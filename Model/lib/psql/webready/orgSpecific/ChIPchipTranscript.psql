     :CREATE_AND_POPULATE
      SELECT DISTINCT ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
                      ta.project_id, ta.org_abbrev, current_timestamp as modification_date,
          CASE
            WHEN ta.is_reversed = 0
            THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
            ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
          END as distance,
          CASE
            WHEN /* distance > 0 */
              CASE WHEN ta.is_reversed = 0
                THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
                ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
              END > 0
            THEN
              CASE
                WHEN ta.is_reversed = 0
                THEN '-'
                ELSE '+'
              END
            ELSE
              CASE
                WHEN ta.is_reversed = 1
                THEN '-'
                ELSE '+'
              END
            END as direction,
          sr.score1 as score
      FROM  :SCHEMA.TranscriptAttributes ta,
            Results.segmentresult sr,
            Study.nodenodeset sl,
            Study.nodeset s
      WHERE   sr.na_sequence_id = ta.na_sequence_id
        AND   s.node_set_id = sl.node_set_id
        AND   sl.protocol_app_node_id = sr.protocol_app_node_id
        AND   lower(s.name) like '%chip%peaks'
        AND   ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                        or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
        AND ta.org_abbrev = ':ORG_ABBREV';

:DECLARE_PARTITION;

