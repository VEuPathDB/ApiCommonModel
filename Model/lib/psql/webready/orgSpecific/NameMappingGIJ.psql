	DROP TABLE IF EXISTS :SCHEMA.:ORG_ABBREVJunExpGIJtmp;
      
        CREATE UNLOGGED TABLE :SCHEMA.:ORG_ABBREVJunExpGIJtmp AS
        WITH ij AS (
          SELECT pj.output_pan_id as junctions_pan_id, p.output_pan_id as expression_pan_id, avg(nafe.value) as avg_value,pan.name as exp_name,
              regexp_replace(pan.name, ' \[htseq-union.*', '') as sample_name
          FROM :SCHEMA.panio p, :SCHEMA.panio pj, results.nafeatureexpression nafe, study.protocolappnode pan
          WHERE pj.output_pan_id in (select distinct protocol_app_node_id from apidb.intronjunction)
                  AND pj.input_pan_id = p.input_pan_id
                  AND p.output_pan_id = pan.protocol_app_node_id
                  AND pan.name like '%tpm - unique%'
                  AND p.output_pan_id = nafe.protocol_app_node_id
		  and p.org_abbrev = ':ORG_ABBREV'
		  and pj.org_abbrev = ':ORG_ABBREV'
          GROUP BY pj.output_pan_id, p.output_pan_id, pan.name
          ORDER BY pj.output_pan_id
        ) , stats AS (
          SELECT protocol_app_node_id, 'total' as type, count(*) as total_junctions,
          sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
          FROM apidb.IntronJunction
          WHERE unique_reads >= 1
          GROUP BY protocol_app_node_id
        ), part AS (
          SELECT
              ij.junctions_pan_id, ij.avg_value, stats.multiplier
              , max(ij.expression_pan_id) OVER w as max_exp_pan_id
              , max(ij.sample_name) OVER w as max_sample_Name
              , max(ij.exp_name) OVER w as max_exp_name
          FROM ij, stats
          WHERE ij.junctions_pan_id = stats.protocol_app_node_id
          WINDOW w AS (partition by ij.junctions_pan_id, stats.multiplier, ij.avg_value)
        )
        SELECT DISTINCT * FROM (
        SELECT junctions_pan_id
               , first_value(max_exp_pan_id) OVER w1 as exp_pan_id
               , first_value(max_sample_name) OVER w1 as sample_name
               , CASE WHEN first_value(max_exp_name) OVER w1 LIKE  '%secondstrand%' THEN 'true' ELSE 'false' END as switch_strands
               , multiplier
        FROM part
        WINDOW w1 AS (PARTITION BY junctions_pan_id, multiplier ORDER BY avg_value DESC)
        ) t
        ORDER BY junctions_pan_id
      
    ;


      
        create index junexpgijtmp_ix on :SCHEMA.:ORG_ABBREVJunExpGIJtmp(junctions_pan_id,exp_pan_id)
      
    ;

        drop table if exists :SCHEMA.:ORG_ABBREVMappingStatsGIJtmp;
      
        CREATE UNLOGGED TABLE :SCHEMA.:ORG_ABBREVMappingStatsGIJtmp (
            junctions_pan_id,
            read_length,
            mapped_reads,
            avg_mapping_coverage,
            num_replicates
        ) AS
           SELECT junctions_pan_id, round(avg(average_read_length - 2),1) as read_length,
                  round(avg(number_mapped_reads),1) as mapped_reads,
                  round(avg(avg_mapping_coverage) * ((avg(average_read_length) - 2) / avg(average_read_length)),2)
                    as avg_mapping_coverage,
                  count(*) as num_replicates
           FROM (SELECT je.junctions_pan_id, ca.value::NUMERIC as average_read_length,
                        cb.value::NUMERIC as number_mapped_reads,
                        cc.value::NUMERIC as avg_mapping_coverage
                 FROM :SCHEMA.:ORG_ABBREVjunexpgijtmp je, STUDY.CHARACTERISTIC ca, sres.ontologyterm ota,
                      panio pj, results.nafeatureexpression nafe, study.protocolappnode pan
          WHERE pj.output_pan_id in (select distinct protocol_app_node_id from apidb.intronjunction)
                  AND pj.input_pan_id = p.input_pan_id
                  AND p.output_pan_id = pan.protocol_app_node_id
                  AND pan.name like '%tpm - unique%'
                  AND p.output_pan_id = nafe.protocol_app_node_id
		  and pj.org_abbrev = ':ORG_ABBREV'
          GROUP BY pj.output_pan_id, p.output_pan_id, pan.name
          ORDER BY pj.output_pan_id
        ) , stats AS (
          SELECT protocol_app_node_id, 'total' as type, count(*) as total_junctions,
          sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
          FROM apidb.IntronJunction
          WHERE unique_reads >= 1
          GROUP BY protocol_app_node_id
        ), part AS (
          SELECT
              ij.junctions_pan_id, ij.avg_value, stats.multiplier
              , max(ij.expression_pan_id) OVER w as max_exp_pan_id
              , max(ij.sample_name) OVER w as max_sample_Name
              , max(ij.exp_name) OVER w as max_exp_name
          FROM ij, stats
          WHERE ij.junctions_pan_id = stats.protocol_app_node_id
          WINDOW w AS (partition by ij.junctions_pan_id, stats.multiplier, ij.avg_value)
        )
        SELECT DISTINCT * FROM (
        SELECT junctions_pan_id
               , first_value(max_exp_pan_id) OVER w1 as exp_pan_id
               , first_value(max_sample_name) OVER w1 as sample_name
               , CASE WHEN first_value(max_exp_name) OVER w1 LIKE  '%secondstrand%' THEN 'true' ELSE 'false' END as switch_strands
               , multiplier
        FROM part
        WINDOW w1 AS (PARTITION BY junctions_pan_id, multiplier ORDER BY avg_value DESC)
        ) t
        ORDER BY junctions_pan_id
      
    ;


:CREATE_AND_POPULATE

      
        CREATE TABLE NameMappingGIJ  AS
        SELECT DISTINCT edp.dataset_presenter_display_name as exp_name,
              edp.external_database_name, je.sample_name,
              je.junctions_pan_id, je.exp_pan_id,
              substr(dp.value, 1, 4000) as presenter_switch_strands,
              substr(sj.value, 1, 4000) as show_intron_junctions,
              substr(uj.value, 1, 4000) as include_unified_junctions,
              ms.read_length, ms.mapped_reads, ms.avg_mapping_coverage, ms.num_replicates,
              je.switch_strands, je.multiplier
        FROM junexpgijtmp je, study.nodeNodeSet sl, study.NodeSet s, ExternalDbDatasetPresenter edp,
             DatasetProperty dp, DatasetProperty sj, DatasetProperty uj, mappingstatsgijtmp ms
        WHERE sl.protocol_app_node_id = je.junctions_pan_id
          AND je.junctions_pan_id = ms.junctions_pan_id
          AND s.node_set_id = sl.node_set_id
          AND s.node_type like 'junctions'
          AND s.external_database_release_id = edp.external_database_release_id
          AND dp.dataset_presenter_id = edp.dataset_presenter_id
          AND dp.property = 'switchStrandsProfiles'
          AND sj.dataset_presenter_id = edp.dataset_presenter_id
          AND sj.property = 'showIntronJunctions'
          AND uj.dataset_presenter_id = edp.dataset_presenter_id
          AND uj.property = 'includeInUnifiedJunctions'
          AND (substr(sj.value, 1, 10) = 'true' or substr(uj.value, 1, 10) = 'true')
      
    
:DECLARE_PARTITION;

