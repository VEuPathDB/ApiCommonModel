/*
 The tuning table this was based on used a loop over the nasequences.   We can add that back if slow but I am:
  1.  using geneattributes which will make this faster than joining genefeature to nalocation and grouping
  2.  using input tables here that are already partitioned
*/
:CREATE_AND_POPULATE
SELECT ga.na_sequence_id
       , ga.start_min
       , ga.is_reversed
       , ga.end_max
       , ga.na_feature_id
       , ga.source_id
       , round(sum(nafe.value)::NUMERIC,2) as total_expression
       , ':PROJECT_ID' as project_id
       , ':ORG_ABBREV' as org_abbrev
       , current_timestamp as modification_date
  FROM  :SCHEMA.GeneAttributes ga
        , :SCHEMA.JunctionToCoverageProfileMapping je
        , results.nafeatureexpression nafe
 WHERE  ga.na_feature_id = nafe.na_feature_id
   AND nafe.protocol_app_node_id = je.exp_pan_id
   AND ga.org_abbrev = ':ORG_ABBREV'
   AND je.org_abbrev = ':ORG_ABBREV'
 GROUP BY ga.na_sequence_id,ga.start_min,ga.is_reversed,ga.end_max,ga.na_feature_id,ga.source_id;
:DECLARE_PARTITION
  ;
