
      
        CREATE UNLOGGED TABLE PanIOgij AS
        SELECT i.protocol_app_id, i.protocol_app_node_id as input_pan_id, o.protocol_app_node_id as output_pan_id
        FROM study.output o, study.input i
        WHERE
          o.protocol_app_node_id in (
            SELECT DISTINCT protocol_app_node_id
            FROM study.protocolappnode where name like '%junctions%' or name like '%htseq%'
          )
          AND o.protocol_app_id = i.protocol_app_id
      
    ;


      
        CREATE UNLOGGED TABLE annotgij (
            na_sequence_id,
            start_min,
            end_max,
            is_reversed,
            feature_type
        ) AS
           SELECT il.na_sequence_id, il.start_min,il.end_max, il.is_reversed, 'Intron' as feature_type
           FROM  apidb.IntronLocation il
           GROUP by il.na_sequence_id, il.start_min,il.end_max,il.is_reversed
      
    ;


      
        CREATE UNIQUE INDEX annottmpnew_pk_ix ON annotgij (na_sequence_id,start_min,end_max,is_reversed,feature_type)

      
    ;


      
        create table GeneIdLocGIJ  (
            na_sequence_id      NUMERIC(10),
            start_min           NUMERIC,
            is_reversed         NUMERIC,
            end_max             NUMERIC,
            na_feature_id       NUMERIC(10),
            source_id           varchar(100),
            total_expression    NUMERIC
        )
      
    ;


      
        CREATE UNIQUE INDEX gnattidloc_pk_ix  ON GeneIdLocGIJ  (na_sequence_id,start_min,is_reversed,end_max,na_feature_id,source_id,total_expression)

      
    ;


      
        DO $$
        DECLARE
          idlist RECORD;
        BEGIN
        FOR idlist IN ( SELECT DISTINCT na_sequence_id FROM apidb.intronjunction)
        LOOP
          INSERT INTO GeneIdLocGIJ   (
          SELECT gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id,
            round(sum(nafe.value)::NUMERIC,2) as total_expression
          FROM  dots.genefeature gf, dots.nalocation l, namemappinggij je, results.nafeatureexpression nafe
          WHERE gf.na_sequence_id = idlist.na_sequence_id
           AND l.na_feature_id = gf.na_feature_id
           AND gf.na_feature_id = nafe.na_feature_id
           AND nafe.protocol_app_node_id = je.exp_pan_id
          GROUP BY gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id
        );
        commit;
        END LOOP;
        END;
        $$ LANGUAGE PLPGSQL;
      
    ;


      
        create index gnidloc_nafid_ix  on GeneIdLocGIJ  (na_feature_id)
      
    ;


      
        create UNLOGGED table GIJtmp (
          NA_SEQUENCE_ID               NUMERIC(10),
          SEQUENCE_SOURCE_ID           VARCHAR(100),
          SEGMENT_START                NUMERIC,
          SEGMENT_END                  NUMERIC,
          TOTAL_UNIQUE                 NUMERIC,
          TOTAL_ISRPM                  NUMERIC,
          IS_REVERSED                  NUMERIC(1),
          INTRON_FEATURE_ID            VARCHAR(200),
          MATCHES_GENE_STRAND          NUMERIC,
          GENE_SOURCE_ID               VARCHAR(100),
          GENE_NA_FEATURE_ID           NUMERIC,
          ANNOTATED_INTRON             VARCHAR(10)
        )
      
    ;


      
        DO $$
        DECLARE
          iter_length numeric := 4999;
          i_first_pos numeric := 1;
          i_last_pos numeric := i_first_pos + iter_length;
          idlist RECORD;
        BEGIN
          FOR idlist IN (
            SELECT na_sequence_id, length, taxon_id, CASE WHEN step_mult > 500000 THEN 500000 ELSE step_mult END as seq_step_mult
            FROM (
              SELECT gs.na_sequence_id, gs.length, gs.taxon_id, 25000 * (1 + floor(gs.length/count(*))) as step_mult
              FROM apidb.intronjunction ij,  dots.nasequence gs
              WHERE gs.na_sequence_id = ij.na_sequence_id
              GROUP BY gs.na_sequence_id, gs.length, gs.taxon_id
            ) t
            ORDER BY taxon_id
            )
          LOOP
            iter_length := idlist.seq_step_mult;
            i_first_pos := 1;
            i_last_pos := i_first_pos + iter_length;
            WHILE i_first_pos < idlist.length
            LOOP
              INSERT INTO GIJtmp
              SELECT DISTINCT
                junc.*,
                CASE
                    WHEN last_value(ga.is_reversed) over w1 = junc.is_reversed
                        THEN 1
                    ELSE 0
                    END as matches_gene_strand,
                last_value(ga.source_id) over w1 as gene_source_id,
                last_value(ga.na_feature_id) over w1 as gene_na_feature_id,
                CASE ag.feature_type WHEN 'Intron' THEN 'Yes' ELSE 'No' END as annotated_intron
              FROM (
                  SELECT ij.na_sequence_id,seq.source_id as sequence_source_id,ij.segment_start,ij.segment_end,
                    sum(ij.unique_reads) as total_unique, round(sum(ij.unique_reads * je.multiplier),2) as total_isrpm,
                    ij.is_reversed,seq.source_id || '_' || ij.segment_start || '_' || ij.segment_end || '_' || ij.is_reversed as intron_feature_id
                  FROM apidb.intronjunction ij, namemappinggij je, dots.nasequence seq
                  WHERE ij.na_sequence_id = idlist.na_sequence_id
                    AND ij.segment_start between i_first_pos and i_last_pos
                    AND ij.na_sequence_id = seq.na_sequence_id
                    AND ij.unique_reads >= 1
                    AND je.junctions_pan_id = ij.protocol_app_node_id
                    AND je.multiplier < 20
                  GROUP BY ij.na_sequence_id,ij.segment_start,ij.segment_end, ij.is_reversed,seq.source_id
                ) junc
                LEFT JOIN GeneIdLocGIJ  ga ON
                  junc.na_sequence_id = ga.na_sequence_id
                  AND junc.segment_start >= ga.start_min
                  AND junc.segment_end <= ga.end_max
                  AND junc.is_reversed = ga.is_reversed
                LEFT JOIN annotgij ag ON
                  junc.na_sequence_id = ag.na_sequence_id
                  AND junc.segment_start = ag.start_min
                  AND junc.segment_end = ag.end_max
                  AND junc.is_reversed = ag.is_reversed
              WHERE (junc.total_unique >= 1 or ag.feature_type = 'Intron')
              WINDOW w1 AS (
                PARTITION BY junc.na_sequence_id,junc.sequence_source_id,junc.segment_start,junc.segment_end, junc.is_reversed, junc.intron_feature_id,junc.total_unique, junc.total_isrpm,ag.feature_type
                ORDER BY ga.total_expression ASC
                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
              )
              ;
              commit;
              i_first_pos := i_last_pos + 1;
              i_last_pos := i_first_pos + iter_length;
            END LOOP;
          END LOOP;
        END;
        $$ LANGUAGE PLPGSQL;
      
    ;


      
        create index gijtmp_gnscid_ix on gijtmp (gene_source_id)
      
    ;

:CREATE_AND_POPULATE

      
        CREATE TABLE GeneIntronJunction  AS
        SELECT
          junc.*, CASE WHEN maxv.gene_source_id is not null and maxv.max_isrpm > 0 THEN round((junc.total_isrpm / maxv.max_isrpm) * 100,2) ELSE null END as percent_max,
          CASE WHEN maxv.gene_source_id is not null THEN 1 ELSE 0 END as contained,
          CAST (null as numeric(10)) as taxon_id,
          cast (null as numeric(10)) as upstream_gene_id,
          cast (null as numeric) as upstream_distance,
          cast (null as numeric(10)) as downstream_gene_id,
          cast (null as numeric) as downstream_distance
        FROM
          gijtmp junc LEFT JOIN
          (
            SELECT gene_source_id,max(total_unique) as max_unique, max(total_isrpm) as max_isrpm
            FROM gijtmp
            WHERE gene_source_id is not null
            GROUP BY gene_source_id
          ) maxv ON junc.gene_source_id = maxv.gene_source_id
      
    
:DECLARE_PARTITION;


      
        UPDATE GeneIntronJunction  gij
        SET taxon_id
            = (SELECT taxon_id
               FROM dots.NaSequence
               WHERE na_sequence_id = gij.na_sequence_id)
      
    ;

