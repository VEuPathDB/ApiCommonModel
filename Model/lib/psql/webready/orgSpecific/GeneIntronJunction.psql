drop table if exists :SCHEMA.:ORG_ABBREVDistinctAnnotatedIntronsTmp;

drop table if exists :SCHEMA.:ORG_ABBREVGIJtmp;

/*
 Distinct Annotated Intron Locations
*/
CREATE UNLOGGED TABLE :SCHEMA.:ORG_ABBREVDistinctAnnotatedIntronsTmp (
  na_sequence_id,
  start_min,
  end_max,
  is_reversed,
  feature_type
) AS
  SELECT il.na_sequence_id
         , il.start_min
         , il.end_max
         , il.is_reversed
         , 'Intron' as feature_type
    FROM  apidb.IntronLocation il
          , dots.nasequence s
   WHERE il.na_sequence_id = s.na_sequence_id
     AND s.taxon_id = :TAXON_ID
   GROUP by il.na_sequence_id
            , il.start_min
            , il.end_max
            , il.is_reversed

            ;
      
CREATE UNIQUE INDEX :ORG_ABBREV_annottmpnew_pk_ix ON :SCHEMA.:ORG_ABBREVDistinctAnnotatedIntronsTmp (na_sequence_id,start_min,end_max,is_reversed,feature_type)
      
    ;

/*
  this table does the heavy lifting for gene intron junction calculations
*/
create UNLOGGED table :SCHEMA.:ORG_ABBREVGIJtmp (
  NA_SEQUENCE_ID               NUMERIC(10),
  SEQUENCE_SOURCE_ID           VARCHAR(100),
  SEGMENT_START                NUMERIC,
  SEGMENT_END                  NUMERIC,
  TOTAL_UNIQUE                 NUMERIC,
  TOTAL_ISRPM                  NUMERIC,
  IS_REVERSED                  NUMERIC(1),
  INTRON_FEATURE_ID            VARCHAR(200),
  MATCHES_GENE_STRAND          NUMERIC,
  GENE_SOURCE_ID               VARCHAR(100),
  GENE_NA_FEATURE_ID           NUMERIC,
  ANNOTATED_INTRON             VARCHAR(10)
)
  ;

      
DO $$
  DECLARE
    iter_length numeric := 4999 :PLPGSQL_DELIM
    i_first_pos numeric := 1 :PLPGSQL_DELIM
    i_last_pos numeric := i_first_pos + iter_length :PLPGSQL_DELIM
    idlist RECORD :PLPGSQL_DELIM
  BEGIN
    FOR idlist IN (
      SELECT na_sequence_id
             , source_id as sequence_source_id
             , length
             , taxon_id
             , CASE WHEN step_mult > 500000 THEN 500000 ELSE step_mult END as seq_step_mult
        FROM (
          SELECT gs.na_sequence_id
                 , gs.source_id
                 , gs.length
                 , gs.taxon_id
                 , 25000 * (1 + floor(gs.length/count(*))) as step_mult
            FROM apidb.intronjunction ij
                 ,  dots.nasequence gs
           WHERE gs.na_sequence_id = ij.na_sequence_id
             AND gs.taxon_id = :TAXON_ID
           GROUP BY gs.na_sequence_id, gs.source_id, gs.length, gs.taxon_id
        )
    )
    LOOP
      iter_length := idlist.seq_step_mult :PLPGSQL_DELIM
      i_first_pos := 1 :PLPGSQL_DELIM
      i_last_pos := i_first_pos + iter_length :PLPGSQL_DELIM
      WHILE i_first_pos < idlist.length
      LOOP
        INSERT INTO :SCHEMA.:ORG_ABBREVGIJtmp
        SELECT DISTINCT
          junc.*,
          CASE
          WHEN last_value(ga.is_reversed) over w1 = junc.is_reversed
            THEN 1
          ELSE 0
          END as matches_gene_strand,
          last_value(ga.source_id) over w1 as gene_source_id,
          last_value(ga.na_feature_id) over w1 as gene_na_feature_id,
          CASE ag.feature_type WHEN 'Intron' THEN 'Yes' ELSE 'No' END as annotated_intron
          FROM (
            SELECT ij.na_sequence_id
                   , idlist.sequence_source_id
                   , ij.segment_start
                   , ij.segment_end
                   , sum(ij.unique_reads) as total_unique
                   , round(sum(ij.unique_reads * je.multiplier),2) as total_isrpm
                   , ij.is_reversed
                   , idlist.sequence_source_id || '_' || ij.segment_start || '_' || ij.segment_end || '_' || ij.is_reversed as intron_feature_id
              FROM apidb.intronjunction ij
                   , :SCHEMA.JunctionToCoverageProfileMapping je
             WHERE ij.na_sequence_id = idlist.na_sequence_id
               AND ij.segment_start between i_first_pos and i_last_pos
               AND ij.unique_reads >= 1
               AND je.junctions_pan_id = ij.protocol_app_node_id
               AND je.multiplier < 20
               AND je.org_abbrev = ':ORG_ABBREV'
             GROUP BY ij.na_sequence_id
                      , ij.segment_start
                      , ij.segment_end
                      , ij.is_reversed
                      , idlist.sequence_source_id
          ) junc
               LEFT JOIN :SCHEMA.JunctionGeneLocation ga
                   ON junc.na_sequence_id = ga.na_sequence_id
                   AND ga.org_abbrev = ':ORG_ABBREV'
                   AND junc.segment_start >= ga.start_min
                   AND junc.segment_end <= ga.end_max
                   AND junc.is_reversed = ga.is_reversed
               LEFT JOIN :SCHEMA.:ORG_ABBREVDistinctAnnotatedIntronsTmp ag
                   ON junc.na_sequence_id = ag.na_sequence_id
                   AND junc.segment_start = ag.start_min
                   AND junc.segment_end = ag.end_max
                   AND junc.is_reversed = ag.is_reversed
         WHERE (junc.total_unique >= 1 or ag.feature_type = 'Intron')
               WINDOW w1 AS (
                 PARTITION BY junc.na_sequence_id,junc.sequence_source_id,junc.segment_start,junc.segment_end, junc.is_reversed, junc.intron_feature_id,junc.total_unique, junc.total_isrpm,ag.feature_type
                 ORDER BY ga.total_expression ASC
                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
               )
                :PLPGSQL_DELIM
        commit :PLPGSQL_DELIM
        i_first_pos := i_last_pos + 1 :PLPGSQL_DELIM
        i_last_pos := i_first_pos + iter_length :PLPGSQL_DELIM
      END LOOP :PLPGSQL_DELIM
    END LOOP :PLPGSQL_DELIM
  END :PLPGSQL_DELIM
$$ LANGUAGE PLPGSQL :PLPGSQL_DELIM
      
; 

      
create index :ORG_ABBREV_gijtmp_gnscid_ix on :SCHEMA.:ORG_ABBREVGIJtmp (gene_source_id)
      
  ;

:CREATE_AND_POPULATE
  SELECT
    junc.*
    , CASE
        WHEN maxv.gene_source_id is not null and maxv.max_isrpm > 0
        THEN round((junc.total_isrpm / maxv.max_isrpm) * 100,2)
        ELSE null
      END as percent_max
    , CASE
        WHEN maxv.gene_source_id is not null
        THEN 1
        ELSE 0
      END as contained
    , :TAXON_ID as taxon_id
--    , CAST (null as numeric(10)) as upstream_gene_id
--    , CAST (null as numeric) as upstream_distance
--    , CAST (null as numeric(10)) as downstream_gene_id
--    , CAST (null as numeric) as downstream_distance
    , ':PROJECT_ID' as project_id
    , ':ORG_ABBREV' as org_abbrev
    , current_timestamp as modification_date
    FROM
      :SCHEMA.:ORG_ABBREVGIJtmp junc LEFT JOIN
      (
        SELECT gene_source_id,max(total_unique) as max_unique, max(total_isrpm) as max_isrpm
          FROM :SCHEMA.:ORG_ABBREVGIJtmp
         WHERE gene_source_id is not null
         GROUP BY gene_source_id
      ) maxv ON junc.gene_source_id = maxv.gene_source_id
:DECLARE_PARTITION
        ;



drop table :SCHEMA.:ORG_ABBREVDistinctAnnotatedIntronsTmp
  ;

drop table :SCHEMA.:ORG_ABBREVGIJtmp
  ;
