DROP TABLE IF EXISTS :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp;

create unlogged table :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp as
(select gf.na_feature_id
      , gf.source_id
      , gf.product
 from dots.genefeature gf
    , dots.nasequence nas
 where gf.na_sequence_id = nas.na_sequence_id
 and nas.taxon_id = :TAXON_ID
)
;


:CREATE_AND_POPULATE
  WITH
    -- Identify 1:1 gene:transcript relationships for this organism
    one_to_one_genes AS (
      SELECT gf.na_feature_id as gene_na_feature_id,
             gf.source_id as gene_source_id,
             MAX(t.na_feature_id) as transcript_na_feature_id
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      LEFT JOIN dots.Transcript t ON t.parent_id = gf.na_feature_id
      GROUP BY gf.na_feature_id, gf.source_id
      HAVING COUNT(t.na_feature_id) = 1
    ),

    -- Priority 1: Preferred curated gene products
    gene_curated_preferred AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT gfp.product, ', ' ORDER BY gfp.product), 1, 4000) as product,
             1 as source_rule,
             COUNT(DISTINCT gfp.product) as value_count,
             'preferred_curated_gene' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN apidb.GeneFeatureProduct gfp ON gfp.na_feature_id = gf.na_feature_id
      WHERE gfp.assigned_by IN ('Sanger', 'VEuPathDB', 'Apollo')
        AND gfp.is_preferred = 1
        AND gfp.product IS NOT NULL
      GROUP BY gf.source_id
    ),

    -- Priority 2: Any curated gene products
    gene_curated_any AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT gfp.product, ', ' ORDER BY gfp.product), 1, 4000) as product,
             2 as source_rule,
             COUNT(DISTINCT gfp.product) as value_count,
             'curated_gene' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN apidb.GeneFeatureProduct gfp ON gfp.na_feature_id = gf.na_feature_id
      WHERE gfp.assigned_by IN ('Sanger', 'VEuPathDB', 'Apollo')
        AND gfp.product IS NOT NULL
      GROUP BY gf.source_id
    ),

    -- Priority 3: 1:1 + Preferred curated transcript products
    transcript_curated_preferred_one_to_one AS (
      SELECT oto.gene_source_id as source_id,
             SUBSTR(STRING_AGG(DISTINCT tp.product, ', ' ORDER BY tp.product), 1, 4000) as product,
             3 as source_rule,
             COUNT(DISTINCT tp.product) as value_count,
             'preferred_curated_transcript_1to1' as rule_description
      FROM one_to_one_genes oto
      INNER JOIN apidb.TranscriptProduct tp ON tp.na_feature_id = oto.transcript_na_feature_id
      WHERE tp.assigned_by IN ('Sanger', 'VEuPathDB', 'Apollo')
        AND tp.is_preferred = 1
        AND tp.product IS NOT NULL
      GROUP BY oto.gene_source_id
    ),

    -- Priority 4: 1:1 + Any curated transcript products
    transcript_curated_any_one_to_one AS (
      SELECT oto.gene_source_id as source_id,
             SUBSTR(STRING_AGG(DISTINCT tp.product, ', ' ORDER BY tp.product), 1, 4000) as product,
             4 as source_rule,
             COUNT(DISTINCT tp.product) as value_count,
             'curated_transcript_1to1' as rule_description
      FROM one_to_one_genes oto
      INNER JOIN apidb.TranscriptProduct tp ON tp.na_feature_id = oto.transcript_na_feature_id
      WHERE tp.assigned_by IN ('Sanger', 'VEuPathDB', 'Apollo')
        AND tp.product IS NOT NULL
      GROUP BY oto.gene_source_id
    ),

    -- Priority 5: ARBA annotations
    gene_arba AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT gfp.product, ', ' ORDER BY gfp.product), 1, 4000) as product,
             5 as source_rule,
             COUNT(DISTINCT gfp.product) as value_count,
             'arba_gene' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN apidb.GeneFeatureProduct gfp ON gfp.na_feature_id = gf.na_feature_id
      WHERE gfp.assigned_by = 'ARBA'
        AND gfp.product IS NOT NULL
      GROUP BY gf.source_id
    ),

    -- Priority 6: All gene products (concatenated)
    gene_all AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT gfp.product, ', ' ORDER BY gfp.product), 1, 4000) as product,
             6 as source_rule,
             COUNT(DISTINCT gfp.product) as value_count,
             'all_gene' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN apidb.GeneFeatureProduct gfp ON gfp.na_feature_id = gf.na_feature_id
      WHERE gfp.product IS NOT NULL
      AND gfp.product != 'hypothetical protein'
      GROUP BY gf.source_id
    ),

    -- Priority 7: All transcript products (concatenated)
    transcript_all AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT tp.product, ', ' ORDER BY tp.product), 1, 4000) as product,
             7 as source_rule,
             COUNT(DISTINCT tp.product) as value_count,
             'all_transcript' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN dots.Transcript t ON t.parent_id = gf.na_feature_id
      INNER JOIN apidb.TranscriptProduct tp ON tp.na_feature_id = t.na_feature_id
      WHERE tp.product IS NOT NULL
      AND tp.product != 'hypothetical protein'
      GROUP BY gf.source_id
    ),

    -- Priority 8: Base gene product field
    gene_base AS (
      SELECT gf.source_id,
             gf.product,
             8 as source_rule,
             1 as value_count,
             'base_gene' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      WHERE gf.product IS NOT NULL
    ),

    -- Priority 9: Base transcript product field (concatenated)
    transcript_base AS (
      SELECT gf.source_id,
             SUBSTR(STRING_AGG(DISTINCT t.product, ', ' ORDER BY t.product), 1, 4000) as product,
             9 as source_rule,
             COUNT(DISTINCT t.product) as value_count,
             'base_transcript' as rule_description
      FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
      INNER JOIN dots.Transcript t ON t.parent_id = gf.na_feature_id
      WHERE t.product IS NOT NULL
      AND t.product != 'hypothetical protein'
      GROUP BY gf.source_id
    ),

    -- Combine all priorities
    all_products AS (
      SELECT * FROM gene_curated_preferred
      UNION ALL SELECT * FROM gene_curated_any
      UNION ALL SELECT * FROM transcript_curated_preferred_one_to_one
      UNION ALL SELECT * FROM transcript_curated_any_one_to_one
      UNION ALL SELECT * FROM gene_arba
      UNION ALL SELECT * FROM gene_all
      UNION ALL SELECT * FROM transcript_all
      UNION ALL SELECT * FROM gene_base
      UNION ALL SELECT * FROM transcript_base
    ),

    -- Select highest priority product per gene
    ranked_products AS (
      SELECT source_id, product, source_rule, value_count, rule_description,
             ROW_NUMBER() OVER (PARTITION BY source_id ORDER BY source_rule) as rank
      FROM all_products
    )
  SELECT gf.source_id,
         COALESCE(rp.product, 'unspecified product') as product,
         COALESCE(rp.value_count, 0) as value_count,
         COALESCE(rp.source_rule, 10) as source_rule,
         COALESCE(rp.rule_description, 'unspecified') as source_rule_description,
         ':PROJECT_ID' as project_id,
         ':ORG_ABBREV' as org_abbrev,
         current_timestamp as modification_date
  FROM :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp gf
  LEFT JOIN ranked_products rp ON gf.source_id = rp.source_id AND rp.rank = 1;
:DECLARE_PARTITION;


/*


Dependent Step
  gene/protein_id -> uniprot accession and product

This step will assume it has all uniprot accessions assined to the protein and uniprot product name and have pfams in our hand




*/

delete from :SCHEMA.GeneProduct_p  where product is null and org_abbrev = ':ORG_ABBREV';

drop table :SCHEMA.:CLEAN_ORG_ABBREVGeneFeatureProductTmp
;
