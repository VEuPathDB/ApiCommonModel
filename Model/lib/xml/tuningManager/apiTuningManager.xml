<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <import file="tuningManager.xml"/>

  <!-- unpartitioned version of this table -->
 <tuningTable name="GeneAttributes">
    <externalDependency name="webready.GeneAttributes_p"/>
    <sql>
      <![CDATA[
       create table geneattributes&1 as select * from webready.geneattributes_p;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX geneattr_sourceId&1 ON GeneAttributes&1  (source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX geneattr_featId&1 ON GeneAttributes&1  (na_feature_id, source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX geneattr_t_p&1 ON GeneAttributes&1  (taxon_id, project_id, source_id, is_pseudo, gene_type);
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="TranscriptAttributes">
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <sql>
      <![CDATA[
       create table transcriptattributes&1 as select * from webready.transcriptattributes_p;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX transcriptattr_sourceId&1 ON TranscriptAttributes&1  (source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX transcriptattr_genesourceId&1 ON TranscriptAttributes&1  (gene_source_id, source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX transcriptattr_t_p&1 ON TranscriptAttributes&1  (taxon_id, project_id, source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX transcriptattr_gnf&1 ON TranscriptAttributes&1  (gene_na_feature_id, gene_source_id, project_id, source_id);
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="ProteinAttributes">
    <externalDependency name="webready.ProteinAttributes_p"/>
    <sql>
      <![CDATA[
       create table proteinattributes&1 as select * from webready.proteinattributes_p;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX proteinattr_sourceId&1 ON ProteinAttributes&1  (source_id);
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="GenomicSeqAttributes">
    <externalDependency name="webready.Genomicseqattributes_p"/>
    <sql>
      <![CDATA[
       create table genomicseqattributes&1 as select * from webready.genomicseqattributes_p;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX genomicseqattr_sourceId&1 ON Genomicseqattributes&1  (source_id);
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX genomicseqattr_t_p&1 ON GenomicSeqAttributes&1  (taxon_id, project_id, source_id);
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="GoTermSummary">
    <externalDependency name="webready.GoTermSummary_p"/>
    <sql>
      <![CDATA[
       create table GoTermSummary&1 as select * from webready.gotermsummary_p;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSumTT_aaSeqId_idx ON GoTermSummary&1  (aa_sequence_id, go_id, source)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSumTT_taxId_idx ON GoTermSummary&1  (taxon_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSumTT_plugin_ix ON GoTermSummary&1
               (gene_source_id, ontology, is_not, is_go_slim,
                go_id, go_term_name, evidence_code, evidence_category)
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="TaxonSpecies">
    <externalDependency name="webready.TaxonSpecies_p"/>
     <sql>
      <![CDATA[
       create table taxonspecies&1 as select * from webready.taxonspecies_p;
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned (and thin) version of this table -->
 <tuningTable name="PathwayGenesThin">
    <externalDependency name="webready.PathwaysGeneTable_p"/>
    <sql>
      <![CDATA[
       create table PathwayGenesThin&1 as select pathway_source_id, gene_source_id from webready.pathwaysgenetable_p
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index pathgene_ix&1 on PathwayGenesThin&1 (pathway_source_id, gene_source_id)
      ]]>
    </sql>
  </tuningTable>

  <!-- unpartitioned version of this table -->
 <tuningTable name="TranscriptPathway">
    <externalDependency name="webready.TranscriptPathway_p"/>
    <sql>
      <![CDATA[
       create table TranscriptPathway&1 as select * from webready.TranscriptPathway_p
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index TranscriptPathTT_1_ix&1 on TranscriptPathway&1 (gene_source_id, complete_ec, exact_match, pathway_source, pathway_id, ec_number_gene, pathway_source, pathway_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index TranscriptPathTT_2_ix&1 on TranscriptPathway&1 (ec_number_gene, pathway_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index TranscriptPathTT_3_ix&1 on TranscriptPathway&1 (pathway_id, gene_source_id, ec_number_gene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index TranscriptPathTT_4_ix&1 on TranscriptPathway&1 (complete_ec, exact_match, external_database_release_id)
      ]]>
    </sql>
  </tuningTable>

 <tuningTable name="GeneOrgAbbrev">
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
         CREATE TABLE GeneOrgAbbrev&1 AS
          SELECT source_id, org_abbrev
          FROM Geneattributes
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneOrgAbbrev_idx&1 ON GeneOrgAbbrev&1 (source_id, org_abbrev)
      ]]>
    </sql>
  </tuningTable>

 <tuningTable name="TranscriptOrgAbbrev">
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
         CREATE TABLE TranscriptOrgAbbrev&1 AS
          SELECT source_id, gene_source_id, org_abbrev
          FROM Transcriptattributes
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptOrgAbbrev_idx&1 ON TranscriptOrgAbbrev&1 (source_id, gene_source_id, org_abbrev)
      ]]>
    </sql>
  </tuningTable>

 <tuningTable name="GenomicSeqOrgAbbrev">
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
         CREATE TABLE GenomicSeqOrgAbbrev&1 AS
          SELECT source_id, org_abbrev
          FROM GenomicSeqattributes
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GenomicSeqOrgAbbrev_idx&1 ON GenomicSeqOrgAbbrev&1 (source_id, org_abbrev)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GoSubsetLeaf">
    <comment>
      Map each GO term that is assigned to at least one gene to a GoSubset term
      that is either itself or an immediate ancestor. By "immediate ancestor"
      we mean an ancestor such that there isn't an intermediate ancestor also
      in the subset. (Note that there can be multiple links as long as none is
      in the subset.) This is currently restricted to 'goslim_generic', solely
      by the condition in the SUBSET_TERM subquery.
    </comment>
    <externalDependency name="apidb.GoSubset"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="dots.goassociation"/>
    <sql>
      <![CDATA[
        create table GoSubsetLeaf&1 as
        with leaf_term -- GO terms assigned to at least one gene
             as (select distinct go_term_id
                 from dots.goassociation),
             subset_term -- (term ID, subset name) pairs
             as (select distinct -- "distinct" is probably unneeded
                        ontology_term_id, go_subset_term
                 from apidb.GoSubset
                 -- where go_subset_term != 'gosubset_prok' -- unrelated and huge
                 where go_subset_term = 'goslim_generic' -- all we currently need
                ),
             subset -- the 17 or so distinct subset names, e.g. "goslim_generic"
             as (select distinct go_subset_term
                 from subset_term),
             leaf_in_subset -- leaf (i.e. assigned) terms that are in a subset
             as (select leaf_term.go_term_id, subset_term.go_subset_term
                 from leaf_term, subset_term
                 where leaf_term.go_term_id = subset_term.ontology_term_id),
             leaf_not_in_subset -- (go_term_id, subset) pairs such that the GO
             as (               -- term is assigned, but not in the given subset
                   select leaf_term.go_term_id, subset.go_subset_term
                   from leaf_term, subset -- cartesian join
                   EXCEPT
                   select go_term_id, go_subset_term
                   from leaf_in_subset),
             leaf_ancestor -- a leaf not in a subset, with an ancestor that is in the subset
             as (select lnis.go_subset_term, lnis.go_term_id, gs.ontology_term_id as ancestor_term_id
                 from leaf_not_in_subset lnis, sres.OntologyRelationship orel, apidb.GoSubset gs
                 where orel.subject_term_id = lnis.go_term_id -- "subject" = "child"
                   and orel.object_term_id = gs.ontology_term_id
                   and orel.subject_term_id != orel.object_term_id
                   and lnis.go_subset_term = gs.go_subset_term),
             leaf_nonimmediate_ancestor
             as (select distinct upper.go_subset_term, upper.go_term_id, upper.ancestor_term_id
                 from leaf_ancestor upper, leaf_ancestor lower, sres.OntologyRelationship orel
                 where upper.go_subset_term = lower.go_subset_term
                   and upper.go_term_id = lower.go_term_id
                   and upper.ancestor_term_id = orel.object_term_id
                   and lower.ancestor_term_id = orel.subject_term_id
                   and orel.subject_term_id != orel.object_term_id),
             leaf_immediate_ancestor
             as (  select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_ancestor
                   EXCEPT
                   select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_nonimmediate_ancestor)
          select -- leaf terms that are in a subset
                 cast (go_subset_term as varchar(50)) as go_subset_term, go_term_id, go_term_id as subset_leaf_term_id
          from leaf_in_subset
        union
          select -- leaf terms not in subset with their subset immediate ancestors
                 cast (go_subset_term as varchar(50)) as go_subset_term, go_term_id, ancestor_term_id as subset_leaf_term_id
          from leaf_immediate_ancestor
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gsl_ix&1 ON GoSubsetLeaf&1 (go_term_id, go_subset_term, subset_leaf_term_id)

      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
      each dataset gets one such row.
      Used in dataset record queries.
    </comment>
    <externalDependency name="sres.ExternalDatabase"/>
    <internalDependency name="Profile"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE DatasetExampleSourceId&1 AS
        WITH profiles AS (
          SELECT p.source_id,
                 ga.project_id,
                 ga.sequence_id,
                 d.name,
                 row_number() over(partition by d.name
                                   order by ga.chromosome_order_num, p.profile_as_string desc) as rn
          FROM Profile p
            INNER JOIN sres.ExternalDatabase d ON p.dataset_name = d.name
            LEFT JOIN Geneattributes ga ON p.source_id = ga.source_id
          WHERE p.profile_as_string is not null
        )
        SELECT p.source_id as example_source_id, p.project_id, p.sequence_id, p.name as dataset
        FROM profiles p
        WHERE p.rn = 1
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="GeneWord">
    <!-- Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
      -->
    <externalDependency name="webready.GeneAttributes_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="apidb.Organism"/>

    <!-- Create empty table structure -->
    <sql>
      <![CDATA[
        CREATE TABLE GeneWord&1 (
          source_id varchar(80),
          taxon_id numeric(12),
          word varchar(200)
        )
      ]]>
    </sql>

    <!-- Loop over organisms and insert data -->
    <sql>
      <![CDATA[
        do $$
        declare
          v_org_abbrev TEXT;
        begin
          for v_org_abbrev in select org_abbrev from webready.OrganismAbbreviation_p loop
            insert into GeneWord&1
            select source_id, taxon_id,
                   -- for each rn (1 - max_words_in_any_product),
                   --    print the rn-th word.
                   --    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN
                   substr(regexp_replace(regexp_substr (product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
            from webready.GeneAttributes_p
            cross join (
              -- create a table of integers 1 - n where n is the max number of words in any product
              select generate_series(1,(select max (regexp_count (product, '[ ,]')) + 1 mx from webready.GeneAttributes_p where org_abbrev = v_org_abbrev)) as rn
            ) t
            where org_abbrev = v_org_abbrev
              and regexp_substr (product, '[^, ]+', 1, rn) is not null
            order by source_id;
          end loop;
        end $$;
      ]]>
    </sql>

    <!-- Create index -->
    <sql>
      <![CDATA[
        create index GeneWord_idx&1 ON GeneWord&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
      as by project_id(), the function that maps an organism to a project.
    </comment>
    <externalDependency name="webready.TaxonSpecies_p"/>
    <externalDependency name="webready.ChIPchipTranscript_p"/>
    <externalDependency name="webready.GeneAttributes_p"/>
    <externalDependency name="webready.GenomicSeqAttributes_p"/>
    <externalDependency name="webready.GoTermSummary_p"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="webready.EstAlignmentGeneSummary_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="webready.EstAttributes_p"/>
    <externalDependency name="webready.TFBSGene_p"/>
    <internalDependency name="Profile"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <!--  <internalDependency name="webready.SnpAttributes"/> -->
    <externalDependency name="apidb.Datasource"/>
    <!--externalDependency name="dots.Similarity"/ -->
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="OrganismCentromere"/>
    <intermediateTable name="SequenceCount"/>
    <!--intermediateTable name="CommunityCount"/-->
    <intermediateTable name="ProfileCount"/>
    <!-- <intermediateTable name="PopsetCount"/> -->
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE DataSourceCount AS
        SELECT
          taxon_id,
          max(CASE WHEN stype = 'organellar' THEN num ELSE null END) as organellar_has,
          max(CASE WHEN stype = 'Epitope'  THEN num ELSE null END)  as Epitope_has,
          max(CASE WHEN stype = 'Array'  THEN num ELSE null END) as Array_has,
          max(CASE WHEN stype = 'HTSIsolate' THEN num ELSE null END) as HTSIsolate_has,
          max(CASE WHEN stype = 'Popset' THEN num ELSE null END) as Popset_has
        FROM (
          SELECT DISTINCT enas.taxon_id, 'organellar' AS stype, 1 AS num
          FROM dots.externalNAsequence enas, SRES.ontologyterm ot
          WHERE enas.sequence_ontology_id = ot.ontology_term_id
            AND ot.name in( 'mitochondrial_chromosome','apicoplast_chromosome')
          GROUP BY enas.taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'HTSIsolate' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'isolates' AND ds.subtype = 'HTS_SNP'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Popset' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.subtype = 'sequenceing_types'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Epitope' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'epitope'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Array' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'transcript_expression'
            AND ds.subtype = 'array'
          GROUP BY  taxon_id
        ) t
        GROUP BY taxon_id
    ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE OrganismCentromere AS
        SELECT distinct s.taxon_id,
               case when count(*) > 0 then 1 else 0 end as hasCentromere
        FROM  DOTS.MISCELLANEOUS f
            , sres.ontologyTerm ot
            , dots.nasequence s
        WHERE ot.ontology_term_id = f.sequence_ontology_id
         AND ot.name='centromere'
         AND f.na_sequence_id = s.na_sequence_id
        GROUP BY s.taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE SequenceCount AS
        SELECT
          taxon_id,
          max(CASE WHEN sequence_type = 'contig' THEN num ELSE null END) as  contig_num,
          max(CASE WHEN sequence_type = 'supercontig' THEN num ELSE null END) as  supercont_num,
          max(CASE WHEN sequence_type = 'chromosome' THEN num ELSE null END) as  chrom_num
        FROM (
         SELECT count(*) as num, sequence_type, taxon_id
         FROM GenomicSeqattributes
         WHERE is_top_level =1
         GROUP BY taxon_id, sequence_type
        ) t
        GROUP BY taxon_id
      ]]>
    </sql>


<!--    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE CommunityCount AS
        SELECT taxon_id, count(*) as communityCount
        FROM Geneattributes
        WHERE (source_id, project_id) IN (
              SELECT distinct stable_id, project_name
              FROM userlogins5.mappedComment
              WHERE is_visible = 1
                AND comment_target_id = 'gene'
          )
        GROUP BY taxon_id
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE ProfileCount AS
        SELECT ga.taxon_id,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                 and p.dataset_subtype like '%rt_pcr%'
                 and ga.is_deprecated = 0
                then p.source_id
                else ''
                 end)) as rtPCRCount,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                               and p.dataset_subtype = 'rnaseq'
                               and ga.is_deprecated = 0
                              then p.source_id
                              else ''
                               end)) as rnaSeqCount,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                               and p.dataset_subtype = 'array'
                               and ga.is_deprecated = 0
                              then p.source_id
                              else ''
                               end)) as geneArrayCount
        FROM Profile p
          RIGHT OUTER JOIN Geneattributes ga ON ga.source_id = p.source_id
        GROUP BY ga.taxon_id
      ]]>
    </sql>

<!--
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE PopsetCount AS
        SELECT count(distinct gene.source_id) as popsetCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, nas.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s, PopsetAttributes i,
                core.tableinfo t, dots.nasequence nas
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND s.pvalue_exp <= -10
           ) sim LEFT JOIN
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, PopsetAttributes i, Geneattributes g,
                  core.tableinfo t, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  g.end_max
              AND s.max_subject_end >= g.start_min
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           ON gene.source_id = sim.source_id AND gene.sequence_id = sim.sequence_source_id)
        GROUP BY sim.taxon_id
      ]]>
    </sql>
    -->

    <sql>
      <![CDATA[
       CREATE UNLOGGED TABLE genecount
        (
         taxon_id numeric(10,0),
         project_id text,
         database_version text, 
         ncbi_tax_id numeric,
         megabps numeric,
         genecount bigint,
         pseudogenecount bigint,
         codinggenecount bigint,
         othergenecount bigint,
         chipchipgenecount bigint,
         orthologcount bigint,
         gocount bigint,
         tfbscount bigint,
         estcount bigint,
         proteomicscount bigint,
         ecnumbercount bigint
      );

     DO $$
     DECLARE
      v_org_abbrev TEXT;
     BEGIN
     FOR v_org_abbrev IN SELECT org_abbrev from webready.OrganismAbbreviation_p LOOP
	INSERT INTO genecount
	WITH genomestat AS (
	  SELECT  
		  project_id,
		  taxon_id,
		  org_abbrev,
		  max(database_version) AS database_version,
		  CASE WHEN ncbi_tax_id > 9000000000 THEN NULL ELSE ncbi_tax_id END AS ncbi_tax_id,
		  (sum(length)/1000000.0)::numeric AS megabps
	  FROM webready.GenomicSeqAttributes_p
	  WHERE is_top_level = 1 and org_abbrev = v_org_abbrev
	  GROUP BY project_id, taxon_id, ncbi_tax_id, org_abbrev
	), cct AS (
	  select
		COUNT(DISTINCT cct.gene_source_id) as chipchipGeneCount
	  from webready.GeneAttributes_p ga ,webready.ChIPchipTranscript_p cct
	   	WHERE ga.is_deprecated = 0
		  	and cct.gene_source_id = ga.source_id
		  	AND ga.org_abbrev = cct.org_abbrev
	   and ga.org_abbrev = v_org_abbrev
	   and cct.org_abbrev = v_org_abbrev
	), gene as (
	  select 
	  	COUNT(DISTINCT ga.source_id) AS geneCount,
		COUNT(DISTINCT ga.source_id) FILTER (WHERE ga.is_pseudo = 1) AS pseudoGeneCount,
		COUNT(DISTINCT ga.source_id) FILTER (WHERE ga.gene_type IN ('protein coding','protein coding gene')) AS codingGeneCount,
		COUNT(DISTINCT ga.source_id) FILTER (WHERE ga.gene_type NOT IN ('protein coding','protein coding gene')) AS otherGeneCount
	  from webready.GeneAttributes_p ga
	  where org_abbrev = v_org_abbrev
	), ortholog AS (
		SELECT
			COUNT(DISTINCT pp.source_id) FILTER (WHERE ga.is_deprecated = 0) AS orthologCount
		FROM webready.GeneAttributes_p ga, apidb.phylogeneticprofile pp 
		WHERE ga.source_id = pp.source_id 
			and ga.org_abbrev = v_org_abbrev
	), go AS (
		SELECT
			COUNT(DISTINCT gts.gene_source_id) FILTER (WHERE ga.is_deprecated = 0) AS goCount
		FROM webready.GeneAttributes_p ga, webready.GoTermSummary_p gts 
		WHERE ga.source_id = gts.gene_source_id 
			AND ga.org_abbrev = gts.org_abbrev
			AND gts.org_abbrev = v_org_abbrev and ga.org_abbrev =v_org_abbrev
	), tfbs AS (
		SELECT
			COUNT(DISTINCT tfbs.gene_source_id) FILTER (WHERE ga.is_deprecated = 0) AS tfbsCount
		FROM webready.GeneAttributes_p ga, webready.TFBSGene_p tfbs 
		WHERE ga.source_id = tfbs.gene_source_id 
			AND ga.org_abbrev = tfbs.org_abbrev
			AND tfbs.org_abbrev = v_org_abbrev and ga.org_abbrev = v_org_abbrev
	), mss AS (
		SELECT
			COUNT(DISTINCT mss.aa_sequence_id) FILTER (WHERE ga.is_deprecated = 0) AS proteomicsCount
		FROM webready.GeneAttributes_p ga, webready.TranscriptAttributes_p ta 
			,apidb.MassSpecSummary mss 
		WHERE ta.gene_source_id = ga.source_id 
			AND ta.aa_sequence_id = mss.aa_sequence_id
			-- AND ga.org_abbrev = ta.org_abbrev
			AND ta.org_abbrev = v_org_abbrev
			AND ga.org_abbrev = v_org_abbrev
	), est AS (
		SELECT 
			COUNT(DISTINCT s.gene) FILTER (WHERE ga.is_deprecated = 0) AS estCount
		FROM webready.GeneAttributes_p ga, webready.EstAlignmentGeneSummary_p s,
           webready.EstAttributes_p e
		WHERE 
			e.source_id = s.accession 
			AND ga.source_id = s.gene
			AND s.est_gene_overlap_length >= 100
            AND s.is_best_alignment = 1
            AND s.percent_est_bases_aligned >= 20
            AND s.percent_identity >= 90
			AND e.org_abbrev = v_org_abbrev
			AND s.org_abbrev = v_org_abbrev
			AND ga.org_abbrev = v_org_abbrev
	), ec AS (
		SELECT 
			COUNT(DISTINCT ga.source_id) FILTER (WHERE ga.is_deprecated = 0 AND ta.ec_numbers IS NOT NULL) AS ecNumberCount
		FROM webready.GeneAttributes_p ga, webready.TranscriptAttributes_p ta
		WHERE ta.gene_source_id = ga.source_id
			-- AND ga.org_abbrev = ta.org_abbrev
			AND ta.org_abbrev =v_org_abbrev
			AND ga.org_abbrev = v_org_abbrev
	)
	SELECT 
		g.taxon_id,
		g.project_id,
		g.database_version,
		g.ncbi_tax_id,
		g.megabps,
		gene.geneCount,
		gene.pseudoGeneCount,
		gene.codingGeneCount,
		gene.otherGeneCount,
		cct.chipchipGeneCount,
		ortholog.orthologCount,
		go.goCount,
		tfbs.tfbsCount,
		est.estCount,
		mss.proteomicsCount,
		ec.ecNumberCount
	FROM genomestat g, gene, cct, ortholog, go, tfbs, est, mss, ec
	;
     END LOOP;
     end $$;
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE OrganismAttributes&1 AS
        SELECT oa.*, tn2.name as species, t.ncbi_tax_id as species_ncbi_tax_id
               , CASE  WHEN ltrim(replace(oa.organism_name, tn2.name, ''))= oa.organism_name
                       THEN strain_abbrev
                       ELSE ltrim(replace(oa.organism_name, tn2.name, '')) END AS strain
        FROM (
            SELECT o.project_name as project_id,
                   case when t.ncbi_tax_id > 10000000
            --       then 'TMPTX_' || round(t.ncbi_tax_id / 10000000) || '_' ||
            --            mod(t.ncbi_tax_id, 10000000) -- e.g. "TMPTX_930_1"
            --       then 'TMPTX_' || t.ncbi_tax_id -- all the many digits
                     then 'TMPTX_' || o.public_abbrev
                     else 'NCBITAXON_' || t.ncbi_tax_id
                   end as source_id,
                   o.abbrev as internal_abbrev,
                   o.public_abbrev,
                   o.orthomcl_abbrev,
                   o.family_name_for_files,
                   tn.name as organism_name,
                   o.genome_source,
                   o.strain_abbrev,
                   o.is_annotated_genome,
                   o.is_reference_strain,
                   o.is_family_representative,
                   o.name_for_filenames,
                   o.taxon_id as component_taxon_id,
                   gc.database_version,
                   gc.megabps as megabps,
                   gc.ncbi_tax_id as ncbi_tax_id,
                   --gc.snpCount as snpCount,
                   gc.geneCount as geneCount,
                   gc.pseudoGeneCount as pseudoGeneCount,
                   gc.codingGeneCount as codingGeneCount,
                   gc.otherGeneCount as otherGeneCount,
                   gc.ChipChipGeneCount as ChipChipGeneCount,
                   gc.orthologCount as orthologCount,
                   gc.goCount as goCount,
                   gc.tfbsCount as tfbsCount,
                   gc.proteomicsCount as proteomicsCount,
                   gc.estCount as estCount,
                   gc.ecNumberCount as ecNumberCount,
                   cast(coalesce(dsc.Organellar_Has, 0) as NUMERIC(1)) as isOrganellar,
                   cast(coalesce(dsc.HTSIsolate_Has, 0) as NUMERIC(1)) as hasHTSIsolate,
                   cast(coalesce(dsc.Popset_Has, 0) as NUMERIC(1)) as hasPopset,
                   cast(coalesce(dsc.Epitope_Has, 0) as NUMERIC(1)) as hasEpitope,
                   cast(coalesce(dsc.Array_Has, 0) as NUMERIC(1)) as hasArray,
                   coalesce(oc.hasCentromere, 0) as hasCentromere,
                   coalesce(sc.contig_num, 0) as contigCount,
                   coalesce(sc.supercont_num, 0) as supercontigCount,
                   coalesce(sc.chrom_num, 0) as chromosomeCount,
                   --coalesce(cc.communityCount, 0) as communityCount,
                   --coalesce(psc.popsetCount, 0) as popsetCount,
                   coalesce(pc.geneArrayCount, 0) as arrayGeneCount,
                   coalesce(pc.rnaSeqCount, 0) as rnaSeqCount,
                   coalesce(pc.rtPCRCount, 0) as rtPCRCount,
                   coalesce(ta.avg_transcript_length, 0) as avg_transcript_length
            FROM apidb.Organism o
              INNER JOIN sres.TaxonName tn ON tn.taxon_id = o.taxon_id
              INNER JOIN sres.Taxon t ON t.taxon_id = tn.taxon_id
              LEFT JOIN DataSourceCount dsc ON o.taxon_id = dsc.taxon_id
              LEFT JOIN OrganismCentromere oc ON o.taxon_id = oc.taxon_id
              LEFT JOIN SequenceCount sc ON o.taxon_id = sc.taxon_id
              --LEFT JOIN CommunityCount cc ON o.taxon_id = cc.taxon_id
              LEFT JOIN GeneCount gc ON o.taxon_id = gc.taxon_id
              --LEFT JOIN popsetCount psc ON o.taxon_id = psc.taxon_id
              LEFT JOIN profileCount pc ON o.taxon_id = pc.taxon_id
              LEFT JOIN (
                SELECT taxon_id, round(avg(length),1) as avg_transcript_length
                FROM Transcriptattributes
                GROUP by taxon_id
              ) ta ON o.taxon_id = ta.taxon_id
            WHERE tn.name_class = 'scientific name'
          ) oa,
          webready.TaxonSpecies_p ts,
          sres.taxon t,
          sres.taxonname tn2
        WHERE oa.component_taxon_id = ts.taxon_id
          AND ts.species_taxon_id = t.taxon_id
          AND ts.species_taxon_id = tn2.taxon_id
          AND tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_projectId_idx&1 ON OrganismAttributes&1 (project_id, source_id)

      ]]>
    </sql>
  </tuningTable>


<!-- COMMENT FOR NOW, as no InferredParam table; FIX later
  <tuningTable name="ChipSeqTranscript">
    <comment> Used by the GenesByChipSeq query
    </comment>
    <internalDependency name="InferredParams"/>
    <internalDependency name="DefaultChars"/>
    <externalDependency name="results.SegmentResult"/>
    <sql>
      <![CDATA[
      CREATE TABLE ChipSeqTranscript&1 AS
      SELECT DISTINCT ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
        CASE
          WHEN ta.is_reversed = 0
          THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
          ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        END as distance,
        CASE
          WHEN /* distance > 0 */
            CASE WHEN ta.is_reversed = 0
              THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
              ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            END > 0
          THEN
            CASE
              WHEN ta.is_reversed = 0
              THEN '-'
              ELSE '+'
            END
          ELSE
            CASE
              WHEN ta.is_reversed = 1
              THEN '-'
              ELSE '+'
            END
          END as direction,
        sr.score1 as score
      FROM  webready.TranscriptAttributes_p ta,
            results.SegmentResult sr
      WHERE sr.na_sequence_id = ta.na_sequence_id
        AND sr.protocol_app_node_id
                IN (      select protocol_app_node_id from DefaultChars where dataset_subtype = 'chipseq'
                    union select protocol_app_node_id from InferredParams where dataset_subtype = 'chipseq'
                    union select protocol_app_node_id from InferredChars where dataset_subtype = 'chipseq')
        AND ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                        or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index chpsq_id_idx&1 ON ChipSeqTranscript&1 (protocol_app_node_id, source_id, gene_source_id)

      ]]>
    </sql>
  </tuningTable>
-->



 

  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
      names. Each record maps an organism name onto this abbreviation, as
      well as the species name and project ID. Used by the model and as an
      input in the creation of the OrganismAbbreviationBlast tuning table.
      Propagated to portal instances.
    </comment>
    <internalDependency name="OrganismTree"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviationWS&1 as
       SELECT oa.organism, ot.parentTerm as parent, oa.org_abbrev as abbreviation, ot.project_id
       FROM webready.OrganismAbbreviation_p oa, OrganismTree ot
       WHERE ot.term = oa.organism
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismTree">
    <comment>
      Group species by higher level taxonomy. Each row associates a taxon of
      interest with one of its ancestors in the taxon tree. Used in parameter
      queries that have to know about the taxon tree. Propagated to portal
      instances.
    </comment>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="ProjectTaxon"/>
    <ancillaryTable name="DistinctTaxonLink"/>
    <sql>
      <![CDATA[
        CREATE TABLE DistinctTaxonLink&1 as
        SELECT taxon_id, max(rank) as rank, max(parent_id) AS parent_id,
               max(tree_level) as tree_level,
               max(display_reason) as display_reason
        FROM (
          WITH RECURSIVE cte AS (
            SELECT taxon_id, rank, parent_id, 1 as tree_level
            FROM sres.taxon
            WHERE taxon_id IN (select taxon_id from GenomicSeqattributes)
            UNION ALL
            SELECT t.taxon_id, t.rank, t.parent_id, cte.tree_level + 1 as tree_level
            FROM sres.taxon t, cte
            WHERE cte.parent_id = t.taxon_id
          )
          SELECT taxon_id, rank, parent_id, tree_level,
            CASE
              WHEN taxon_id in (select taxon_id from GenomicSeqattributes) THEN 'has data'
              WHEN rank in ('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species') THEN 'major rank'
              WHEN taxon_id in (
                SELECT taxon_id
                FROM sres.taxon
                WHERE ncbi_tax_id in (44542 -- gambiae species complex
                     , 554915 -- Amoebozoa
                     , 5796 -- Coccidia
                     , 1280412 -- Conoidasida
              )) THEN 'hardwired'
              ELSE 'none'
            END as display_reason
          FROM cte
        ) t
        GROUP BY taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index dtl_ix&1
          ON DistinctTaxonLink&1 (taxon_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          skiplist RECORD;
        BEGIN
          FOR skiplist
              IN (SELECT taxon_id, max(parent_id) as parent_id, max(tree_level)
                  FROM DistinctTaxonLink&1
                  WHERE display_reason in ('none', 'has data')
                  GROUP by taxon_id
                  ORDER by max(tree_level) desc
                 )
          LOOP
            UPDATE DistinctTaxonLink&1
            SET parent_id
                = (SELECT max(parent_id)
                   FROM DistinctTaxonLink&1
                   WHERE taxon_id = skiplist.taxon_id)
            WHERE parent_id = skiplist.taxon_id;
          END LOOP;
          commit;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DELETE FROM DistinctTaxonLink&1 WHERE display_reason = 'none'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 AS
        WITH dtl AS (
          WITH RECURSIVE cte AS (
            SELECT taxon_id as leaf_taxon_id, taxon_id,
                parent_id, rank, tree_level
            FROM DistinctTaxonLink&1
            WHERE display_reason = 'has data' OR rank = 'species'
            UNION
            SELECT cte.leaf_taxon_id, dtl.taxon_id, dtl.parent_id, dtl.rank, dtl.tree_level
            FROM  DistinctTaxonLink&1 dtl, cte
            WHERE cte.parent_id = dtl.taxon_id
          )
          SELECT *
          FROM cte
        ) , parent_name AS (
          SELECT taxon_id, name
          FROM sres.TaxonName
          WHERE name_class = 'scientific name'
        )
        SELECT leaf_name.name as organism,
               tn.name as term, parent_name.name parentterm,
               dtl.taxon_id as internal,
               apidb.project_id(leaf_name.name) as project_id,
               dtl.tree_level, dtl.rank
        FROM
           sres.TaxonName leaf_name, sres.TaxonName tn,
           dtl LEFT JOIN parent_name ON dtl.parent_id = parent_name.taxon_id
        WHERE dtl.leaf_taxon_id = leaf_name.taxon_id
          AND leaf_name.name_class = 'scientific name'
          AND dtl.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index OrgTree_term_pterm_ix&1 on OrganismTree&1(TERM, PARENTTERM)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
      BLAST-query parameters. Propagated to portal instances.
    </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
<!--    <internalDependency name="PopsetAttributes"/> -->
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="webready.EstAttributes_p"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviationBlast&1 as
       SELECT organism, parent, abbreviation, substr(project_id, 1, 20) as project_id
       FROM OrganismAbbreviationWS
       UNION
         -- all familes for popsets
       --SELECT DISTINCT family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent,
       --                family_name_for_files as abbreviation, substr(project_name, 1, 20) as project_id
       --FROM apidb.Organism
       --WHERE family_name_for_files is not null
       --  AND abbrev || '_isolates_genbank_RSRC' IN (SELECT external_db_name as db_name FROM PopsetAttributes)
       --  AND family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Ordosporidae')
       --UNION
       SELECT special.organism, special.parent, special.abbreviation,
              substr(ot.project_id, 1, 20) as project_id
       FROM OrganismTree ot,
            ( -- all species and speciesAbbreviations from apidb.Organism where we have ests
               SELECT DISTINCT
                sp.name as organism, ot.parentTerm as parent,
                regexp_replace(org.name_for_filenames, replace(org.strain_abbrev, '/','_'),'') as abbreviation
               FROM sres.TaxonName sp, TaxonSpecies ts, apidb.Organism org, OrganismTree ot
               WHERE org.taxon_id = ts.taxon_id
                 AND ts.species_taxon_id = sp.taxon_id
                 AND sp.name_class = 'scientific name'
                 AND ot.term = sp.name
                 AND org.strain_abbrev is not null
                 AND org.name_for_filenames is not null
                 AND sp.taxon_id
                     in (SELECT etn.taxon_id
                         FROM sres.TaxonName etn
                         WHERE etn.name in (SELECT organism FROM webready.EstAttributes_p))
             UNION
               SELECT 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism,
                      'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation
            ) special
       WHERE special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
      species. Used in BLAST param queries. Propagated to portal instances.
    </comment>
<!--     <internalDependency name="PopsetAttributes"/> -->
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="webready.EstAttributes_p"/>
    <sql>
      <![CDATA[
        CREATE TABLE BlastTypes&1 as
        /* Standard GENES */
        SELECT distinct organism, project_id, type
        FROM Transcriptattributes,
             (SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE organism not in ('Toxoplasma gondii RH') and (gene_type = 'protein coding' or gene_type = 'protein coding gene')
        UNION
        /* GiardiaDB Deprecated Genes */
        SELECT 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type
        FROM (SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        UNION
        /* GiardiaDB Scaffolds */
        SELECT 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, 'Genome' as type
        UNION
        /* Standard GENOME */
        SELECT distinct organism, project_id, 'Genome' as type
        FROM GenomicSeqattributes
        UNION
        /* Mitochondrial GENES and GENOME */
        SELECT DISTINCT organism || ' mitochondrial', project_id, type
        FROM GenomicSeqattributes,
          (SELECT 'Genome' as type UNION SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE so_id = 'SO:0000819'
          AND NOT project_id='PlasmoDB'
        UNION
        /* Plastid GENES and GENOME */
        SELECT DISTINCT organism || ' plastid' as organism, project_id, type
        FROM GenomicSeqattributes,
          (SELECT 'Genome' as type UNION SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE so_id = 'SO:0001259'
          AND NOT project_id='PlasmoDB'
        UNION
        /* Regular ESTs (all species from webready.EstAttributes_p) */
        SELECT DISTINCT sp.name as organism, ea.project_id, 'ESTs' as type
        FROM webready.EstAttributes_p ea, sres.TaxonName tn, TaxonSpecies ts, sres.TaxonName sp
        WHERE ea.organism = tn.name
          AND (tn.taxon_id = ts.taxon_id or tn.taxon_id = ts.species_taxon_id)
          AND ts.species_taxon_id = sp.taxon_id
          AND sp.name_class = 'scientific name'
        -- UNION
        /* regular Isolates */
        --SELECT DISTINCT family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'PopSet'
        --FROM apidb.Organism
        --WHERE family_name_for_files is not null
        --  AND abbrev || '_isolates_genbank_RSRC' in (SELECT DISTINCT external_db_name  AS db_name FROM PopsetAttributes)
        --UNION
        /* isolates are hard coded */
        --SELECT 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'PopSet' as type
        --UNION
        --SELECT 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'PopSet' as type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary_p">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
      one experiment for one gene. Used for mass spec queries in the model,
      GBrowse, and PBrowse, and also in the creation of the MSTranscriptSummary
      tuning table.
    </comment>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.MassSpecPeptide"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="apidb.Organism"/>

    <!-- Create empty table structure -->
    <sql>
      <![CDATA[

        CREATE TABLE MSPeptideSummary_p&1 (
          peptide_sequence text,
          source_id varchar(80),
          gene_source_id varchar(80),
          project_id text,
          experiment varchar(200),
          external_database_name varchar(200),
          spectrum_count numeric,
          aa_sequence_id numeric(12),
          aa_start_min numeric(10),
          aa_end_max numeric(10),
          sample varchar(200),
          sample_display_name varchar(200),
          html_color varchar(20),
          sort_order numeric,
          org_abbrev text
        ) PARTITION BY LIST (org_abbrev)
      ]]>
    </sql>

    <!-- Loop over organisms and insert data -->
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          orgrecord RECORD;
          partition_name TEXT;
        BEGIN
          FOR orgrecord IN SELECT org_abbrev, sanitized_org_abbrev from webready.OrganismAbbreviation_p LOOP
            partition_name := lower('Mspeptidesummary_p&1_' || orgrecord.sanitized_org_abbrev);
            EXECUTE format('CREATE TABLE %I PARTITION OF MSPeptideSummary_p&1 FOR VALUES IN (%L)', partition_name, orgrecord.org_abbrev);

            INSERT INTO MSPeptideSummary_p&1
            select pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER, orgrecord.org_abbrev
            from (
                    select msp.peptide_sequence,
                           ta.source_id,
                           ta.gene_source_id,
                           ta.project_id,
                           dsp.display_name as experiment,
                           d.name as external_database_name,
                           sum(msp.spectrum_count) as spectrum_count,
                           ta.aa_sequence_id,
                           msp.peptide_start as aa_start_min,
                           msp.peptide_end  as aa_end_max,
                           msp.sample
                    from apidb.massspecpeptide msp
                      inner join sres.externaldatabaserelease r on msp.external_database_release_id = r.external_database_release_id
                      inner join sres.externaldatabase d on r.external_database_id = d.external_database_id
                      inner join webready.TranscriptAttributes_p ta on msp.protein_source_id = ta.protein_source_id
                      LEFT JOIN DatasetDatasource dd ON d.name = dd.name
                      left join datasetpresenter dsp on dd.dataset_presenter_id = dsp.dataset_presenter_id
                    where ta.org_abbrev = orgrecord.org_abbrev
                    group by d.name, ta.source_id, ta.gene_source_id, ta.project_id, dsp.display_name,
                             msp.protein_source_id, ta.aa_sequence_id, msp.peptide_sequence,
                             msp.spectrum_count, msp.peptide_start, msp.peptide_end, msp.external_database_release_id, msp.sample
              ) pep
              ,sampledisplayinfo sdi
            where sdi.dataset_name = pep.external_database_name
             and pep.sample = replace (sdi.sample ,'.tab', '');
          end loop;
        end $$;
      ]]>
    </sql>

    <!-- Create index -->
    <sql>
      <![CDATA[
        create index sample_ix&1 on Mspeptidesummary_p&1 (sample)

      ]]>
    </sql>
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        create index mspep_ix&1-->
<!--          on Mspeptidesummary_p&1-->
<!--               (aa_sequence_id, external_database_name, peptide_aa_feature_id,-->
<!--                aa_start_min, aa_end_max, sample, source_id, spectrum_count, experiment,-->
<!--                sample_display_name, html_color, peptide_sequence)-->
<!--        -->
<!--      ]]>-->
<!--    </sql>-->
  </tuningTable>

<!-- TODO: JB 10-6-2025 why do we need geneattributes here?  cant we just ask for the organism which have the is_annotated flag set to true? -->
  <tuningTable name="AnnotatedGenomeSummary">
    <comment> Stores summary information from annotated genomes to facilitate overview section of gene page
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE AnnotatedGenomeSummary&1 AS
        SELECT ga.external_db_name as external_db_name, ga.organism, ga.taxon_id,
               o.is_reference_strain,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'isCurated') as is_curated_genome,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'updatedAnnotationText') as updated_link_text,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'specialLinkDisplayText') as special_link_text,
               (SELECT rel.id_url
                FROM DatasetProperty p,  sres.ExternalDatabase db, sres.ExternalDatabaseRelease rel
                WHERE p.dataset_presenter_id = dsp.dataset_presenter_id
                  AND db.name = cast(substr(p.value, 1, 4000) as varchar(4000))
                  AND db.external_database_id = rel.external_database_id
                  AND p.property = 'specialLinkExternalDbName') as link_url,
               dsp.release_policy
        FROM apidb.Organism o,
             (SELECT distinct external_db_name, taxon_id, organism FROM Geneattributes) ga
             LEFT JOIN DatasetPresenter dsp ON dsp.name = ga.external_db_name
        WHERE ga.external_db_name like '%_primary_genome_RSRC'
          AND o.taxon_id = ga.taxon_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MSModifiedPeptideSummary_p">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
      and PBrowse.
    </comment>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="apidb.ModifiedMassSpecPeptide"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="apidb.Organism"/>

    <!-- Create empty table structure -->
    <sql>
      <![CDATA[
        CREATE TABLE MSModifiedPeptideSummary_p&1 (
          source_id varchar(80),
          gene_source_id varchar(80),
          project_id text,
          aa_sequence_id numeric(12),
          experiment varchar(200),
          external_database_name varchar(200),
          sample varchar(200),
          spectrum_count numeric,
          residue varchar(10),
          residue_location numeric(10),
          modification_type varchar(100),
          peptide_sequence text,
          aa_start_min numeric(10),
          aa_end_max numeric(10),
          sample_display_name varchar(200),
          html_color varchar(20),
          sort_order numeric,
          org_abbrev text
        ) PARTITION BY LIST (org_abbrev)
      ]]>
    </sql>

    <!-- Loop over organisms and insert data -->
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          orgrecord RECORD;
          partition_name TEXT;
        BEGIN
          FOR orgrecord IN SELECT org_abbrev, sanitized_org_abbrev from webready.OrganismAbbreviation_p LOOP
            partition_name := lower('MSModifiedPeptideSummary_p&1_' || orgrecord.sanitized_org_abbrev);
            EXECUTE format('CREATE TABLE %I PARTITION OF MSModifiedPeptideSummary_p&1 FOR VALUES IN (%L)', partition_name, orgrecord.org_abbrev);

            INSERT INTO MSModifiedPeptideSummary_p&1
            select pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER, orgrecord.org_abbrev
            from (
                    select ta.source_id,
                           ta.gene_source_id,
                           ta.project_id,
                           ta.aa_sequence_id,
                           dsp.display_name as experiment,
                           d.name as external_database_name,
                           msp.sample,
                           sum(msp.spectrum_count) as spectrum_count,
                           msp.residue,
                           msp.residue_protein_loc  as residue_location,
                           msp.modification_type,
                           msp.peptide_sequence,
                           msp.peptide_start as aa_start_min,
                           msp.peptide_end  as aa_end_max
                    from apidb.ModifiedMassSpecPeptide msp
                      inner join sres.externaldatabaserelease r on msp.external_database_release_id = r.external_database_release_id
                      inner join sres.externaldatabase d on r.external_database_id = d.external_database_id
                      inner join webready.TranscriptAttributes_p ta on msp.protein_source_id = ta.protein_source_id
                      LEFT JOIN DatasetDatasource dd ON d.name = dd.name
                      left join datasetpresenter dsp on dd.dataset_presenter_id = dsp.dataset_presenter_id
                    where ta.org_abbrev = orgrecord.org_abbrev
                    group by d.name, ta.source_id, ta.gene_source_id, ta.project_id, dsp.display_name,
                             msp.protein_source_id, ta.aa_sequence_id, msp.peptide_sequence,
                             msp.spectrum_count, msp.peptide_start, msp.peptide_end, msp.external_database_release_id,
                             msp.sample, msp.modification_type, msp.residue, msp.residue_protein_loc
              ) pep
              , sampledisplayinfo sdi
            where sdi.dataset_name = pep.external_database_name
             and pep.sample = replace (sdi.sample ,'.tab', '');
          end loop;
        end $$;
      ]]>
    </sql>

    <!-- Alter column constraint -->
    <sql>
      <![CDATA[
        ALTER TABLE MSModifiedPeptideSummary_p&1 ALTER COLUMN modification_type DROP NOT null
      ]]>
    </sql>

    <!-- Create indexes -->
    <sql>
      <![CDATA[
        create index msmodps_tx_ix&1 on MSModifiedPeptideSummary_p&1 (source_id, gene_source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msmodps_gn_ix&1 on MSModifiedPeptideSummary_p&1 (gene_source_id, source_id)

      ]]>
    </sql>
  </tuningTable>


<!--  <tuningTable name="Ssgcid" alwaysUpdate="true">-->
  <tuningTable name="Ssgcid" alwaysUpdate="true" >
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
      populated from their web service. Used in the gene record.
    </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


<!--  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true">-->
  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true" >
    <comment> Used by the model and GBrowse, as well as an input in the creation of
      the tuning tables like MSModifiedPeptideSummary and MSPeptideSummary.
    </comment>
    <program commandLine="buildSampleDisplayInfoTT"/>
  </tuningTable>


<!--  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true">-->
  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true" >
    <comment> Used by the model when writing profile data
    </comment>
    <program commandLine="buildProfileSetDisplayInfoTT"/>
  </tuningTable>


<!--  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">-->
  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true" >
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
      for it. Used by the gene record.
    </comment>
    <externalDependency name="apidb.Organism"/>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>

  <tuningTable name="GenomicsInternalHyperlink" alwaysUpdate="true">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
      each dataset gets one such row.
      Used in dataset record queries.
    </comment>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="OrganismAttributes"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenomicsInternalHyperlink&1 AS
        WITH rnaseqgenes AS (
          SELECT p.DATASET_NAME
                , p.source_id as gene_source_id
                , ga.sequence_id as sequence_id
                , row_number() over (partition by p.dataset_name
                                    order by p.max_value, p.source_id, ga.sequence_id) as rn
          FROM profile p, Geneattributes ga
          WHERE dataset_type = 'transcript_expression' and dataset_subtype =  'rnaseq'
            AND p.source_id = ga.source_id
        ), proteomicsgenes as (
          SELECT ga.gene_source_id,
                 ga.SEQUENCE_ID,
                 ga.protein_source_id,
                 d.name,
                 row_number() over(partition by d.name
                                   order by mss.aa_seq_percent_covered desc, ga.gene_source_id) as rn
          FROM apidb.MassSpecSummary mss, Transcriptattributes ga,
               sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
          WHERE mss.external_database_release_id = r.external_database_release_id
          AND r.external_database_id = d.external_database_id
          AND mss.aa_sequence_id = ga.aa_sequence_id
        ), sequences as (
          select sa.source_id
               , sa.taxon_id
               , row_number() over(partition by sa.taxon_id
                                   order by sa.chromosome_order_num, sa.length desc) as rn
          from GenomicSeqattributes sa
          where sa.is_top_level = 1
        ), macros as (
          SELECT dd.dataset_presenter_id
               , o.name_for_filenames
               , o.project_id
               , o.public_abbrev as org_abbrev
               , o.source_id as org_pk
               , dd.name
               , dsp.name as dataset_presenter_name
               , sa.source_id as sequence_source_id
               , pg.sequence_id as p_sequence_source_id
               , pg.gene_source_id as p_gene_id
               , pg.protein_source_id as p_protein_id
               , rg.sequence_id as r_sequence_source_id
               , rg.gene_source_id as r_gene_id
          FROM organismattributes o
             INNER JOIN datasetdatasource dd ON o.component_taxon_id = dd.taxon_id
             INNER JOIN datasetpresenter dsp ON dd.dataset_presenter_id = dsp.dataset_presenter_id
             INNER JOIN sequences sa ON dd.taxon_id = sa.taxon_id
             LEFT JOIN (select * from proteomicsgenes where rn = 1) pg ON dd.name = pg.name
             LEFT JOIN (select * from rnaseqgenes where rn = 1) rg ON dd.name = rg.dataset_name
          WHERE sa.rn = 1
        )
        SELECT DISTINCT
             h.dataset_link_id, h.dataset_presenter_id, h.description
             , replace(h.text, 'DEFAULT_PROJECT', macros.project_id) as text
             , replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(h.url
                                                    , 'DEFAULT_PROJECT', macros.project_id)
                                                    , 'ORGANISM_FILE_NAME', macros.name_for_filenames)
                                                    , 'DEFAULT_SEQUENCE', macros.sequence_source_id)
                                                    , 'DEFAULT_ORG_ABBREV', macros.org_abbrev)
                                                    , 'DEFAULT_PROTEOMICS_SEQUENCE', macros.p_sequence_source_id)
                                                    , 'DEFAULT_PROTEOMICS_GENE', macros.p_gene_id)
                                                    , 'DEFAULT_PROTEOMICS_PROTEIN', macros.p_protein_id)
                                                    , 'DEFAULT_RNASEQ_GENE', macros.r_gene_id)
                                                    , 'DEFAULT_RNASEQ_SEQUENCE', macros.r_sequence_source_id)
                                                    , 'DEFAULT_DATASET_NAME', macros.name)
                                                    , 'DEFAULT_DATASET_PRESENTER_NAME', macros.dataset_presenter_name)
                                                    , 'DEFAULT_ORGANISM_PK', macros.org_pk) as url
             , h.isPublication
        FROM datasetpresenter dsp, macros, datasethyperlink h
        WHERE macros.dataset_presenter_id = dsp.dataset_presenter_id
          AND h.dataset_presenter_id = macros.dataset_presenter_id
          AND h.url like '/%'
      ]]>
    </sql>
  </tuningTable>


<!-- DONT SEE THIS TABLE  USED ANYWHERE 
  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="Mspeptidesummary_P"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProteomicsCitation&1 AS
        WITH pubs AS (
          SELECT name, id, contact_email,
                string_agg(publication, ',' order by publication) as pmids
          FROM (
            SELECT ds.name as name, ds.dataset_presenter_id as id,
                   c.email as contact_email, p.pmid as publication
            FROM DatasetPresenter ds, DatasetContact c, DatasetPublication p
            WHERE ds.dataset_presenter_id = c.dataset_presenter_id
              AND ds.dataset_presenter_id = p.dataset_presenter_id
              AND c.is_primary_contact = true
              AND ds.type = 'protein_expression'
              AND ds.subtype is null
          ) t
          GROUP BY name, id, contact_email
        ),
        samples AS (
          SELECT name, id, string_agg(sample_i, chr(10) order by sample) as sample_table
          FROM (
            SELECT distinct ds.name as name,
                             ds.dataset_presenter_id as id, sample,
                             '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
            FROM Mspeptidesummary_P mps, DatasetPresenter ds
      ## consider using the tuning table ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
            WHERE (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern)
          ) t
          group by name, id
        )
        SELECT name,
               substr(description, 4000, 1) || ' Primary Contact Email: '|| coalesce(email, 'unavailable')
               || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
               || sample_table || chr(10) ||
               ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
        FROM (
          SELECT ds.name as name, ds.summary as description, pubs.contact_email as email,
                 pubs.pmids as publications, samples.sample_table as sample_table
          FROM DatasetPresenter ds, pubs, samples
          WHERE ds.dataset_presenter_id = pubs.id
            AND ds.dataset_presenter_id = samples.id
        ) t
      ]]>
    </sql>
  </tuningTable>
-->


<!--  <tuningTable name="Pubmed" alwaysUpdate="true">-->
  <tuningTable name="Pubmed"  alwaysUpdate="true" >
    <!-- PubMed info
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <program commandLine="buildPubmedTT"/>
  </tuningTable>


  <tuningTable name="GenePubmed_p">
    <!-- PubMed records mapped to genes
      -->
    <internalDependency name="OrganismAttributes"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="Pubmed"/>
    <externalDependency name="webready.DbRefNaFeature_p"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="apidb.Organism"/>

    <!-- Create empty table structure -->
<sql>
      <![CDATA[
        CREATE TABLE GenePubmed_p&1 (
          source_id varchar(80),
          gene_source_id varchar(80),
          project_id text,
          pubmed_id varchar(20),
          doi varchar(200),
          title varchar(2000),
          authors varchar(2000),
          org_abbrev text
        ) PARTITION BY LIST (org_abbrev)
      ]]>
</sql>

    <!-- Loop over organisms and insert data -->
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          orgrecord RECORD;
          partition_name TEXT;
        BEGIN
          FOR orgrecord IN SELECT org_abbrev, sanitized_org_abbrev from webready.OrganismAbbreviation_p LOOP
            partition_name := lower('GenePubmed_p&1_' || orgrecord.sanitized_org_abbrev);
            EXECUTE format('CREATE TABLE %I PARTITION OF GenePubmed_p&1 FOR VALUES IN (%L)', partition_name, orgrecord.org_abbrev);

            INSERT INTO GenePubmed_p&1
            with feat_pm as (
              select dbref_subset.na_feature_id,
                     pm.pubmed_id, pm.doi, pm.title,
                     substr(pm.authors, 1, 2000) authors
              from Pubmed pm,
                   (select dbna.na_feature_id, db.primary_identifier
                    from webready.DbRefNaFeature_p dbna,
                         sres.DbRef db
	             where db.db_ref_id = dbna.db_ref_id
		     and dbna.org_abbrev = orgrecord.org_abbrev	 
                     and db.external_database_release_id
                         in (  select external_database_release_id
                               from ExternalDbDatasetPresenter
                               where lower(dataset_presenter_display_name) like '%pubmed%'
                             union
                               select edr.external_database_release_id
                               from sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
                               where ed.external_database_id = edr.external_database_id
                                 and lower(ed.name) like '%pubmed%'
                            )
                   ) dbref_subset
              where dbref_subset.primary_identifier = pm.pubmed_id::varchar
            )
            select ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors, orgrecord.org_abbrev
            from webready.TranscriptAttributes_p ta, feat_pm
            where ta.na_feature_id = feat_pm.na_feature_id
              and ta.org_abbrev = orgrecord.org_abbrev
            union
            select ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors, orgrecord.org_abbrev
            from webready.TranscriptAttributes_p ta, feat_pm
            where ta.gene_na_feature_id = feat_pm.na_feature_id
              and ta.org_abbrev = orgrecord.org_abbrev;
          end loop;
        end $$;
      ]]>
    </sql>

    <!-- Create indexes -->
    <sql>
      <![CDATA[
        create index gpm_gene_idx&1
          on GenePubmed_p&1 (gene_source_id, source_id, project_id, pubmed_id, doi, title, authors)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_tx_idx&1
          on GenePubmed_p&1 (source_id, gene_source_id, project_id, pubmed_id, doi, title, authors)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Profile">
    <comment> One profile per gene per dataset. Used for graphs.</comment>
    <externalDependency name="apidb.Datasource"/>
<!--
    <externalDependency name="apidb.OntologyTermResult"/>
    <externalDependency name="apidb.NaFeatureMetacycle"/>
    <externalDependency name="apidb.LopitResults"/>
    <externalDependency name="apidb.EigenGeneWgcnaResults"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
-->
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GeneOrgAbbrev"/>
    <intermediateTable name="profile_nafeatureexp_summary"/>
    <intermediateTable name="gene_nafeatureexp"/>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE profile_nafeatureexp_summary (
          node_set_id numeric(12,0),
          na_feature_id numeric(10,0),
          node_type character varying(200),
          profile_as_string_value text,
          profile_as_string_stderr text,
          profile_as_string_percentile1 text,
          profile_as_string_percentile2 text
       )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          -- Declare a record variable to hold each nodeset record
          nodeset RECORD;
          rows INTEGER := 0;
          start_time timestamptz;
          end_time timestamptz;
        BEGIN
          -- Loop through each dataset/experiment and compute & insert results into the temp table
          FOR nodeset IN SELECT node_set_id, node_type FROM study.nodeset LOOP
            start_time := clock_timestamp();
              INSERT INTO profile_nafeatureexp_summary
              SELECT sl.node_set_id, result.na_feature_id, nodeset.node_type,
                string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string_value,
                string_agg(coalesce(round(result.standard_error::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string_stderr,
                string_agg(coalesce(round(result.percentile_channel1::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string_percentile1,
                string_agg(coalesce(round(result.percentile_channel2::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string_percentile2
              FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, results.NaFeatureExpression result
              WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                AND result.protocol_app_node_id = pan.protocol_app_node_id
                AND sl.node_set_id = nodeset.node_set_id
              GROUP BY sl.node_set_id, result.na_feature_id, nodeset.node_type
            ;
            end_time := clock_timestamp();
            rows := rows +1;
            -- raise notice '% inserted nodeset % in % ms', rows, nodeset.node_set_id, EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
          END LOOP;
        END $$;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE gene_nafeatureexp AS
        SELECT summ.node_set_id, ga.source_id, summ.node_type,
               profile_as_string_value, profile_as_string_stderr,
               profile_as_string_percentile1, profile_as_string_percentile2
        FROM Geneattributes ga, GeneOrgAbbrev goa, profile_nafeatureexp_summary summ
               WHERE ga.source_id = goa.source_id
               AND ga.org_abbrev = goa.org_abbrev
               AND ga.na_feature_id = summ.na_feature_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE Profile&1 AS
            WITH gene_prof AS
             (SELECT * from gene_nafeatureexp)
            SELECT
               ds.name as dataset_name, ds.type as dataset_type, o.abbrev as org_abbrev,
               ds.subtype as dataset_subtype, 'values' AS profile_type, profile.node_type,
               profile.source_id, profile.node_set_id as profile_study_id,
               ps.name as profile_set_name,
               cast(case
                      when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                        then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                      -- special cases for legacy datasets
                      when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%'
                        then regexp_replace(
                                 regexp_replace(
                                     regexp_replace(
                                         regexp_replace(
                                             regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                        '\[.+ unique\]', ' - unique'),
                                                    '\[.+\]', ''),
                                                'aligned with cds coordinates ', 'cds coordinates'),
                                            'T.brucei paired end RNA-Seqdata from Horn ', '')
                      else null
                    end as varchar(50)
                   ) as profile_set_suffix,
               CASE WHEN replace(profile.profile_as_string_value, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string_value END as profile_as_string,
               '-1' as max_value, '1' as min_value, '-1' as max_timepoint, '-1' as min_timepoint
            FROM apidb.DataSource ds, sres.ExternalDatabase d, apidb.organism o,
              sres.ExternalDatabaseRelease r, study.NodeSet ps,
              gene_prof profile
            WHERE ds.name = d.name
              AND ds.version = r.version
	      AND ds.taxon_id = o.taxon_id
              AND d.external_database_id = r.external_database_id
              AND profile.node_set_id = ps.node_set_id
              AND ps.external_database_release_id = r.external_database_release_id
            UNION ALL
            SELECT
               ds.name as dataset_name, ds.type as dataset_type, o.abbrev as org_abbrev,
               ds.subtype as dataset_subtype, 'standard_error' AS profile_type, profile.node_type,
               profile.source_id, profile.node_set_id as profile_study_id,
               ps.name as profile_set_name,
               cast(case
                      when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                        then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                      -- special cases for legacy datasets
                      when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%'
                        then regexp_replace(
                                 regexp_replace(
                                     regexp_replace(
                                         regexp_replace(
                                             regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                        '\[.+ unique\]', ' - unique'),
                                                    '\[.+\]', ''),
                                                'aligned with cds coordinates ', 'cds coordinates'),
                                            'T.brucei paired end RNA-Seqdata from Horn ', '')
                      else null
                    end as varchar(50)
                   ) as profile_set_suffix,
               CASE WHEN replace(profile.profile_as_string_stderr, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string_stderr END as profile_as_string,
               '-1' as max_value, '1' as min_value, '-1' as max_timepoint, '-1' as min_timepoint
            FROM apidb.DataSource ds, sres.ExternalDatabase d, apidb.organism o,
              sres.ExternalDatabaseRelease r, study.NodeSet ps,
              gene_prof profile
            WHERE ds.name = d.name
              AND ds.version = r.version
	      AND ds.taxon_id = o.taxon_id
              AND d.external_database_id = r.external_database_id
              AND profile.node_set_id = ps.node_set_id
              AND ps.external_database_release_id = r.external_database_release_id
            UNION ALL
            SELECT
               ds.name as dataset_name, ds.type as dataset_type, o.abbrev as org_abbrev,
               ds.subtype as dataset_subtype, 'channel1_percentiles' AS profile_type, profile.node_type,
               profile.source_id, profile.node_set_id as profile_study_id,
               ps.name as profile_set_name,
               cast(case
                      when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                        then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                      -- special cases for legacy datasets
                      when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%'
                        then regexp_replace(
                                 regexp_replace(
                                     regexp_replace(
                                         regexp_replace(
                                             regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                        '\[.+ unique\]', ' - unique'),
                                                    '\[.+\]', ''),
                                                'aligned with cds coordinates ', 'cds coordinates'),
                                            'T.brucei paired end RNA-Seqdata from Horn ', '')
                      else null
                    end as varchar(50)
                   ) as profile_set_suffix,
               CASE WHEN replace(profile.profile_as_string_percentile1, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string_percentile1 END as profile_as_string,
               '-1' as max_value, '1' as min_value, '-1' as max_timepoint, '-1' as min_timepoint
            FROM apidb.DataSource ds, sres.ExternalDatabase d, apidb.organism o,
              sres.ExternalDatabaseRelease r, study.NodeSet ps,
              gene_prof profile
            WHERE ds.name = d.name
              AND ds.version = r.version
	      AND ds.taxon_id = o.taxon_id
              AND d.external_database_id = r.external_database_id
              AND profile.node_set_id = ps.node_set_id
              AND ps.external_database_release_id = r.external_database_release_id
            UNION ALL
            SELECT
               ds.name as dataset_name, ds.type as dataset_type, o.abbrev as org_abbrev,
               ds.subtype as dataset_subtype, 'channel2_percentiles' AS profile_type, profile.node_type,
               profile.source_id, profile.node_set_id as profile_study_id,
               ps.name as profile_set_name,
               cast(case
                      when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                        then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                      -- special cases for legacy datasets
                      when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%'
                        then regexp_replace(
                                 regexp_replace(
                                     regexp_replace(
                                         regexp_replace(
                                             regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                        '\[.+ unique\]', ' - unique'),
                                                    '\[.+\]', ''),
                                                'aligned with cds coordinates ', 'cds coordinates'),
                                            'T.brucei paired end RNA-Seqdata from Horn ', '')
                      else null
                    end as varchar(50)
                   ) as profile_set_suffix,
               CASE WHEN replace(profile.profile_as_string_percentile2, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string_percentile2 END as profile_as_string,
               '-1' as max_value, '1' as min_value, '-1' as max_timepoint, '-1' as min_timepoint
            FROM apidb.DataSource ds, sres.ExternalDatabase d, apidb.organism o
              sres.ExternalDatabaseRelease r, study.NodeSet ps,
              gene_prof profile
            WHERE ds.name = d.name
	      AND ds.taxon_id = o.taxon_id  
              AND ds.version = r.version
              AND d.external_database_id = r.external_database_id
              AND profile.node_set_id = ps.node_set_id
              AND ps.external_database_release_id = r.external_database_release_id

     ]]>
    </sql>
    <sql>
      <![CDATA[
        create index orgabbrev_idx&1
          on Profile&1 (org_abbrev)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_idx&1
          on Profile&1 (source_id, profile_type, profile_set_name)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index profset_idx&1
          on Profile&1 (profile_set_name, profile_type)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index srcdset_idx&1
          on Profile&1 (source_id, dataset_subtype, dataset_type)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET dataset_name = 'tbruTREU927_Rijo_Circadian_Regulation_rnaSeq_RSRC'
        WHERE dataset_name= 'tbruTREU927_RNASeq_Rijo_Circadian_Regulation_RSRC'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileType">
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProfileType&1 AS
        SELECT DISTINCT dataset_name, profile_study_id, profile_set_name, profile_set_suffix, node_type, profile_type,
               dataset_type, dataset_subtype
        FROM profile
        WHERE profile_as_string IS NOT NULL
        ORDER BY  dataset_name, profile_set_name,  profile_type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileSamples">
    <internalDependency name="ProfileType"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <sql>
      <![CDATA[
      CREATE TABLE ProfileSamples&1 AS
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id as study_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.nafeatureexpression r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
      AND pt.profile_type not in ('pvalue', 'period', 'amplitude', 'probability_mean','sd','lower_CI','upper_CI','correlation_coefficient')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.NAFeatureMetacycle r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.LopitResults r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.compoundMassSpec r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, APIDB.compoundmassspecresult r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          and pan.name like '%mean%'
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, apidb.ontologytermresult r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.nafeaturehostresponse r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
          SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.subjectresult r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
          SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.EigenGeneWgcnaResults r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psamp_ix&1
          on ProfileSamples&1
            (dataset_name, profile_type, study_id, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_name,
             node_type, protocol_app_node_name)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psampstdy_ix&1
          on ProfileSamples&1
            (study_name, node_type, profile_type, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_id,
             protocol_app_node_name, dataset_name)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExpressionGraphsData">
    <comment>
      for gene-page expression graphs
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="ProfileSamples"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExpressionGraphsData&1  as
          -- RNASeq
          SELECT distinct ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast(case when ps.profile_set_suffix is null then ps.protocol_app_node_name
                          when ps.protocol_app_node_name ='value' then ps.profile_set_suffix 
                          else ps.protocol_app_node_name || ' - ' || ps.profile_set_suffix end ||
                      case when substr(dp.value, 1, 10) in ('0', 'false') and pan.name like '% firststrand %' then '- sense'
                           when substr(dp.value, 1, 10) in ('0', 'false') and pan.name like '% secondstrand %' then '- antisense'
                           when substr(dp.value, 1, 10) in ('1', 'true') and pan.name like '% firststrand %' then '- antisense'
                           when substr(dp.value, 1, 10) in ('1', 'true') and pan.name like '% secondstrand %' then '- sense'
                           else '' end ||
                      case when pan.name like '% unique%' then ' - unique' 
                           else '' end
                       as varchar(300)) AS sample_name,
                 round(nfe.value::numeric, 2) as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, Geneattributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetPresenter dnt, DatasetProperty dp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND ps.dataset_name = dnt.name
            AND dnt.dataset_presenter_id = dp.dataset_presenter_id
            AND dp.property = 'switchStrandsProfiles'
            AND ps.study_name not like '%cuff%'
            AND ps.study_name not like '%htseq-intersection-nonempty%'
            AND ps.study_name not like '%htseq-intersection-strict%'
        UNION
          -- Splice Site data
          SELECT ga.source_id, dd.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                            else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                        end as varchar(300)) AS sample_name,
                 round(nfe.value::numeric, 2) as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, Geneattributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetDatasource dd, DatasetProperty dp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND d.name = dd.name
            AND dd.dataset_presenter_id = dp.dataset_presenter_id
            AND dp.property = 'type' and substr(dp.value, 1, 10) = 'Splice Site'
        UNION
          -- microarray expression, quantitative proteomics, and eQTL
          SELECT ga.source_id, dd.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                             else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                       end as varchar(300)) AS sample_name,
                 CASE WHEN (d.NAME ='pfal3D7_quantitativeMassSpec_Apicoplast_ER_RSRC')
                   THEN round(nfe.VALUE::numeric, 6)
                   ELSE round(nfe.value::numeric, 2) END as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, Geneattributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetDatasource dd, DatasetPresenter dsp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND d.name = dd.name
            AND dd.dataset_presenter_id = dsp.dataset_presenter_id
            AND dd.category != 'RNASeq'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edg_ix&1
          on ExpressionGraphsData&1
            (source_id, dataset_id, sample_name, value, standard_error, percentile_channel1, percentile_channel2)

      ]]>
    </sql>
  </tuningTable>


<!-- TODO:  Turn back on always update -->
<!--  <tuningTable name="Stringdb" alwaysUpdate="true">-->
  <tuningTable name="Stringdb"  alwaysUpdate="true" >
    <comment> Data from STRING-DB.org, populated from their web service.
      Used in the gene record.
    </comment>
    <program commandLine="buildStringdbTT"/>
  </tuningTable>


  <tuningTable name="ApolloUpdate" alwaysUpdate="false">
    <comment>annotation updates from Apollo</comment>
    <ancillaryTable name="ApolloID"/>
    <externalDependency name="dots.NaSequence"/>
    <program commandLine="loadGffApolloTT"/>
  </tuningTable>


  <tuningTable name="DatabaseTaxonUrl">
    <comment>
      Stores a mapping between external databases, taxon IDs, and URLs
    </comment>
    <externalDependency name="apidb.ExternalResourceUrl"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table DatabaseTaxonUrl&1 as
        select edd.dataset_presenter_display_name AS dataset, ga.taxon_id, edr.id_url
        from sres.DbRef db, dots.DbRefNaFeature dbna,
             ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
             Geneattributes ga
        where db.external_database_release_id = edd.external_database_release_id
          and edr.external_database_release_id = edd.external_database_release_id
         and dbna.db_ref_id = db.db_ref_id
         and ga.na_feature_id = dbna.na_feature_id
         and id_url not like 'http://chemlims.com/%'
      union
        select edd.dataset_presenter_display_name AS dataset, ta.taxon_id, edr.id_url
        from sres.dbref db, dots.DbRefNaFeature dbna,
             ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
             Transcriptattributes ta
        where db.external_database_release_id = edd.external_database_release_id
          and edr.external_database_release_id = edd.external_database_release_id
          and dbna.db_ref_id = db.db_ref_id
          and ta.na_feature_id = dbna.na_feature_id
      union
        select d.name as dataset, ga.taxon_id, eru.id_url
        from sres.DbRef dbr, dots.DbRefNaFeature dbrf, sres.ExternalDatabaseRelease r,
             sres.ExternalDatabase d, Geneattributes ga,
             apidb.ExternalResourceUrl eru
        where dbr.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and dbr.db_ref_id = dbrf.db_ref_id
          and dbrf.na_feature_id = ga.na_feature_id
          and upper(d.name) = eru.database_name
      union
        select distinct
               d.name as dataset, ta.taxon_id, eru.id_url
        from sres.DbRef dbr, dots.DbRefAaFeature dbrf, dots.AaFeature aaf,
             sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
             Transcriptattributes ta, apidb.ExternalResourceUrl eru
        where dbr.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and dbr.db_ref_id = dbrf.db_ref_id
          and dbrf.aa_feature_id = aaf.aa_feature_id
          and aaf.aa_sequence_id = ta.aa_sequence_id
          and upper(d.name) = eru.database_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index dtaxu_ix&1
          on DatabaseTaxonUrl&1 (taxon_id, dataset, id_url)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ApolloUpdateGene">
    <comment>
      Text from ApolloUpdate that can be used in site search to find genes
    </comment>
    <internalDependency name="ApolloUpdate"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE ApolloUpdateGene&1 AS
        SELECT ga.source_id
          , ga.project_id
          , au.id_attr
          , ta.gene_source_id
          , 'Y' as matched_result
          -- TODO, cast(utl_url.unescape(replace( replace(regexp_substr(au.attr, 'Name=[^;]*;'), 'Name=', ''), ';', '')) as varchar(400)) as apollo_transcript_id
          , 'TODO' as apollo_transcript_id
          , au.creationdate as comment_date
          , au.apolloproduct || au.apollosymbol || au.apolloowner || au.apollogoterm || au.apollopmid as attr
          , au.apolloproduct as apollo_description
          , au.apolloowner as apollo_owner
          , au.apollopmid as apollo_dbxref
          , au.apollosymbol as apollo_symbol
          , au.apollogoterm as apollo_go_term
          , au.creationdate as creation_date
          , au.apolloevidencecode as evidence_code
          , au.apolloevidencecodeassignment as evidence_code_parameter
          , 'TODO add owner details' as apollo_owner_details
          --, (select firstname.value || ' ' ||  lastname.value || ', ' || address.value from
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'first_name') firstname,
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'last_name') lastname,
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'organization') address) as apollo_owner_details
        FROM ApolloUpdate au, Geneattributes ga, Transcriptattributes ta
        WHERE au.type = 'gene'
          AND (au.attr like '%gene_product=%'
              OR au.attr like '%description=%')
          AND ga.na_sequence_id = au.na_sequence_id
          AND ga.start_min <= au.mapping_end AND ga.end_max >= au.mapping_start
          AND ta.source_id = au.apolloTranscript
          AND ga.strand_plus_minus = au.strand
          AND ta.gene_source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index aug_ix&1
          on ApolloUpdateGene&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>

  <!-- this table is not used anyplace 12/8/25 -->
  <tuningTable name="PreferredProductsGene_p">
    <comment>
      Text for PreferredProduct table on gene record page.
    </comment>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="webready.GeneAttributes_p"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="apidb.Organism"/>
    <intermediateTable name="preferred_product_evids"/>

     <sql>
        <![CDATA[
	      create UNLOGGED table preferred_product_evids as
	      select distinct gaiec.go_evidence_code_id, ot.name
                  from  dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm ot
                  where ot.ontology_term_id = gaiec.go_evidence_code_id
       ]]>
    </sql>

    <!-- Create empty table structure -->
    <sql>
      <![CDATA[
        CREATE TABLE PreferredProductsGene_p&1 (
          source_id text,
          product text,
          project_id text,
          transcript_ids varchar,
          reference varchar,
          evidence_code varchar,
          evidence_code_parameter varchar,
          assigned_by text,
          row_source varchar,
          org_abbrev text
        ) PARTITION BY LIST (org_abbrev)
      ]]>
    </sql>

    <!-- Loop over organisms and insert data -->
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          orgrecord RECORD;
          partition_name TEXT;
        BEGIN
          FOR orgrecord IN SELECT org_abbrev, sanitized_org_abbrev from webready.OrganismAbbreviation_p LOOP
            partition_name := lower('preferredproductsgene_p&1_' || orgrecord.sanitized_org_abbrev);
            EXECUTE format('CREATE TABLE %I PARTITION OF PreferredProductsGene_p&1 FOR VALUES IN (%L)', partition_name, orgrecord.org_abbrev);

            INSERT INTO PreferredProductsGene_p&1
            -- PreferredProductsGene: check apidb.TranscriptProduct and
            -- apidb.GeneFeatureProduct for records with IS_PREFERRED set. If
            -- (and only if) that turns up nothing, check the PRODUCT column of
            -- dots.GeneFeature and dots.Transcript
            with fromDots
            as ( select gf.source_id
                        from dots.GeneFeature gf, webready.GeneAttributes_p ga
                        where gf.product is not null
                        and gf.na_feature_id = ga.na_feature_id
                        and ga.org_abbrev = orgrecord.org_abbrev
                        union
                        select ga.source_id
                        from dots.Transcript t, webready.GeneAttributes_p ga
                        where t.product is not null
                          and t.parent_id = ga.na_feature_id
                          and ga.org_abbrev = orgrecord.org_abbrev
               EXCEPT
               select ta.gene_source_id
                        from apidb.TranscriptProduct tp, webready.TranscriptAttributes_p ta
                        where tp.na_feature_id = ta.na_feature_id
                        and ta.org_abbrev = orgrecord.org_abbrev
                        union
                        select ga.source_id
                        from apidb.GeneFeatureProduct gfp, webready.GeneAttributes_p ga
                        where gfp.na_feature_id = ga.na_feature_id
                        and ga.org_abbrev = orgrecord.org_abbrev)
            select ta.gene_source_id as source_id, tp.product, ta.project_id,
              string_agg(source_id, ', ' order by source_id) as transcript_ids,
              string_agg(publication, ', ' order by source_id) as reference,
              e.name as evidence_code,
              tp.with_from AS evidence_code_parameter,
              cast (max(tp.assigned_by) as varchar(20)) as assigned_by,
              'apidb.TranscriptProduct' as row_source,
              orgrecord.org_abbrev as org_abbrev
            from apidb.TranscriptProduct tp
              INNER JOIN webready.TranscriptAttributes_p ta ON ta.na_feature_id = tp.na_feature_id
              LEFT JOIN preferred_product_evids e ON tp.evidence_code = e.go_evidence_code_id
            where tp.is_preferred = 1
              and ta.org_abbrev = orgrecord.org_abbrev
            group by gene_source_id, ta.project_id, tp.product,
              e.name, tp.with_from
            union
            select ga.source_id, gfp.product, ga.project_id,
              null::varchar as transcript_ids,
              null::varchar as reference,
              null::varchar as evidence_code,
              null::varchar as evidence_code_parameter,
              null::varchar as  assigned_by,
              'apidb.GeneFeatureProduct' as row_source,
              orgrecord.org_abbrev as org_abbrev
            from apidb.GeneFeatureProduct gfp, webready.GeneAttributes_p ga
            where ga.na_feature_id = gfp.na_feature_id
              and gfp.is_preferred = 1
              and ga.org_abbrev = orgrecord.org_abbrev
            group by source_id, ga.project_id, gfp.product
            union
            select t.*, orgrecord.org_abbrev as org_abbrev
            from (select ta.gene_source_id as source_id, ta.transcript_product, ta.project_id,
                    string_agg(source_id, ', ' order by source_id) as transcript_ids,
                    null::varchar as reference,
                    null::varchar as evidence_code,
                    null::varchar as evidence_code_parameter,
                    null::varchar as  assigned_by,
                    'webready.TranscriptAttributes_p/GeneAttributes' as row_source
                  from webready.TranscriptAttributes_p ta
                  where ta.transcript_product is not null
                    and ta.org_abbrev = orgrecord.org_abbrev
                  group by ta.gene_source_id, ta.transcript_product, ta.project_id
                 ) t, fromDots
            where t.source_id = fromDots.source_id;
          END LOOP;
        END $$;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ppg_ix&1
          on PreferredProductsGene_p&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AllGeneProducts_p" prefixEnabled="true">
    <comment>
      all products for each gene
    </comment>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="webready.GeneAttributes_p"/>
    <externalDependency name="webready.TranscriptAttributes_p"/>
    <externalDependency name="webready.OrganismAbbreviation_p"/>
    <externalDependency name="webready.GeneProduct_p"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.Organism"/>
    <intermediateTable name="all_gene_product_evids"/>
    <!-- Create empty table structure -->
    <sql>
     <![CDATA[
       create table &prefixAllGeneProducts_p&1 (
         source_id text,
         product text,
         project_id text,
         is_alternate varchar(3),
         transcript_ids text,
         reference text,
         evidence_code text,
         evidence_code_parameter text,
         assigned_by text,
         source text,
         org_abbrev text
       ) PARTITION BY LIST (org_abbrev)
       ]]>
    </sql>


     <sql>
        <![CDATA[
	      create UNLOGGED table all_gene_product_evids as
	      select distinct gaiec.go_evidence_code_id, ot.name
                  from  dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm ot
                  where ot.ontology_term_id = gaiec.go_evidence_code_id
       ]]>
    </sql>

    <sql>
     <![CDATA[
       do $$
       declare
          orgrecord RECORD;
          partition_name TEXT;
       begin
          FOR orgrecord IN SELECT org_abbrev, sanitized_org_abbrev from webready.OrganismAbbreviation_p LOOP

           partition_name := lower('&prefixallgeneproducts_p&1_' || orgrecord.sanitized_org_abbrev);
           EXECUTE format('CREATE TABLE %I PARTITION OF &prefixAllGeneProducts_p&1 FOR VALUES IN (%L)', partition_name, orgrecord.org_abbrev);

           insert into &prefixAllGeneProducts_p&1
           select ta.gene_source_id AS source_id, tp.product, ta.project_id,
                  CASE tp.is_preferred WHEN 1 THEN 'No' WHEN 0 THEN 'Yes' END as is_alternate,
                  string_agg(ta.source_id, ', ' order by ta.source_id) as transcript_ids,
                -- TODO: fix me.  ta has no publication column
                --  string_agg(ta.publication, ', ' order by ta.source_id) as reference,
                  null as reference,
                  e.name as evidence_code, tp.with_from as evidence_code_parameter,
                  tp.assigned_by, 'apidb.TranscriptProduct' as source, orgrecord.org_abbrev
           from webready.TranscriptAttributes_p ta
              INNER JOIN apidb.TranscriptProduct tp ON ta.na_feature_id = tp.na_feature_id
              LEFT JOIN all_gene_product_evids e ON tp.evidence_code = e.go_evidence_code_id
           where ta.org_abbrev = orgrecord.org_abbrev
           group by ta.gene_source_id, ta.project_id, tp.product, tp.is_preferred, e.name,
                 tp.with_from, tp.assigned_by;

           insert into &prefixAllGeneProducts_p&1
           select ga.source_id as source_id, gfp.product, ga.project_id,
                  CASE gfp.is_preferred WHEN 1 THEN 'No' WHEN 0 THEN 'Yes' END as is_alternate,
                  null as transcript_ids, null as reference, null as evidence_code,
                  null as evidence_code_parameter,
                  -- CHECK AND FIX: OK that apidb.GeneFeatureProduct has NO assigned_by column?
                  NULL as assigned_by,
                  'apidb.GeneFeatureProduct' as source, orgrecord.org_abbrev
           from apidb.GeneFeatureProduct gfp, webready.GeneAttributes_p ga
           where ga.na_feature_id = gfp.na_feature_id
             and ga.org_abbrev = orgrecord.org_abbrev;

           insert into &prefixAllGeneProducts_p&1
           select ga.source_id as source_id, gf.product, ga.project_id,
                  null as  is_alternate,
                  null as transcript_ids, null as reference, null as evidence_code,
                  null as evidence_code_parameter, null as assigned_by,
                  'dots.GeneFeature' as source, orgrecord.org_abbrev
           from dots.GeneFeature gf, webready.GeneAttributes_p ga, webready.GeneProduct_p gp
           where ga.na_feature_id = gf.na_feature_id
             and gf.product is not null
             and ga.source_id = gp.source_id
             and gp.org_abbrev = orgrecord.org_abbrev
             and ga.org_abbrev = orgrecord.org_abbrev
             and gp.source_rule >= 3; -- no product in apidb.GeneFeatureProduct

           insert into &prefixAllGeneProducts_p&1
           select ta.gene_source_id AS source_id, t.product, ta.project_id,
                  null as is_alternate,
                  string_agg(ta.source_id, ', ' order by ta.source_id) as transcript_ids,
                  null as reference, null as evidence_code, null as evidence_code_parameter,
                  null as assigned_by, 'dots.Transcript' as source, orgrecord.org_abbrev
           from webready.TranscriptAttributes_p ta, dots.Transcript t
           where ta.na_feature_id = t.na_feature_id
             and t.product is not null
             and ta.org_abbrev = orgrecord.org_abbrev
             and ta.gene_source_id
                 not in (select source_id
                     from webready.GeneProduct_p
                     where source_rule < 6
                       and org_abbrev = orgrecord.org_abbrev) -- product only in dots.Transcript
           group by ta.gene_source_id, ta.project_id, t.product;

           insert into &prefixAllGeneProducts_p&1
           select gp.source_id as source_id, gp.product, ga.project_id,
                  null as  is_alternate,
                  null as transcript_ids, null as reference, null as evidence_code,
                  null as evidence_code_parameter, null as assigned_by,
                  'unspecified product' as source, orgrecord.org_abbrev
           from webready.GeneProduct_p gp, webready.GeneAttributes_p ga
           where gp.source_rule = 7
             and gp.source_id = ga.source_id
             and ga.org_abbrev = orgrecord.org_abbrev
             and gp.org_abbrev = orgrecord.org_abbrev;
         end loop;
       end $$;
       ]]>
    </sql>

    <!-- Create index -->
    <sql>
      <![CDATA[
        create index allGeneProds_idx&1
        on &prefixAllGeneProducts_p&1 (source_id, product)

      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
