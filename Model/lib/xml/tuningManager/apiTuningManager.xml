<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <import file="tuningManager.xml"/>

  <tuningTable name="TransmembraneDomains" prefixEnabled="false">
    <comment>Locations and Sequence of Transmembrane Domains (TMHMM)
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <sql>
      <![CDATA[
               create table TransmembraneDomains&1 as 
               SELECT ta.source_id as transcript_source_id
                    , ta.gene_source_id AS gene_source_id
                    , ta.project_id
                    , tmf.topology AS tmf_topology
                    , aal.start_min AS tmf_start_min
                    , aal.end_max AS tmf_end_max
                    , dbms_lob.substr(tas.sequence, aal.end_max - aal.start_min + 1, aal.start_min) AS tmf_sequence
                    , tmf.aa_feature_id tmf_aa_feature_id
                    , tmf.aa_sequence_id tmf_aa_sequence_id
                    , tas.source_id as protein_source_id
               FROM dots.aalocation aal
                  , transcriptattributes ta
                  , dots.translatedaafeature taf
                  , dots.translatedaasequence tas
                  , dots.transmembraneaafeature tmf
               WHERE ta.na_feature_id = taf.na_feature_id
                AND taf.aa_sequence_id = tas.aa_sequence_id
                AND tas.aa_sequence_id = tmf.aa_sequence_id
                and tmf.aa_feature_id = aal.aa_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TransDom1_ix&1
        on TransmembraneDomains&1 (tmf_aa_sequence_id, tmf_aa_feature_id, tmf_start_min, tmf_end_max, tmf_topology)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TransDom2_ix&1
        on TransmembraneDomains&1 (gene_source_id, project_id, transcript_source_id, tmf_start_min, tmf_end_max, tmf_topology, tmf_sequence)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="SignalPeptideDomains" prefixEnabled="false">
    <comment>Locations and Sequence of Signal Peptide Domains (SignalP)
    </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <sql>
        <![CDATA[
          CREATE TABLE SignalPeptideDomains&1 AS
          SELECT
              gf.source_id gene_source_id
              , t.source_id transcript_source_id
              , taf.na_feature_id
              , spf.aa_feature_id
              , spf.aa_sequence_id
              , spf.parent_id
              , aal.start_min
              , aal.end_max
              , spf.algorithm_name
              , dbms_lob.substr(s.sequence, aal.end_max, 1) peptide_sequence
          FROM
             dots.SignalPeptideFeature spf
            , dots.AaLocation aal
            , dots.TranslatedAaFeature taf
            , dots.TranslatedAaSequence tas
            , dots.GeneFeature gf
            , dots.AaSequence s
            , dots.Transcript t
          WHERE
              spf.aa_sequence_id = s.aa_sequence_id
              AND aal.aa_feature_id = spf.aa_feature_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = tas.aa_sequence_id
              AND tas.aa_sequence_id = spf.aa_sequence_id
              AND gf.na_feature_id = t.parent_id
              AND (spf.signal_probability >= .5
                  OR spf.signal_probability IS NULL
                  OR ((spf.means_score + spf.maxy_score) / 2) >= .5
                      OR ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3
                  )
          ORDER BY
              spf.aa_sequence_id, spf.aa_feature_id
        ]]>
    </sql>
    <sql>
        <![CDATA[
          CREATE INDEX SignalP1_ix&1
          ON SignalPeptideDomains&1 (aa_sequence_id)
          TABLESPACE indx
        ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX SignalP2_ix&1
          ON SignalPeptideDomains&1 (gene_source_id, transcript_source_id, end_max)
          TABLESPACE indx
        ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismSelectTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for organisms
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table OrganismSelectTaxonRank&1 as 
with organism_rank as (
select tn1.name as organism, o.public_abbrev, tn2.name as parent_organism, 
case when tn2.name = 'Oomycetes' then 'class' else r.rank end as rank

from (
select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
from sres.taxon
start with taxon_id in (select taxon_id from apidb.organism where is_annotated_genome = 1)
connect by prior parent_id = taxon_id) r
, sres.taxonname tn1
, sres.taxonname tn2
, apidb.organism o
where r.input = tn1.taxon_id
and r.taxon_id = tn2.taxon_id
and tn1.name_class = 'scientific name'
and tn2.name_class = 'scientific name'
and (r.rank in ('phylum', 'genus', 'species', 'kingdom', 'class') or (r.rank = 'no rank' and tn2.name = 'Oomycetes'))
and tn1.taxon_id = o.taxon_id
)

select organisms.organism, organisms.public_abbrev, nvl (phylum.parent_organism, 'N/A') as phylum, nvl ( genus.parent_organism, 'N/A') as genus, nvl(species.parent_organism, 'N/A') as species , nvl(kingdom.parent_organism, 'N/A') as kingdom, nvl (class.parent_organism, 'N/A') as class
from 
(select distinct organism, public_abbrev from organism_rank) organisms,
(select * from organism_rank where rank= 'phylum') phylum,
(select * from organism_rank where rank= 'genus') genus,
(select * from organism_rank where rank= 'species') species,
(select * from organism_rank where rank= 'kingdom') kingdom,
(select * from organism_rank where rank= 'class') class
where organisms.organism = phylum.organism (+)
and organisms.organism = genus.organism (+)
and organisms.organism = species.organism (+)
and organisms.organism = kingdom.organism (+)
and organisms.organism = class.organism (+)
 ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PathwayAttributes" prefixEnabled="false">
    <comment>Attributes for Metabolic Pathways
    </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
create table PathwayAttributes&1 as
SELECT
  p.source_id
, p.pathway_id
, p.name
, enz.total_enzyme_count
, cpd.total_compound_count
, p.url
, replace(replace(ed.name, 'Pathways_', ''), '_RSRC', '') as pathway_source
, ed.name as external_db_name
, edr.version as external_db_version
FROM
  sres.pathway p
, sres.externalDatabase ed
, sres.externalDatabaseRelease edr
,(SELECT
    COUNT( *) AS total_compound_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'molecular entity'
  GROUP BY
    pathway_id
  ) cpd
,(SELECT
    COUNT( *) AS total_enzyme_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'enzyme'
  GROUP BY
    pathway_id
  ) enz
WHERE
  ed.external_database_id = edr.external_database_id
  AND edr.external_database_release_id = p.external_database_release_id
  AND cpd.pathway_id = p.pathway_id
  AND enz.pathway_id = p.pathway_id
  AND source_id NOT IN('ec01100', 'ec01110', 'ec01120')
  -- temporarily remove MPMP from release 46
  AND ed.name NOT LIKE '%MPMP%'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX PathAttr_sourceId_pwaySrc&1
          ON &prefixPathwayAttributes&1 (source_id, pathway_source)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathAttr_ix&1
        on PathwayAttributes&1 (pathway_id, source_id, name, pathway_source, total_enzyme_count, total_compound_count)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonPairSummary">
    <comment>synteny stats for each reference-taxon / comparison-taxon pair
    </comment>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.SyntenicGene"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
        create table TaxonPairSummary&1 as
        select ref_taxon_id, comp_taxon_id,
               count(*) as syntenic_span_count,
               sum(ref_length) as ref_coverage,
               avg(ref_length) as average_span_length,
               avg(gene_count) as average_gene_count
        from (select ref_seq.taxon_id as ref_taxon_id,
                     comp_seq.taxon_id as comp_taxon_id,
                     synteny.a_end - synteny.a_start + 1 as ref_length,
                     nvl(sg_summary.gene_count, 0) as gene_count
              from apidb.Synteny, dots.NaSequence ref_seq,
                   dots.NaSequence comp_seq,
                   (select synteny_id, count(*) as gene_count
                    from apidb.SyntenicGene
                    group by synteny_id) sg_summary
              where synteny.a_na_sequence_id = ref_seq.na_sequence_id
                and synteny.b_na_sequence_id = comp_seq.na_sequence_id
                and synteny.synteny_id = sg_summary.synteny_id
             )
        group by ref_taxon_id, comp_taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tps_ix&1
          on TaxonPairSummary&1 (ref_taxon_id, comp_taxon_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="FallbackOrganism">
    <comment>
      Taxon metadata for reference SNPs
    </comment>
    <internalDependency name="PANResults"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        create table FallbackOrganism&1 nologging as
        select ed.name as dataset_name, 'SNP' as type, 'HTS_SNP' as subtype, tn.name as organism,
               o.strain_abbrev as pan_name, pan.protocol_app_node_id, 'name' as term_name,
               study_release.study_name
        from study.ProtocolAppNode pan, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidb.Organism o,
             (select s.study_id, s.external_database_release_id,
                     s.name as study_name
              from study.Study s
              where investigation_id is null) study_release
        where pan.protocol_app_node_id in (select pan_id
                                           from PANResults)
--        and ed.name not in (select dataset_name from InferredParams)
--        and ed.name not in (select dataset_name from InferredChars)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name like '%_NGS_SNPsAndVariations'
          and o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          and o.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TranscriptPathway">
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <sql>
        <![CDATA[
     create table TranscriptPathway&1 ( 
        SOURCE_ID	                VARCHAR2(80),
        GENE_SOURCE_ID	                VARCHAR2(80),
        PROJECT_ID	                VARCHAR2(20),
        PATHWAY_SOURCE_ID	        VARCHAR2(50),
        PATHWAY_NAME	                VARCHAR2(150),
        EC_NUMBER_GENE	                VARCHAR2(16),
        WILDCARD_COUNT_GENE	        NUMBER,
        EC_NUMBER_PATHWAY	        VARCHAR2(16),
        WILDCARD_COUNT_PATHWAY	        NUMBER,
        EXACT_MATCH	                NUMBER,
        COMPLETE_EC	                NUMBER,
        PATHWAY_ID	                NUMBER(12,0),
        PATHWAY_SOURCE	                VARCHAR2(200),
        EXTERNAL_DATABASE_RELEASE_ID	NUMBER(10,0)
     )
      ]]>
    </sql>
    <sql>
      <![CDATA[
  BEGIN
  FOR idlist IN (
    SELECT  distinct organism 
      from GeneAttributes
    )
  LOOP
   insert into TranscriptPathway&1 nologging
       with transcript_ec
        as (select ec.enzyme_class_id, ec.ec_number, ec.ec_number_1, ec.ec_number_2, ec.ec_number_3, ec.ec_number_4,
                   regexp_count( ec.ec_number, '-') as wildcard_count
            from sres.EnzymeClass ec
            where enzyme_class_id
                  in (select enzyme_class_id
                      from dots.AaSequenceEnzymeClass)),
        pathway_node_ec
        as (select distinct pn.pathway_id, pn.row_id as enzyme_class_id
            from sres.PathwayNode pn, sres.ontologyterm ot
                      where pn.pathway_node_type_id = ot.ontology_term_id
                      and ot.name = 'enzyme'
                      and pn.display_label != '-.-.-.-'),
        pathway_ec
        as (select ec.enzyme_class_id, ec.ec_number, ec.ec_number_1, ec.ec_number_2, ec.ec_number_3, ec.ec_number_4,
                   regexp_count( ec.ec_number, '-') as wildcard_count
            from sres.EnzymeClass ec
            where enzyme_class_id
                  in (select enzyme_class_id
                      from pathway_node_ec)),
        ec_match
        as (select tec.enzyme_class_id as transcript_enzyme_class_id,
                   pec.enzyme_class_id as pathway_enzyme_class_id,
                   tec.wildcard_count as wildcard_count_transcript,
                   pec.wildcard_count as wildcard_count_pathway,
                   tec.ec_number as ec_number_transcript,
                   pec.ec_number as ec_number_pathway
            from transcript_ec tec, pathway_ec pec
            where (tec.ec_number_1 = pec.ec_number_1 or tec.ec_number_1 is null or pec.ec_number_1 is null)
              and (tec.ec_number_2 = pec.ec_number_2 or tec.ec_number_2 is null or pec.ec_number_2 is null)
              and (tec.ec_number_3 = pec.ec_number_3 or tec.ec_number_3 is null or pec.ec_number_3 is null)
              and (tec.ec_number_4 = pec.ec_number_4 or tec.ec_number_4 is null or pec.ec_number_4 is null))
        select distinct ga.source_id
        , ga.gene_source_id
        , ga.project_id
        , pa.source_id as pathway_source_id
        , pa.name as pathway_name
        , ec_match.ec_number_transcript as ec_number_gene
        , ec_match.wildcard_count_transcript as wildcard_count_gene
        , ec_match.ec_number_pathway
        , ec_match.wildcard_count_pathway
        , CASE WHEN ec_match.ec_number_pathway = ec_match.ec_number_transcript
            THEN 1
            ELSE 0 END as exact_match
        , CASE WHEN ec_match.wildcard_count_pathway + ec_match.wildcard_count_transcript = 0
            THEN 1
            ELSE 0  END as complete_ec 
        , pa.pathway_id
        , pa.pathway_source
        , p.external_database_release_id
        from PathwayAttributes pa
        , sres.pathway p
        , pathway_node_ec pec
        , ec_match
        , dots.AaSequenceEnzymeClass asec
        , TranscriptAttributes ga
        where ga.organism = idlist.organism
        and pa.pathway_id = pec.pathway_id
        and p.pathway_id = pa.pathway_id
        and pec.enzyme_class_id = ec_match.pathway_enzyme_class_id
        and asec.enzyme_class_id = ec_match.transcript_enzyme_class_id
        and ga.aa_sequence_id  = asec.aa_sequence_id
	AND ( (ga.orthomcl_name IS NULL AND asec.evidence_code != 'OrthoMCLDerived') OR ga.orthomcl_name IS NOT NULL)
;
    commit;
   END LOOP;
  END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptPath_ix&1
        on TranscriptPathway&1(gene_source_id, source_id, pathway_source_id,
                               pathway_name, pathway_id, ec_number_gene, wildcard_count_pathway,
                               ec_number_pathway, pathway_source)
        tablespace indx
      ]]>
    </sql>
    <sql>
        <![CDATA[
            create index TranscriptPathSource_ix&1
            on TranscriptPathway&1(pathway_source, gene_source_id, source_id)
            tablespace indx
        ]]>
    </sql>
  </tuningTable>

  <tuningTable name="EcMatch">
    <internalDependency name="TranscriptPathway"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        create table EcMatch&1 nologging as
        with tp_ec
        as (select distinct ec_number_gene
            from TranscriptPathway),
        wildcarded_pathway_ec
        as (select distinct enzyme
            from PathwayReactions
            where enzyme like '%.%.%.%'
              and enzyme like '%-%'
              and enzyme != '-.-.-.-'),
        unwildcarded_pathway_ec
        as (select distinct enzyme
            from PathwayReactions
            where enzyme like '%.%.%.%'
              and enzyme not like '%-%')
        -- end of WITH clause
          select ec_number_gene, wpe.enzyme, 1 as is_wildcarded
          from tp_ec te, wildcarded_pathway_ec wpe
          where te.ec_number_gene like replace(wpe.enzyme, '-', '%')
        union all
          select ec_number_gene, upe.enzyme, 0 as is_wildcarded
          from tp_ec te, unwildcarded_pathway_ec upe
          where te.ec_number_gene = upe.enzyme
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ecmtch_gene_ix&1
        on EcMatch&1(ec_number_gene, enzyme, is_wildcarded)
        tablespace indx
      ]]>
    </sql>
    <sql>
        <![CDATA[
        create index ecmtch_enzyme_ix&1
        on EcMatch&1(enzyme, ec_number_gene, is_wildcarded)
        tablespace indx
        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayNodeGene">
    <internalDependency name="TranscriptPathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
       create table PathwayNodeGene&1 nologging as
select distinct pn.pathway_node_id
, tp.gene_source_id
from transcriptpathway tp
   , sres.pathwaynode pn
where tp.pathway_id = pn.pathway_id
and tp.ec_number_gene like replace(pn.display_label, '-', '%')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="RnaSeqStats">
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table RnaSeqStats&1 nologging as
        select study_id, study_name, dataset_name, taxon_id, round(avg(num_reads),0) as avg_unique_reads
        from (select sl.study_id
                , s.name as study_name
                , ed.name as dataset_name
                , ds.taxon_id
                , c.value as num_reads
            from apidb.Datasource ds
                , sres.ExternalDatabase ed
                , sres.ExternalDatabaseRelease edr
                , study.Study s
                , study.StudyLink sl
                , study.ProtocolAppNode pan
                , study.Characteristic c
                , sres.OntologyTerm ot
            where ds.external_database_name = ed.name
                and ed.external_database_id = edr.external_database_id
                and edr.external_database_release_id = s.external_database_release_id
                and s.study_id = sl.study_id
                and sl.protocol_app_node_id = pan.protocol_app_node_id
                and pan.protocol_app_node_id = c.protocol_app_node_id
                and c.qualifier_id = ot.ontology_term_id
                and (ot.source_id = 'EUPATH_0000460' or ot.source_id = 'EuPathUserDefined_00507'))
        group by study_id, study_name, dataset_name, taxon_id
        union
        select study_id, study_name, dataset_name, taxon_id, round(2*avg(num_reads),0) as avg_unique_reads
        from (select sl.study_id
                , s.name as study_name
                , ed.name as dataset_name
                , ds.taxon_id
                , c.value as num_reads
            from apidb.Datasource ds
                , sres.ExternalDatabase ed
                , sres.ExternalDatabaseRelease edr
                , study.Study s
                , study.StudyLink sl
                , study.ProtocolAppNode pan
                , study.Characteristic c
                , sres.OntologyTerm ot
            where ds.external_database_name = ed.name
                and ed.external_database_id = edr.external_database_id
                and edr.external_database_release_id = s.external_database_release_id
                and s.study_id = sl.study_id
                and sl.protocol_app_node_id = pan.protocol_app_node_id
                and pan.protocol_app_node_id = c.protocol_app_node_id
                and c.qualifier_id = ot.ontology_term_id
                and (ot.source_id = 'EUPATH_0000468' or ot.source_id = 'EuPathUserDefined_00515' or ot.source_id = 'EUPATH_0000476' or ot.source_id = 'EuPathUserDefined_00523'))
        group by study_id, study_name, dataset_name, taxon_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OntologyLevels" prefixEnabled="true">
    <comment>the max and min depth of each ontology term in OntologyRelationship. Used by the GoTermSummary tuning table</comment>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyLevels&1 nologging as
        with is_a_links -- not closure, just real links
             as (select subject_term_id, object_term_id
                 from sres.OntologyRelationship rel, sres.OntologyTerm pred
                 where rel.predicate_term_id = pred.ontology_term_id
                   and pred.name = 'is_a'),
             roots -- terms with no parents
             as ( select object_term_id from is_a_links
                 minus
                  select subject_term_id from is_a_links),
             levels -- terms and all their depths, unaggregated
             as ( select object_term_id as ontology_term_id, 0 as depth from roots
                 union
                  select subject_term_id as ontology_term_id, level + 1 as depth
                  from is_a_links
                  start with object_term_id in (select object_term_id from roots)
                  connect by object_term_id = prior subject_term_id)
        select ontology_term_id, min(depth) as min_depth, max(depth) as max_depth
        from levels
        group by ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index olev_termix&1 on &prefixOntologyLevels&1 (ontology_term_id, min_depth, max_depth)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="InterproResults" prefixEnabled="true">
    <comment>GeneGoTerms: each row represents one GO term assignment to one gene, right from what was loaded.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="dots.DomainFeature"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <ancillaryTable name="InterproDomainDatabase"/>
    <ancillaryTable name="InterproDomainAccession"/>
    <sql>
      <![CDATA[
        create table &prefixInterproResults&1 nologging as
        select
          ta.source_id as transcript_source_id
        , ta.protein_source_id
        , ta.gene_source_id as gene_source_id
        , ta.project_id
        , ta.organism
        , xd1.name AS interpro_db_name
        , dr.primary_identifier AS interpro_primary_id
        , dr.secondary_identifier AS interpro_secondary_id
        , substr(dr.remark, 1, 400) AS interpro_desc
        , al.start_min AS interpro_start_min
        , al.end_min AS interpro_end_min
        , CASE
            WHEN df.e_value = 0
            THEN '0'
            ELSE TO_CHAR(df.e_value, '9.9EEEE')
          END AS interpro_e_value
        , df2.source_id AS interpro_family_id
        FROM
          TranscriptAttributes ta
        , dots.AaLocation al
        , sres.ExternalDatabaseRelease xdr1
        , sres.ExternalDatabase xd1
        , sres.ExternalDatabaseRelease xdr3 
        , sres.ExternalDatabase xd3
        , sres.DbRef dr
        , dots.DbRefAaFeature draf
        , dots.DomainFeature df
        , dots.DomainFeature df2
        WHERE xd3.name IN('InterproscanData_RSRC', 'INTERPRO', 'Prints', 'HAMAP', 'SFLD', 'TIGRFAM', 'SUPERFAMILY', 'Pfam', 'PIRSF', 'PROSITE patterns', 'Superfamily', 'PRINTS', 'InterProScan', 'PFAM', 'SMART', 'CDD', 'PANTHER')
          AND ta.aa_sequence_id = df.aa_sequence_id
          AND (ta.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
          AND df.aa_feature_id = draf.aa_feature_id
          AND df.aa_feature_id = al.aa_feature_id
          AND draf.db_ref_id = dr.db_ref_id
          AND dr.external_database_release_id = xdr1.external_database_release_id
          AND xdr1.external_database_id = xd1.external_database_id
          AND df.external_database_release_id = xdr3.external_database_release_id
          AND xdr3.external_database_id = xd3.external_database_id
          and df.parent_id = df2.aa_feature_id (+)
          and dr.primary_identifier is not null
      ]]>
    </sql>
    <sql>
      <!-- gene/transcript id search (primary use case) -->
      <![CDATA[
        create index ips_resix&1 on &prefixInterproResults&1 (organism, interpro_db_name, interpro_primary_id, interpro_secondary_id, interpro_desc, transcript_source_id, gene_source_id, project_id, interpro_e_value)
        tablespace indx
      ]]>
    </sql>

    <!-- PBrowse (all rows for a protein)--> 
    <sql>
      <![CDATA[
        create index ips_res1ix&1 on &prefixInterproResults&1 (protein_source_id)
        tablespace indx
      ]]>
    </sql>

    <!-- Gene Record Page.  (May help some with download;  we are not prioritizing speed for download) -->
    <sql>
      <![CDATA[
        create index ips_res21ix&1 on &prefixInterproResults&1 (project_id, gene_source_id)
        tablespace indx
      ]]>
    </sql>

    <!-- domain database param query --> 
    <sql>
      <![CDATA[
        create table &prefixInterproDomainDatabase&1 nologging as
        select distinct interpro_db_name
               from &prefixInterproResults&1
      ]]>
    </sql>

    <!-- domain accession param query --> 
    <sql>
      <![CDATA[
        create table &prefixInterproDomainAccession&1 nologging as
        select interpro_db_name, 
               interpro_primary_id,
               interpro_secondary_id,
               interpro_desc,
               count(*) as ct_hits
        from &prefixinterproresults&1
         where interpro_primary_id is not null                                                                                                                                                    
         group by interpro_db_name, interpro_primary_id, interpro_secondary_id, interpro_desc
      ]]>
    </sql>

    <!-- domain Accession param query --> 
    <sql>
      <![CDATA[
        create index ips_p1ix&1 on &prefixInterproDomainAccession&1 (interpro_db_name, interpro_primary_id, interpro_secondary_id, interpro_desc, ct_hits)
        tablespace indx
      ]]>
    </sql>



  </tuningTable>


  <tuningTable name="GeneGoTerms" prefixEnabled="true">
    <comment>GeneGoTerms: each row represents one GO term assignment to one gene, right from what was loaded.
     </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixGeneGoTerms&1 nologging as
        with root_term
             as (select ontology_term_id,
                        cast(initcap(replace(name, '_', ' ')) as varchar2(20)) as ontology
                 from sres.OntologyTerm
                 where source_id in ('GO_0008150','GO_0003674','GO_0005575'))
        select gf.source_id as gene_source_id, t.source_id as transcript_source_id, taf.aa_sequence_id,
               cast (decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as varchar2(3)) as is_not, ns.taxon_id,
               cast (gt.source_id as varchar2(20)) as go_id,
               gt.ontology_term_id as go_term_id, rt.ontology,
               cast(gt.name as varchar2(250)) as go_term_name,
               cast(gail.name as varchar2(24)) as source,
               cast(gec.name as varchar2(12)) as evidence_code,
               cast(gaiec.reference as varchar2(250)) as reference,
               cast(gaiec.evidence_code_parameter as varchar2(80))as evidence_code_parameter
        from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf, dots.GoAssociation ga,
             sres.OntologyTerm gt, dots.GoAssociationInstance gai, dots.GoAssociationInstanceLoe gail,
             dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm gec, root_term rt, dots.NaSequence ns
        where t.parent_id = gf.na_feature_id
          and gf.na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
          and t.na_feature_id = taf.na_feature_id
          and taf.aa_sequence_id = ga.row_id
          and ga.table_id = (select table_id
                             from core.TableInfo
                             where name = 'TranslatedAASequence')and ga.go_term_id = gt.ontology_term_id
          and ga.go_association_id = gai.go_association_id
          and gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
          and gai.go_association_instance_id = gaiec.go_association_instance_id
          and gaiec.go_evidence_code_id = gec.ontology_term_id
          and gt.ancestor_term_id = rt.ontology_term_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ggt_ix&1 ON &prefixGeneGoTerms&1
               (gene_source_id, transcript_source_id, ontology, go_id, go_term_id,
                go_term_name, source, evidence_code, reference,
                evidence_code_parameter, aa_sequence_id, is_not)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGoTable">
    <comment>A tuning table for the gene record GO term table
    </comment>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table GeneGoTable&1 nologging as
        select source_id, project_id, go_id,
               listagg(transcript_source_id, ', ') within group (order by transcript_source_id) as transcript_ids,
               is_not,
               max(go_term_name) as go_term_name, ontology, source, evidence_code,
               reference, evidence_code_parameter, sort_key
        from (select distinct ggt.gene_source_id as source_id, ga.project_id,
                              replace(ggt.go_id, 'GO_', 'GO:') as go_id,
                              ggt.transcript_source_id,
                              case when ggt.is_not = 'not' then 'Is not' else '' end AS is_not,
                              ggt.go_term_name, ggt.ontology, ggt.source, ggt.evidence_code,
                              ggt.reference, ggt.evidence_code_parameter,
                              substr(ggt.ontology, 1, 1) || replace(ggt.go_id, 'GO_', 'GO:') as sort_key
              from GeneGoTerms ggt, GeneAttributes ga
              where ggt.gene_source_id = ga.source_id)
        group by source_id, project_id, go_id, is_not, ontology,
                 source, evidence_code, reference, evidence_code_parameter, sort_key
        order by source_id, ontology, go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ggtab_ix&1 ON GeneGoTable&1
               (source_id, project_id, go_id, transcript_ids, is_not, go_term_name,
                ontology, source, evidence_code, reference, evidence_code_parameter, sort_key)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoSubsetLeaf">
    <comment>
       Map each GO term that is assigned to at least one gene to a GoSubset term
       that is either itself or an immediate ancestor. By "immediate ancestor"
       we mean an ancestor such that there isn't an intermediate ancestor also
       in the subset. (Note that there can be multiple links as long as none is
       in the subset.) This is currently restricted to 'goslim_generic', solely
       by the condition in the SUBSET_TERM subquery.
    </comment>
    <externalDependency name="apidb.GoSubset"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <internalDependency name="GeneGoTerms"/>
    <sql>
      <![CDATA[
        create table GoSubsetLeaf&1 nologging as
        with leaf_term -- GO terms assigned to at least one gene
             as (select distinct go_term_id
                 from GeneGoTerms),
             subset_term -- (term ID, subset name) pairs
             as (select distinct -- "distinct" is probably unneeded
                        ontology_term_id, go_subset_term
                 from apidb.GoSubset
                 -- where go_subset_term != 'gosubset_prok' -- unrelated and huge
                 where go_subset_term = 'goslim_generic' -- all we currently need
                ),
             subset -- the 17 or so distinct subset names, e.g. "goslim_generic"
             as (select distinct go_subset_term
                 from subset_term),
             leaf_in_subset -- leaf (i.e. assigned) terms that are in a subset
             as (select leaf_term.go_term_id, subset_term.go_subset_term
                 from leaf_term, subset_term
                 where leaf_term.go_term_id = subset_term.ontology_term_id),
             leaf_not_in_subset -- (go_term_id, subset) pairs such that the GO
             as (               -- term is assigned, but not in the given subset
                   select leaf_term.go_term_id, subset.go_subset_term
                   from leaf_term, subset -- cartesian join
                 minus
                   select go_term_id, go_subset_term
                   from leaf_in_subset),
             leaf_ancestor -- a leaf not in a subset, with an ancestor that is in the subset
             as (select lnis.go_subset_term, lnis.go_term_id, gs.ontology_term_id as ancestor_term_id
                 from leaf_not_in_subset lnis, sres.OntologyRelationship orel, apidb.GoSubset gs
                 where orel.subject_term_id = lnis.go_term_id -- "subject" = "child"
                   and orel.object_term_id = gs.ontology_term_id
                   and orel.subject_term_id != orel.object_term_id
                   and lnis.go_subset_term = gs.go_subset_term),
             leaf_nonimmediate_ancestor
             as (select distinct upper.go_subset_term, upper.go_term_id, upper.ancestor_term_id
                 from leaf_ancestor upper, leaf_ancestor lower, sres.OntologyRelationship orel
                 where upper.go_subset_term = lower.go_subset_term
                   and upper.go_term_id = lower.go_term_id
                   and upper.ancestor_term_id = orel.object_term_id
                   and lower.ancestor_term_id = orel.subject_term_id
                   and orel.subject_term_id != orel.object_term_id),
             leaf_immediate_ancestor
             as (  select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_ancestor
                 minus
                   select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_nonimmediate_ancestor)
          select -- leaf terms that are in a subset
                 cast (go_subset_term as varchar2(50)) as go_subset_term, go_term_id, go_term_id as subset_leaf_term_id
          from leaf_in_subset
        union
          select -- leaf terms not in subset with their subset immediate ancestors
                 cast (go_subset_term as varchar2(50)) as go_subset_term, go_term_id, ancestor_term_id as subset_leaf_term_id
          from leaf_immediate_ancestor
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gsl_ix&1 ON GoSubsetLeaf&1 (go_term_id, go_subset_term, subset_leaf_term_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoTermSummary" prefixEnabled="true">
    <comment>GoTermSummary: each row represents one GO term assignment to one gene.
         (Typically, a gene has multiple such assignments.) This is used for
          finding gene-GO mappings, such as for the gene-page GO table.
     </comment>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="OntologyLevels"/>
    <externalDependency name="apidb.GoSubset"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
          create table &prefixGoTermSummary&1 nologging as
          select ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id,
                 ggt.taxon_id, ggt.is_not, replace(ggt.go_id, '_', ':') as go_id,
                 ggt.go_term_id, ggt.ontology,
                 replace(ggt.go_term_name, '_',' ') as go_term_name, ggt.source,
                 ggt.evidence_code, 
                 decode(ggt.evidence_code, 'IEA', 'Computed', 'Curated') as evidence_category,
                 ggt.reference, ggt.evidence_code_parameter,
                 ol.min_depth as depth,
                 case
                   when gs.ontology_term_id is null then 0
                   else 1
                 end as is_go_slim
          from &prefixGeneGoTerms ggt, &prefixOntologyLevels ol,
               (select distinct ontology_term_id
                from apidb.GoSubset
                where go_subset_term = 'goslim_generic') gs
          where ggt.go_term_id = ol.ontology_term_id(+)
            and ggt.go_term_id = gs.ontology_term_id(+)
        union
          select ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id,
                 ggt.taxon_id, ggt.is_not,
                 replace (substr(ot.source_id, 1, 25),'_',':') as go_id,
                 ot.ontology_term_id as go_term_id, ggt.ontology,
                 replace (substr(ot.name, 1,250),'_',' ') as go_term_name,
                 ggt.source, ggt.evidence_code,
                 decode(ggt.evidence_code, 'IEA', 'Computed', 'Curated') as evidence_category,
                 ggt.reference,
                 ggt.evidence_code_parameter,
                 ol.min_depth as depth,
                 case
                   when gs.ontology_term_id is null then 0
                   else 1
                 end as is_go_slim
          from &prefixGeneGoTerms ggt, sres.OntologyRelationship orel,
               sres.OntologyTerm ot, &prefixOntologyLevels ol,
               sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
               (select distinct ontology_term_id
                from apidb.GoSubset
                where go_subset_term = 'goslim_generic') gs
          where ggt.go_term_id = orel.subject_term_id
            and orel.object_term_id = ot.ontology_term_id
            and ot.ontology_term_id = ol.ontology_term_id(+)
            and edr.external_database_release_id = ot.external_database_release_id
            and edr.external_database_id = ed.external_database_id
            and ed.name ='GO_RSRC'
            and ot.ontology_term_id = gs.ontology_term_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_aaSeqId_idx&1 ON &prefixGoTermSummary&1 (aa_sequence_id, go_id, source)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_plugin_ix&1 ON &prefixGoTermSummary&1
               (ontology, gene_source_id, is_not, is_go_slim,
                go_id, go_term_name, evidence_code, evidence_category)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="sres.ExternalDatabase"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
CREATE TABLE DatasetExampleSourceId&1 NOLOGGING AS
with profiles as (
select p.source_id,
       ga.project_id,
       ga.sequence_id,
       d.name,
       row_number() over(partition by d.name
                         order by ga.chromosome_order_num, p.profile_as_string desc) as rn
from Profile p, sres.ExternalDatabase d, GeneAttributes ga
where p.dataset_name = d.name
and p.profile_as_string is not null
and p.source_id = ga.source_id (+)
)
select p.source_id as example_source_id, p.project_id, p.sequence_id, p.name as dataset
from profiles p
where p.rn = 1
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneWord">
    <!-- Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
      -->
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table GeneWord&1 nologging as
        select source_id, taxon_id,
               -- for each rn (1 - max_words_in_any_product),
               --    print the rn-th word.
               --    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN
               substr(regexp_replace(regexp_substr (product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
        from GeneAttributes
        cross
               -- create a table of integers 1 - n where n is the max number of words in any product
        join (select rownum rn
              from (select max (regexp_count (product, '[ ,]')) + 1 mx
                    from GeneAttributes)
              connect by level <= mx
             )
        where regexp_substr (product, '[^, ]+', 1, rn) is not null
        order by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneWord_idx&1 ON GeneWord&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
         as by project_id(), the function that maps an organism to a project.
      </comment>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="ChIPchipTranscript"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="Profile"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="OrganismCentromere"/>
    <intermediateTable name="SequenceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="PopsetCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
CREATE TABLE DataSourceCount nologging as ( 
  SELECT * FROM (
    SELECT DISTINCT enas.taxon_id, 'organellar' AS stype, 1 AS num
    FROM dots.externalNAsequence enas, SRES.ontologyterm ot
    WHERE enas.sequence_ontology_id = ot.ontology_term_id
    AND ot.name in( 'mitochondrial_chromosome','apicoplast_chromosome')
    GROUP BY  enas.taxon_id
    UNION
    SELECT distinct ds.taxon_id, 'HTSIsolate' AS stype, 1 AS num
    FROM   apidb.DataSource ds
    WHERE ds.type = 'isolates' AND ds.subtype = 'HTS_SNP'
    GROUP BY  taxon_id
    UNION
    SELECT distinct ds.taxon_id, 'Popset' AS stype, 1 AS num
    FROM   apidb.DataSource ds
    WHERE ds.subtype = 'sequenceing_types'
    GROUP BY  taxon_id
    UNION
    SELECT distinct ds.taxon_id, 'Epitope' AS stype, 1 AS num
    FROM   apidb.DataSource ds
    WHERE ds.type = 'epitope'
    GROUP BY  taxon_id
    UNION
    SELECT distinct ds.taxon_id, 'Array' AS stype, 1 AS num
    FROM   apidb.DataSource ds
    WHERE ds.type = 'transcript_expression'
    AND ds.subtype = 'array'
    GROUP BY  taxon_id
      ) PIVOT (
        LISTAGG(num, ';') WITHIN GROUP (ORDER BY num) AS has
        FOR stype IN ('organellar' organellar, 'Epitope' Epitope, 'Array' Array, 'HTSIsolate' HTSIsolate, 'Popset' Popset)
        )
  )
    ]]>
   </sql>


    <sql>
      <![CDATA[
CREATE TABLE OrganismCentromere nologging as ( 
        SELECT distinct s.taxon_id,
               case when count(*) > 0 then 1 else 0 end as hasCentromere
        FROM  DOTS.MISCELLANEOUS f
            , sres.ontologyTerm ot
            , dots.nasequence s
        WHERE ot.ontology_term_id = f.sequence_ontology_id
         AND ot.name='centromere'
         and f.na_sequence_id = s.na_sequence_id
        group by s.taxon_id
 )
      ]]>
    </sql>


    <sql>
      <![CDATA[
       create table SequenceCount nologging as
       select * from (
         select count(*) as num, sequence_type, taxon_id
         from GenomicSeqAttributes
         where is_top_level =1
       group by  taxon_id, sequence_type)
       pivot (
         listagg(num, ';') within group (order by num) as num
         for sequence_type in ('contig' contig, 'supercontig' supercont, 'chromosome' chrom)
       )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create table CommunityCount nologging as
       select taxon_id, count(*) as communityCount
       from GeneAttributes
       where (source_id, project_id)
              in (select distinct stable_id, project_name
                  from userlogins5.mappedComment@prodn.login_comment
                  where is_visible = 1
                    and comment_target_id = 'gene')
       group by taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE ProfileCount nologging as (
        select ga.taxon_id,         
                            count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype like '%rt_pcr%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rtPCRCount,     
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'rnaseq'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rnaSeqCount,
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'array'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as geneArrayCount
         from Profile p
              right outer join GeneAttributes ga on ga.source_id = p.source_id
         group by ga.taxon_id
)       
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE PopsetCount nologging as (
        SELECT count(distinct gene.source_id) as popsetCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, nas.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s, PopsetAttributes i,
                core.tableinfo t, dots.nasequence nas
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND s.pvalue_exp <= -10
           ) sim LEFT JOIN
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, PopsetAttributes i, GeneAttributes g, 
                  core.tableinfo t, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  g.end_max
              AND s.max_subject_end >= g.start_min
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           ON gene.source_id = sim.source_id AND gene.sequence_id = sim.sequence_source_id)
        GROUP BY sim.taxon_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE GeneCount nologging as (    
select genomestat.taxon_id,
       genomestat.project_id,
       genomestat.database_version,
       genomestat.ncbi_tax_id,
       genomestat.Megabps,
       nvl(snpCount.ct,0) as snpCount,
       nvl(count(distinct ga.source_id),0) as geneCount,
       nvl(count(distinct case when ga.is_pseudo =1  then ga.source_id else '' end),0) as pseudoGeneCount,    
       nvl(count(distinct case when (ga.gene_type ='protein coding' or ga.gene_type ='protein coding gene') then ga.source_id else '' end),0) as codingGeneCount,
       nvl(count(distinct case when (ga.gene_type ='protein coding' or ga.gene_type ='protein coding gene') then '' else ga.source_id end),0) as otherGeneCount, 
       nvl(count (distinct (case when ga.is_deprecated = 0
                  then cct.gene_source_id
                  else NULL 
                  end)),0) ChipChipGeneCount ,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then pp.source_id
                  else NULL 
                  end)),0) orthologCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then gts.gene_source_id
                  else NULL 
                  end)),0) goCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then tfbs.gene_source_id
                  else NULL 
                  end)),0) tfbsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then mss.aa_sequence_id
                  else NULL 
                  end)),0) proteomicsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then est.source_id
                  else NULL 
                  end)),0) estCount,
      nvl(count (distinct (case when (ga.is_deprecated = 0 and ta.ec_numbers is not null)
                  then ga.source_id 
                  else NULL 
                  end)),0) ecNumberCount
        FROM   GeneAttributes ga
               left outer join apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
               left outer join gotermsummary gts on ga.source_id = gts.gene_source_id
               left outer join TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
               left outer join TranscriptAttributes ta on ta.gene_source_id = ga.source_id
               left outer join apidb.MassSpecSummary mss on ta.aa_sequence_id = mss.aa_sequence_id
               left outer join chipchipTranscript cct on ga.source_id = cct.gene_source_id
               left outer join (SELECT distinct s.gene as source_id 
                                  FROM EstAlignmentGeneSummary s, EstAttributes e 
                                  WHERE s.est_gene_overlap_length >= 100 
                                    AND s.is_best_alignment in (1) 
                                    AND s.percent_est_bases_aligned >= 20  
                                    AND s.percent_identity >= 90  
                                    AND e.best_alignment_count <= 1 
                                    AND e.source_id = s.accession   
                                    GROUP by s.gene HAVING count(*) >= 1) est on ga.source_id = est.source_id
          right outer join
         ( SELECT  project_id, taxon_id,
                 max(database_version) as database_version,
                CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                     ELSE ncbi_tax_id
                END ncbi_tax_id, 
                to_char(sum(length)/1000000,'9999.99') as megabps 
         FROM   GenomicSeqAttributes 
         WHERE  is_top_level = 1
         GROUP BY project_ID, taxon_id, ncbi_tax_id
       ) genomestat on genomestat.taxon_id = ga.taxon_id
        left outer join       
      (
       SELECT count(distinct ga.source_id) as ct, ga.taxon_id 
       FROM GeneAttributes ga, SnpAttributes sf  
       WHERE  sf.gene_source_id = ga.source_id
         AND ga.is_deprecated = 0 
       GROUP BY ga.taxon_id 
      ) snpCount on ga.taxon_id = snpCount.taxon_id
        group by genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 snpCount.ct
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE OrganismAttributes&1 NOLOGGING AS
SELECT oa.*, tn2.name as species, t.ncbi_tax_id as species_ncbi_tax_id
       , CASE  WHEN ltrim(replace(oa.organism_name, tn2.name))= oa.organism_name 
               THEN strain_abbrev
               ELSE ltrim(replace(oa.organism_name, tn2.name)) END AS strain
FROM
(
SELECT o.project_name as project_id,
       case when t.ncbi_tax_id > 10000000
--       then 'TMPTX_' || round(t.ncbi_tax_id / 10000000) || '_' ||
--            mod(t.ncbi_tax_id, 10000000) -- e.g. "TMPTX_930_1"
--       then 'TMPTX_' || t.ncbi_tax_id -- all the many digits
         then 'TMPTX_' || o.public_abbrev
         else 'NCBITAXON_' || t.ncbi_tax_id
       end as source_id,
       o.abbrev as internal_abbrev,
       o.public_abbrev,
       o.orthomcl_abbrev,
       o.family_name_for_files,
       tn.name as organism_name,
       o.genome_source,
       o.strain_abbrev,
       o.is_annotated_genome,
       o.is_reference_strain,
       o.is_family_representative,
       o.name_for_filenames,
       o.taxon_id as component_taxon_id,
       gc.database_version,
       gc.megabps as megabps,
       gc.ncbi_tax_id as ncbi_tax_id,
       gc.snpCount as snpCount,
       gc.geneCount as geneCount,
       gc.pseudoGeneCount as pseudoGeneCount,
       gc.codingGeneCount as codingGeneCount,
       gc.otherGeneCount as otherGeneCount,
       gc.ChipChipGeneCount as ChipChipGeneCount,
       gc.orthologCount as orthologCount,
       gc.goCount as goCount,    
       gc.tfbsCount as tfbsCount,
       gc.proteomicsCount as proteomicsCount,
       gc.estCount as estCount,
       gc.ecNumberCount as ecNumberCount,
       cast(nvl(dsc.Organellar_Has, 0) as NUMBER(1)) as isOrganellar,
       cast(nvl(dsc.HTSIsolate_Has, 0) as NUMBER(1)) as hasHTSIsolate,
       cast(nvl(dsc.Popset_Has, 0) as NUMBER(1)) as hasPopset,
       cast(nvl(dsc.Epitope_Has, 0) as NUMBER(1)) as hasEpitope,
       cast(nvl(dsc.Array_Has, 0) as NUMBER(1)) as hasArray,
       nvl(oc.hasCentromere, 0) as hasCentromere,
       nvl(sc.contig_num, 0) as contigCount,
       nvl(sc.supercont_num, 0) as supercontigCount,
       nvl(sc.chrom_num, 0) as chromosomeCount,
       nvl(cc.communityCount, 0) as communityCount,
       nvl(psc.popsetCount, 0) as popsetCount,
       nvl(pc.geneArrayCount, 0) as arrayGeneCount,
       nvl(pc.rnaSeqCount, 0) as rnaSeqCount,
       nvl(pc.rtPCRCount, 0) as rtPCRCount,
       nvl(ta.avg_transcript_length, 0) as avg_transcript_length
FROM   apidb.Organism o,
       sres.Taxon t,
       sres.TaxonName tn,
       DataSourceCount dsc,
       OrganismCentromere oc,
       SequenceCount sc,
       CommunityCount cc,
       GeneCount gc,
       popsetCount psc,
       profileCount pc,
       (select taxon_id, round(avg(length),1) as avg_transcript_length
        from TranscriptAttributes
        group by taxon_id) ta
WHERE t.taxon_id = tn.taxon_id
  AND tn.taxon_id = o.taxon_id
  AND tn.name_class = 'scientific name' 
  AND o.taxon_id = dsc.taxon_id (+)
  AND o.taxon_id = oc.taxon_id (+)
  AND o.taxon_id = sc.taxon_id (+)
  AND o.taxon_id = cc.taxon_id (+)
  AND o.taxon_id = gc.taxon_id (+)
  AND o.taxon_id = psc.taxon_id (+)
  AND o.taxon_id = pc.taxon_id (+)
  AND o.taxon_id = ta.taxon_id (+)
) oa,
  TaxonSpecies ts,
  sres.taxon t,
  sres.taxonname tn2
where oa.component_taxon_id = ts.taxon_id
and ts.species_taxon_id = t.taxon_id
and ts.species_taxon_id = tn2.taxon_id
and tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PdbSimilarity">
    <comment> Each record maps a gene to a PDB structure. Used by the model to find
         genes that have a PDB structure and to find the PDB structures for a
         given gene.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE PdbSimilarity&1 NOLOGGING AS
SELECT ta.source_id, eas.source_id AS pdb_chain,                                               
       substr(eas.description, 1, 100) AS pdb_title,                                          
       substr(eas.source_id, 1,                                                               
              instr(eas.source_id, '_', -1) - 1)                                              
         AS pdb_id,                                                                           
       s.pvalue_mant, s.pvalue_exp,                                                           
       SUBSTR(tn.name, 1, 100) AS taxon,                                                      
       ROUND( (s.number_identical / s.total_match_length) * 100)                              
         AS percent_identity,                                                                 
       ROUND( (s.total_match_length / ta.protein_length) * 100)                                      
         AS percent_plasmo_coverage,                                                          
       s.score, eas.taxon_id as pdb_taxon_id, ta.taxon_id as gene_taxon_id                   
FROM core.TableInfo tas_ti,                                    
     dots.Similarity s, 
     core.TableInfo eas_ti,                                                
     dots.ExternalAaSequence eas,                                                             
     sres.ExternalDatabaseRelease edr, 
     sres.ExternalDatabase ed,                              
     sres.TaxonName tn, 
     TranscriptAttributes ta
WHERE ta.aa_sequence_id = s.query_id
  AND tas_ti.name = 'TranslatedAASequence'                                                    
  AND tas_ti.table_id = s.query_table_id                                                      
  AND eas_ti.name = 'ExternalAASequence'                                                      
  AND eas_ti.table_id = s.subject_table_id                                                    
  AND s.subject_id = eas.aa_sequence_id                                                       
  AND tn.name_class = 'scientific name'                                                       
  AND eas.external_database_release_id                                                        
      = edr.external_database_release_id                                                      
  AND edr.external_database_id = ed.external_database_id                                      
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')                         
  AND eas.taxon_id = tn.taxon_id                                                              
ORDER BY ta.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PdbSim_sourceId_ix&1
ON PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneId" prefixEnabled="true">
  <comment>GeneId maps any valid ID for a gene onto its official ID. These two quantities
       are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
       column is set to 1 for IDs which map to only one gene.

       Most of the CREATE TABLE statement is made up of the union of nine subqueries,
       each of which looks in a different place for gene IDs. Each subquery populates
       the "union_member" field with a different literal string, to make it easier to
       understand which part (or parts) of the SQL is responsible for each ID-to-gene
       mapping.
   </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <intermediateTable name="OneGeneIds"/>
    <intermediateTable name="CommentAssignment"/>
    <intermediateTable name="NewCsi"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneId&1 NOLOGGING AS
SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (0 as NUMBER(1)) as unique_mapping,
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab)),'; '), 1, 100) as union_member, 
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab)),'; '), 1, 200) as database_name
/*   we would use listagg() as follows, but it repeats duplicate values, and doesn't provide a way to aggregate DISTINCT values. (lame!)
         substr(listagg(union_member, '; ') within group (order by union_member), 1, 100) as union_member,
         substr(listagg(database_name, '; ') within group (order by database_name), 1, 200) as database_name */
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name /* dots.Transcript.protein_id, trimmed at period */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name /* dots.Transcript.protein_id */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                                  AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
        AND NOT edr.id_type = 'synonym'
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier on Transcript' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = t.parent_id
        AND t.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                             AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'VectorBase alternate names' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        and ed.name in ('VB_Community_Annotation', 'VB_Community_Symbol') /* vectorbase alt names  */
     UNION
     SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'synonym' as union_member, ed.name as database_name
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND edr.id_type  = 'synonym'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name /* sres.DbRef.secondary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier for Genbank records */
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name /* dots.GeneFeature.source_id for predicted genes that overlap */
      FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS id, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name /* dots.NaGene.name */
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT source_id AS id, source_id AS gene,
             'same ID' as union_member, ed.name as database_name /* same ID (reflexive mapping) */
      FROM dots.GeneFeature gf,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT n.name AS id, gf.source_id AS gene,
             'gene name' as union_member, d.name as database_name -- apidb.GeneFeatureName.name
      from dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
           (  select na_feature_id, name
              from apidb.GeneFeatureName
              where is_preferred = 1
            minus
              -- suppress gene/name associations from the *DELETED_RSRC databases
              select gfn.na_feature_id, gfn.name
              from apidb.GeneFeatureName gfn,
                   sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
              where gfn.external_database_release_id = edr.external_database_release_id
                and ed.external_database_id = edr.external_database_id
                and ed.name like '%DELETED_RSRC'
           ) n
      where n.na_feature_id = gf.na_feature_id
        and gf.external_database_release_id = r.external_database_release_id
        and r.external_database_id = d.external_database_id
     UNION
      select dr.primary_identifier as id,
             gf.source_id as gene,
             'AA feature DbRef primary ID' as union_member,
             ed.name as database_name /* DbRef.primary_identifier mapped through DbRefAaFeature */
      from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
           dots.DbRefAaFeature draf,  sres.DbRef dr,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = t.parent_id
        and t.na_feature_id = taf.na_feature_id
        and taf.aa_feature_id = draf.aa_feature_id
        and draf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name
            not in ('INTERPRO', 'PFAM', 'PIRSF', 'PRODOM', 'PROSITEPROFILES',
                    'SMART', 'SUPERFAMILY', 'TIGRFAM', 'CDD','HAMAP','HMMPANTHER',
                    'PRINTS','SCANPROSITE','SFLD')
    ) mapping,
      dots.GeneFeature gf, dots.NaSequence ns
where mapping.gene = gf.source_id
  and gf.na_sequence_id = ns.na_sequence_id
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  and (gf.is_predicted != 1 OR gf.is_predicted is null)
group by mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
insert into &prefixGeneId&1
            (id, gene, unique_mapping, union_member, database_name)
with munge
     as (select distinct
                regexp_replace(id, '(*)\.\d\d?$', '') as id,
                gene, unique_mapping, union_member, database_name
         from &prefixGeneId&1
         where regexp_like(id, '(*)\.\d\d?$'))
select id, gene, 0 as unique_mapping, 'base ID' as union_member, database_name
from munge
where id not in (select id from &prefixGeneId&1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table &prefixOneGeneIds
              (lower_id,
               constraint ogix&1_pk primary key(lower_id))
        organization index nologging as
        select lower_id
        from (select distinct lower(id) as lower_id, gene
              from &prefixGeneId&1)
        group by lower_id
        having count(*) = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGeneId&1
        set unique_mapping = 1
        where id = gene
           or lower(id) in (select lower_id from &prefixOneGeneIds)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCommentAssignment NOLOGGING AS
WITH projects AS
       (SELECT DISTINCT project_id FROM &prefixGenomicSeqAttributes),
     project_comments AS
       (SELECT stable_id, comment_id
        FROM userlogins5.comments@&dblink
        WHERE project_name in (select project_id FROM projects)
          AND comment_target_id = 'gene')
  SELECT stable_id, comment_id
  FROM project_comments
UNION
  SELECT csi.stable_id, csi.comment_id
  FROM project_comments pc, userlogins5.commentStableId@&dblink csi
  WHERE csi.comment_id = pc.comment_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixNewCsi nologging as
SELECT stable_id, comment_id, userlogins5.CommentStableId_pkseq.nextval@&dblink as comment_stable_id
FROM (  SELECT gi.gene AS stable_id, ca.comment_id
        FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca
        WHERE gi.id = ca.stable_id
          AND gi.id != gi.gene
      MINUS
        SELECT stable_id, comment_id
        FROM &prefixCommentAssignment ca)
      ]]>
    </sql>
    <sql>
      <![CDATA[
INSERT INTO userlogins5.CommentStableId@&dblink
           (stable_id, comment_id, comment_stable_id)
SELECT stable_id, comment_id, comment_stable_id
FROM &prefixNewCsi
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceId">
  <comment> This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    </comment>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
FROM (
  SELECT ns.source_id as id, ns.source_id as sequence
  FROM dots.NaSequence ns, sres.OntologyTerm oterm
  WHERE ns.sequence_ontology_id = oterm.ontology_term_id
    AND oterm.name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome','maxicircle')
UNION
  SELECT dr.primary_identifier AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_sequence_idx&1 ON GenomicSequenceId&1 (sequence, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_id_idx&1 ON GenomicSequenceId&1 (id, sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_lowid_idx&1 ON GenomicSequenceId&1 (lower(id), sequence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <comment> Used by GeneTables.Epitopes to map a gene to its epitopes.
     </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EpitopeSummary&1 NOLOGGING AS
SELECT t.source_id, 
              al.start_min||'-'||al.end_max AS location,
              ef.source_id as iedb_id,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.Transcript t,
     dots.TranslatedAaFeature taf, 
     dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, 
     dots.EpitopeFeature ef,
     dots.AaLocation al, 
     sres.TaxonName tn
WHERE taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptCenDistance">
    <comment> Stores (transcript, sequence, distance from centromere) 3-tuples for transcripts
         that lie on a sequence for which we have a centomere location.
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE TranscriptCenDistance&1 NOLOGGING AS
        SELECT tl.feature_source_id AS transcript,
               LEAST(ABS(mfl.start_min - tl.end_max),
                     ABS(mfl.end_max - tl.start_min)) AS centromere_distance,
               tl.sequence_source_id AS genomic_sequence
        FROM apidb.TranscriptLocation tl, apidb.FeatureLocation mfl,
             sres.OntologyTerm so
        WHERE tl.na_sequence_id = mfl.na_sequence_id
          AND mfl.feature_type = 'Miscellaneous'
          AND mfl.sequence_ontology_id = so.ontology_term_id
          AND so.name = 'centromere'
          AND tl.is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GCent_loc_ix&1
       on TranscriptCenDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinAttributes" prefixEnabled="true">
    <comment>The BFMV for proteins. Each protein gets a single record, which
         stores all its attributes. Used mainly to create TranscriptAttributes
    </comment>
    <externalDependency name="apidb.CdsLocation"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="SignalPeptideDomains"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.EnzymeClass"/>
    <ancillaryTable name="GoTermList"/>
    <ancillaryTable name="ProteinGoAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGoTermList&1 NOLOGGING AS
SELECT aa_sequence_id, ontology, source,
             apidb.tab_to_string(set(cast(COLLECT(go_term_name order by go_term_name) as apidb.varchartab)), ';') AS go_terms,
             apidb.tab_to_string(set(cast(COLLECT(go_id order by go_term_name) as apidb.varchartab)), ';') AS go_ids
      FROM (SELECT aa_sequence_id, ontology, 
                        DECODE(evidence_code, 'IEA', 'predicted', 'annotated') AS source, go_term_name, go_id
                 FROM  &prefixGeneGoTerms
                 )
      GROUP BY aa_sequence_id, ontology, source
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinGoAttributes&1 NOLOGGING AS
SELECT DISTINCT gts.aa_sequence_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process,

       substr(annotated_go_component.go_ids, 1, 300) AS annotated_go_id_component,
       substr(annotated_go_function.go_ids, 1, 300) AS annotated_go_id_function,
       substr(annotated_go_process.go_ids, 1, 300) AS annotated_go_id_process,
       substr(predicted_go_component.go_ids, 1, 300) AS predicted_go_id_component,
       substr(predicted_go_function.go_ids, 1, 300) AS predicted_go_id_function,
       substr(predicted_go_process.go_ids, 1, 300) AS predicted_go_id_process
FROM (SELECT DISTINCT aa_sequence_id FROM &prefixGoTermSummary) gts,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'annotated' AND ontology = 'Cellular Component')
       annotated_go_component,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'annotated' AND ontology = 'Molecular Function')
       annotated_go_function,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'annotated' AND ontology = 'Biological Process')
       annotated_go_process,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'predicted' AND ontology = 'Cellular Component')
       predicted_go_component,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'predicted' AND ontology = 'Molecular Function')
       predicted_go_function,
     (SELECT * FROM &prefixGoTermList&1
      WHERE source = 'predicted' AND ontology = 'Biological Process')
       predicted_go_process
WHERE gts.aa_sequence_id = annotated_go_component.aa_sequence_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'Cellular Component' = annotated_go_component.ontology(+)
  AND gts.aa_sequence_id = annotated_go_function.aa_sequence_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'Molecular Function' = annotated_go_function.ontology(+)
  AND gts.aa_sequence_id = annotated_go_process.aa_sequence_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'Biological Process' = annotated_go_process.ontology(+)
  AND gts.aa_sequence_id = predicted_go_component.aa_sequence_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'Cellular Component' = predicted_go_component.ontology(+)
  AND gts.aa_sequence_id = predicted_go_function.aa_sequence_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'Molecular Function' = predicted_go_function.ontology(+)
  AND gts.aa_sequence_id = predicted_go_process.aa_sequence_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'Biological Process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProteinGoAttr_aaSequenceId&1 ON &prefixProteinGoAttributes&1 (aa_sequence_id)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinAttributes&1 NOLOGGING AS
SELECT pi.name as project_id,
             tas.source_id, tas.aa_sequence_id,
             t.source_id as transcript_source_id,
             gf.source_id as gene_source_id,
             cdsl.na_sequence_id as na_sequence_id,
             cdsl.is_reversed, 
             cdsl.start_min as cds_start,
             cdsl.end_max as cds_end,
             (taf.translation_stop - taf.translation_start) + 1 AS cds_length,
             tas.length AS protein_length, 
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             tas.molecular_weight,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.isoelectric_point, asa.hydropathicity_gravy_score,
             asa.aromaticity_score,             
             SUBSTR(sigp.peptide_sequence, 1, 200) as signalp_peptide,
             ec_numbers,
             ec_numbers_derived,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       go.annotated_go_id_component,
       go.annotated_go_id_function,
       go.annotated_go_id_process,
       go.predicted_go_id_component,
       go.predicted_go_id_function,
       go.predicted_go_id_process,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       0 AS has_seqedit,
       row_number() over (partition by t.source_id order by tas.length desc) as rank_in_transcript,
       uniprot.uniprot_ids
      FROM  dots.GeneFeature gf, dots.Transcript t, core.ProjectInfo pi,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT aa_sequence_id, listagg(peptide_sequence, ', ') peptide_sequence
             FROM (SELECT DISTINCT aa_sequence_id, peptide_sequence FROM SignalPeptideDomains)
             GROUP BY aa_sequence_id
            ) sigp,
            (SELECT protein_source_id, na_sequence_id, is_reversed,
                 MIN(start_min) AS start_min, MAX(end_max) AS end_max  
             FROM apidb.CdsLocation WHERE is_top_level=1
             GROUP BY protein_source_id, na_sequence_id, is_reversed)  cdsl, 
            &prefixProteinGoAttributes&1 go,
            dots.RnaType rt1, dots.RnaType rt2,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), ';'),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND NOT asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ec,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), ';'),
                           1, 300)
                      AS ec_numbers_derived
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ecDerived,
            (select af.aa_sequence_id,
                    listagg(dbref.primary_identifier,',')
                      within group(order by dbref.primary_identifier) as uniprot_ids
             from sres.ExternalDatabase d, sres.ExternalDatabaseRelease r,
                  sres.DbRef, dots.DbRefAaFeature daf, dots.AaFeature af
             where d.name like 'Uniprot%'
               and d.external_database_id = r.external_database_id
               and r.external_database_release_id = dbref.external_database_release_id
               and dbref.db_ref_id = daf.db_ref_id
               and daf.aa_feature_id = af.aa_feature_id
             group by af.aa_sequence_id) uniprot
      WHERE gf.na_feature_id = t.parent_id
        AND t.row_project_id = pi.project_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id (+)
        AND tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND cdsl.protein_source_id(+) =  tas.source_id
        AND t.na_feature_id = rt1.parent_id(+)
        AND gf.na_feature_id = rt2.parent_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)
        AND tas.aa_sequence_id = ecDerived.aa_sequence_id(+)
        AND tas.aa_sequence_id = go.aa_sequence_id(+)
        AND tas.aa_sequence_id = uniprot.aa_sequence_id(+)
      ORDER BY tas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixProteinAttributes&1 gaup
       set has_seqedit  = 1 
       where source_id in (select source_id from apidb.seqedit)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_sourceId&1 ON &prefixProteinAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_aaSequenceId&1 ON &prefixProteinAttributes&1 (aa_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="GeneId"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.IntronLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <internalDependency name="SnpAttributes"/>
    <internalDependency name="GeneLocations"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.UtrLocation"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <ancillaryTable name="TranscriptUniprot"/>
    <sql>
      <![CDATA[
      create table &prefixTranscriptUniprot&1 nologging as
      select na_feature_id,
             substr(listagg (uniprot_id, ',') within group (order by uniprot_id), 1, 240) as uniprot_id,
             substr(listagg (uniprot_id, '+or+') within group (order by uniprot_id), 1, 240) as uniprot_id_internal
      from (select distinct t.na_feature_id, dr.primary_identifier as uniprot_id
            from sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                 sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
            where dr.db_ref_id = x.DB_REF_ID
            and (x.na_feature_id = t.na_feature_id -- 
                 or x.na_feature_id = t.parent_id)
            and dr.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and (d.name like '%uniprot_dbxref_RSRC'
                 or d.name like '%dbxref_gene2Uniprot_RSRC'
                 or d.name = 'Links to Uniprot Genes'
                 or d.name like '%_dbxref_uniprot_linkout_RSRC'
                 or d.name like '%_dbxref_uniprot_from_annotation_RSRC')
           )
      group by na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptAttributes&1 NOLOGGING AS
SELECT DISTINCT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       t.source_id,
       -- first the gene attributes:
       gf.source_id AS gene_source_id, 
       gf.na_feature_id AS gene_na_feature_id,
       LEAST(nl.start_min, nl.end_max) AS gene_start_min,
       GREATEST(nl.start_min, nl.end_max) AS gene_end_max,
       COALESCE(preferred_name.name, any_name.name) AS gene_name,
       cast(coalesce(preferred_gene_product.product, any_gene_product.product,
                       gf.product,
                       preferred_tx_product.product, any_tx_product.product,
                       t.product,
                       case when t.is_pseudo = 1
                         then 'pseudogene'
                         else 'unspecified product'
                       end) as varchar2(300))
            as gene_product,
       REPLACE(so.name, '_', ' ') AS gene_type,
       gf.name as gene_ebi_biotype,
       gi.gene_id,
       transcripts.gene_transcript_count,
       exons.gene_exon_count,
       cast(null as varchar2(80)) as representative_transcript,
       olds.old_ids AS gene_previous_ids,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, 
       0 as gene_paralog_number, 0 as gene_ortholog_number,
       GREATEST(1, least(nl.start_min, nl.end_max) - 15000) AS gene_context_start,
       LEAST(gsa.length, greatest(nl.start_min, nl.end_max) + 15000) AS gene_context_end,
       GREATEST(1, least(nl.start_min, nl.end_max) - 1500) AS gene_zoom_context_start,
       LEAST(gsa.length, greatest(nl.start_min, nl.end_max) + 1500) AS gene_zoom_context_end,
       CAST(orthologs.name AS VARCHAR2(60)) AS orthomcl_name,
       nvl(tothtssnps.total_hts_snps,0) AS gene_total_hts_snps, 
       nvl(tothtssnps.hts_nonsynonymous_snps,0) AS gene_hts_nonsynonymous_snps,
       nvl(tothtssnps.hts_stop_codon_snps,0) AS gene_hts_stop_codon_snps,
       nvl(tothtssnps.hts_noncoding_snps,0) AS gene_hts_noncoding_snps, 
       nvl(tothtssnps.hts_synonymous_snps,0) AS gene_hts_synonymous_snps,
       nvl(tothtssnps.hts_nonsyn_syn_ratio,0) AS gene_hts_nonsyn_syn_ratio, 
       CAST(cmnt.comment_string AS VARCHAR2(300)) AS comment_string,
       transcript_uniprot.uniprot_id, transcript_uniprot.uniprot_id_internal,
       entrez_table.entrez_id AS gene_entrez_id,
       gloc.locations AS gene_locations,
       -- next the transcript attributes: 
       t.source_id AS transcript_source_id,
       tso.name as transcript_type,
       t.na_feature_id,
       cast(coalesce(preferred_tx_product.product, any_tx_product.product,
                       t.product,
                       preferred_gene_product.product, any_gene_product.product,
                       gf.product,
                       case when t.is_pseudo = 1
                         then 'pseudogene'
                         else 'unspecified product'
                       end) AS VARCHAR2(300))
            as transcript_product,
       tl.start_min, tl.end_max,
       tl.is_reversed,   --CHECK if needed
       DECODE(nvl(tl.is_reversed, 0), 0, 'forward', 1, 'reverse', tl.is_reversed) AS strand,
       DECODE(t.is_pseudo, null, 0, t.is_pseudo) as is_pseudo,
       transcript_exons.exon_count,
       sns.length AS length, sns.na_sequence_id as spliced_na_sequence_id,
       CAST(gsa.source_id AS VARCHAR2(50)) AS sequence_id,
       CAST(SUBSTR(tn.name, 1, 80) AS VARCHAR2(80)) AS organism,
       CAST(species_name.name AS VARCHAR2(60)) AS species,
       LTRIM(REGEXP_REPLACE(tn.name, replace (replace (species_name.name,'[',''), ']','') ,'')) AS strain,
       taxon.ncbi_tax_id,  tn.taxon_id, 
       so.source_id as so_id,
       CAST(so.name AS VARCHAR2(150)) AS so_term_name,
       CAST(SUBSTR(so.definition, 1, 150) AS VARCHAR2(150)) AS so_term_definition,
       CAST(soRls.version AS VARCHAR2(7)) AS so_version,
       CAST(NVL(rt1.anticodon, rt2.anticodon) AS VARCHAR2(3)) AS anticodon,
       ed.name AS external_db_name,
       edr.version AS external_db_version,
       edr.external_database_release_id AS external_db_rls_id,
       CAST(gsa.chromosome AS VARCHAR2(20)) AS chromosome,
       gsa.sequence_type,
       gsa.chromosome_order_num, gsa.na_sequence_id,
       --next the protein attributes: 
       pa.source_id AS protein_source_id,
       pa.aa_sequence_id,
       pa.cds_start as coding_start,
       pa.cds_end as coding_end,
       pa.cds_length, 
       pa.protein_length, 
       pa.has_seqedit,
       pa.tm_count,
       pa.molecular_weight,
       pa.isoelectric_point, 
       pa.signalp_peptide,
       pa.ec_numbers, pa.ec_numbers_derived,
       pa.annotated_go_component,
       pa.annotated_go_function,
       pa.annotated_go_process,
       pa.predicted_go_component,
       pa.predicted_go_function,
       pa.predicted_go_process,
       pa.annotated_go_id_component,
       pa.annotated_go_id_function,
       pa.annotated_go_id_process,
       pa.predicted_go_id_component,
       pa.predicted_go_id_function,
       pa.predicted_go_id_process,
       utr_lengths.five_prime_utr_length, 
       utr_lengths.three_prime_utr_length
FROM dots.GeneFeature gf, apidb.FeatureLocation nl, sres.OntologyTerm so,
     sres.externalDatabaseRelease soRls,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed, sres.OntologyTerm tso,
     &prefixGeneLocations gloc,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     &prefixTranscriptUniprot&1 transcript_uniprot,
     (SELECT rna_feature_id, count(*) as exon_count
      FROM dots.RnaFeatureExon 
      GROUP BY rna_feature_id) transcript_exons,
     &prefixGenomicSeqAttributes gsa,
     apidb.TranscriptLocation tl,
     dots.geneinstance gi, &prefixTaxonSpecies ts, sres.TaxonName species_name,
     (SELECT *
      FROM &prefixProteinAttributes
      WHERE rank_in_transcript = 1) pa,
     (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT parent_id, count(*) AS gene_transcript_count
      FROM dots.Transcript
      GROUP BY parent_id) transcripts,
     (SELECT parent_id, count(*) AS gene_exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct drnf.na_feature_id as gene_na_feature_id, 1 as is_deprecated
      from dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC') deprecated,
     ( select gene_source_id, total_hts_snps, hts_nonsynonymous_snps, hts_stop_codon_snps,hts_noncoding_snps,hts_synonymous_snps,
        case when (hts_nonsynonymous_snps is null) then 0
              when (hts_synonymous_snps = 0) then 0
                  else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio 
      from (
             select gene_source_id,
                    count(*) as total_hts_snps,
                    sum(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                    sum(has_stop_codon) as hts_stop_codon_snps,
                    sum(is_noncoding_snp) as hts_noncoding_snps,
                    count(*) - sum(has_nonsynonymous_allele) - sum(has_stop_codon) - sum(is_noncoding_snp)  as hts_synonymous_snps
             from &prefixSnpAttributes
             where  gene_source_id is not null
             group by gene_source_id 
      ) ) tothtssnps, 
     (  select ssg.sequence_id as gene_na_feature_id, sg.name
        from dots.SequenceSequenceGroup ssg, 
             dots.SequenceGroup sg, core.TableInfo ti
        where ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_tx_product,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      group by na_feature_id
     ) any_tx_product,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_gene_product,
     (select na_feature_id, max(product) as product
      from apidb.GeneFeatureProduct
      group by na_feature_id
     ) any_gene_product,
     (  select na_feature_id, max(name) as name
        from apidb.GeneFeatureName
        where is_preferred = 1
        group by na_feature_id
      minus
        -- suppress gene/name associations from the *DELETED_RSRC databases
        select gfn.na_feature_id, gfn.name
        from apidb.GeneFeatureName gfn,
             sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
        where gfn.external_database_release_id = edr.external_database_release_id
          and ed.external_database_id = edr.external_database_id
          and ed.name like '%DELETED_RSRC'
     ) preferred_name,
     (  select na_feature_id, max(name) as name
        from apidb.GeneFeatureName
        group by na_feature_id
      minus
        -- suppress gene/name associations from the *DELETED_RSRC databases
        select gfn.na_feature_id, gfn.name
        from apidb.GeneFeatureName gfn,
             sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
        where gfn.external_database_release_id = edr.external_database_release_id
          and ed.external_database_id = edr.external_database_id
          and ed.name like '%DELETED_RSRC'
     ) any_name,
     (select dbna.na_feature_id,
             substr(listagg (db.primary_identifier, ',' on overflow truncate) within group (order by db.primary_identifier), 1, 300) as entrez_id
      from sres.ExternalDatabaseRelease edr, sres.DbRef db,
           dots.DbRefNaFeature dbna, sres.ExternalDatabase ed
      where edr.external_database_release_id = db.external_database_release_id
        and ed.external_database_id = edr.external_database_id
        and dbna.db_ref_id = db.db_ref_id
        and lower(ed.name) like '%entrez%'
        group by dbna.na_feature_id
     ) entrez_table,
     (select drnf.na_feature_id,
                 substr(listagg(dr.primary_identifier, ';') within group (order by dr.primary_identifier), 1, 900) as old_ids
          from dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
          where dr.primary_identifier is not null
            and drnf.db_ref_id = dr.db_ref_id
            and dr.external_database_release_id = edr.external_database_release_id
            and edr.external_database_id = ed.external_database_id
            and edr.id_type = 'previous id'
          group by drnf.na_feature_id
     ) olds, 
    (select t.na_feature_id as transcript_na_feature_id, five_prime.utr_length as five_prime_utr_length, three_prime.utr_length as three_prime_utr_length
     from dots.transcript t
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from apidb.UtrLocation
       where direction = 5
         and is_top_level = 1
       group by parent_id
       ) five_prime
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from apidb.UtrLocation
       where direction = 3
         and is_top_level = 1
       group by parent_id
       ) three_prime
     where t.na_feature_id = five_prime.parent_id(+)
     and t.na_feature_id = three_prime.parent_id(+)
  ) utr_lengths
WHERE gf.source_id = gene.source_id
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.feature_type = 'GeneFeature' 
  AND nl.na_sequence_id = gsa.na_sequence_id
  AND (gsa.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND gf.sequence_ontology_id = so.ontology_term_id
  AND so.external_database_release_id = soRls.external_database_release_id
  AND gsa.taxon_id = taxon.taxon_id
  AND gsa.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND tn.taxon_id NOT IN
	 (SELECT o.taxon_id FROM apidb.Organism o WHERE  o.is_annotated_genome=0)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND tl.feature_source_id =  t.source_id
  AND tl. is_top_level=1
  AND t.na_feature_id = transcript_exons.rna_feature_id
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = transcripts.parent_id(+)
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.gene_na_feature_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.na_feature_id = deprecated.gene_na_feature_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.source_id = tothtssnps.gene_source_id(+)
  AND gsa.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  AND t.na_feature_id = preferred_tx_product.na_feature_id(+)
  AND t.na_feature_id = any_tx_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_gene_product.na_feature_id(+)
  AND gf.na_feature_id = any_gene_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
  AND (gf.is_predicted != 1 OR gf.is_predicted is null)
  AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
  AND t.na_feature_id = transcript_uniprot.na_feature_id(+)
  AND gf.na_feature_id = entrez_table.na_feature_id(+)
  AND gf.na_feature_id = olds.na_feature_id(+)
  AND t.source_id = pa.transcript_source_id(+)
  AND t.na_feature_id = utr_lengths.transcript_na_feature_id
  AND t.sequence_ontology_id = tso.ontology_term_id
  AND gf.source_id = gloc.source_id
ORDER BY tn.taxon_id, t.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_sourceId&1
          ON &prefixTranscriptAttributes&1 (source_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_srcPrj&1
        ON &prefixTranscriptAttributes&1 (source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genesrc&1
        ON &prefixTranscriptAttributes&1 (gene_source_id, source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_exon_ix&1
          ON &prefixTranscriptAttributes&1 (gene_exon_count, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_loc_ix&1
          ON &prefixTranscriptAttributes&1
               (na_sequence_id, gene_start_min, gene_end_max, is_reversed, na_feature_id,
                is_deprecated, source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_feat_ix&1
          ON &prefixTranscriptAttributes&1 (na_feature_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_geneid_ix&1
          ON &prefixTranscriptAttributes&1 (gene_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_orthoname_ix&1
          ON &prefixTranscriptAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type, organism, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_molwt_ix&1
          ON &prefixTranscriptAttributes&1 (taxon_id, molecular_weight, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>


    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_ortholog_ix&1
          ON &prefixTranscriptAttributes&1
             (source_id, na_sequence_id, gene_start_min, gene_end_max, orthomcl_name, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_orgsrc_ix&1
          ON &prefixTranscriptAttributes&1 (organism, source_id, sequence_id, gene_start_min, gene_end_max)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixTranscriptAttributes&1 ta
  set exon_count = (select count(*) + 1 from apidb.IntronLocation il where il.parent_id = ta.na_feature_id  and il.end_max - il.start_min + 1 > 10 )
  where ta.project_id = 'TriTrypDB' 
      ]]>
    </sql>


<!--

these updates are used for assigning non-coding genes to ortholog groups
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from &prefixTranscriptAttributes&1 gb
                     where gb.gene_id = ga.gene_id
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = 'NonCodingOrthoGroup_' || gene_id
        where orthomcl_name is null
        and gene_id is not null
        and gene_type not like 'protein%'
	and gene_type not like 'pseudo%'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = 'CodingOrthoGroup_' || gene_id
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>

    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = gene_source_id
        where orthomcl_name is null
      ]]>
    </sql>
-->

    <sql>
      <![CDATA[
       update &prefixTranscriptAttributes&1 gaup
       set gene_paralog_number = (select count(distinct gene_source_id)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.gene_source_id != g1.gene_source_id),
           gene_ortholog_number = (select count(distinct gene_source_id)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where (gaup.gene_type = 'protein coding' or gaup.gene_type = 'protein coding gene')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set gene_id = gene_na_feature_id + (select nvl(max(gene_id), 0) from dots.gene)
        where gene_id is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = (select min(source_id)
                                   from &prefixTranscriptAttributes&1 ga
                                   where ga.gene_source_id = &prefixTranscriptAttributes&1.gene_source_id)
        where representative_transcript is null
          and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = source_id
        where representative_transcript is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_lwrsrc_ix&1
          ON &prefixTranscriptAttributes&1 (lower(source_id), gene_source_id, project_id, source_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_species_ix&1
          ON &prefixTranscriptAttributes&1 (species, source_id, gene_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TrnscrptAttr_geneinfo&1
        ON &prefixTranscriptAttributes&1
           (gene_source_id, project_id, source_id, na_feature_id, spliced_na_sequence_id,
            protein_source_id, na_sequence_id, length, protein_length,
            five_prime_utr_length, three_prime_utr_length)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genenaf&1
        ON &prefixTranscriptAttributes&1 (gene_na_feature_id, gene_source_id, source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_locsIds_ix&1
          ON &prefixTranscriptAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, gene_source_id, source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneModelCharMD" prefixEnabled="true">
    <comment>
      Stores tuned data for the genemodelchar filter search
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneIntronJunction"/>
    <externalDependency name="apidb.LongReadTranscript"/>
    <sql>
    
     <![CDATA[
create table &prefixGeneModelCharMD&1
 (
  ontology_term_name,
  gene_source_id,
  source_id,
  taxon_id,
  string_value,
  number_value,
  CONSTRAINT &prefixGeneModelCharMD_pk&1 PRIMARY KEY
        (ontology_term_name, gene_source_id, source_id, taxon_id, string_value, number_value)
 )
organization index
nologging
as
select ontology_term_name, gene_source_id, source_id, taxon_id, nvl(string_value,'NA'), nvl(number_value,-1)
from (  select gene_source_id, source_id, taxon_id,
               'transcript_count' as ontology_term_name,
               null as string_value, gene_transcript_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'transcript_exon_count' as ontology_term_name, null as string_value,
               exon_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'gene_exon_count' as ontology_term_name, null as string_value,
               gene_exon_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'is_pseudo' as ontology_term_name, decode(is_pseudo,1,'Yes',0,'No') as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'is_deprecated' as ontology_term_name, decode(is_deprecated,1,'Yes',0,'No') as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'gene_type' as ontology_term_name, gene_type as string_value, null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'gene_type_ebi' as ontology_term_name, gene_ebi_biotype as string_value, null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'transcript_type' as ontology_term_name, transcript_type as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id,
               'organism' as ontology_term_name, organism as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id,
               'long_transcript_novelty' as ontology_term_name, ltr.transcript_novelty string_value,
               null as number_value
        from TranscriptAttributes atr
        , apidb.LongReadTranscript ltr
        where 
        ltr.gene_source_id = atr.gene_source_id
        
     UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id, 
        'intron_junction' as ontology_term_name, gj.annotated_intron string_value,
            null as number_value
        from 
        GeneIntronJunction gj
        ,TranscriptAttributes atr
        where gj.gene_source_id =  atr.gene_source_id
        
     UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id, 
        'Unique_reads' as ontology_term_name, null as string_value , gj.total_unique number_value           
        from 
        geneintronjunction gj
        ,TranscriptAttributes atr
        where gj.gene_source_id =  atr.gene_source_id
     )
      ]]>
   </sql>
  </tuningTable>


  <tuningTable name="GeneModelCharOrgMD" prefixEnabled="true">
    <comment>
      Stores tuned data for the genemodelchar filter search. Portal-specific version including taxon names.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneIntronJunction"/>
    <externalDependency name="apidb.LongReadTranscript"/>
    <sql>
      <![CDATA[
create table &prefixGeneModelCharOrgMD&1
 (
  ontology_term_name,
  gene_source_id,
  source_id,
  taxon_id,
  taxon_name,
  string_value,
  number_value,
  CONSTRAINT &prefixGeneModelCharOrgMD_pk&1 PRIMARY KEY
        (ontology_term_name, gene_source_id, source_id, taxon_id, taxon_name, string_value, number_value)
 )
organization index
nologging
as
select ontology_term_name, gene_source_id, source_id, taxon_id, cast(organism as varchar2(53)),
       cast(nvl(string_value,'NA') as varchar2(100)), nvl(number_value,-1)
       from (  select gene_source_id, source_id, taxon_id, organism,
               'transcript_count' as ontology_term_name,
               null as string_value, gene_transcript_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'transcript_exon_count' as ontology_term_name, null as string_value,
               exon_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'gene_exon_count' as ontology_term_name, null as string_value,
               gene_exon_count as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'is_pseudo' as ontology_term_name, decode(is_pseudo,1,'Yes',0,'No') as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'is_deprecated' as ontology_term_name, decode(is_deprecated,1,'Yes',0,'No') as string_value,
               null as number_value
        from TranscriptAttributes

      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'gene_type' as ontology_term_name, gene_type as string_value, null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'gene_type_ebi' as ontology_term_name, gene_ebi_biotype as string_value, null as number_value
        from TranscriptAttributes
     UNION
        select gene_source_id, source_id, taxon_id, organism,
               'transcript_type' as ontology_term_name, transcript_type as string_value,
               null as number_value
        from TranscriptAttributes
      UNION
        select gene_source_id, source_id, taxon_id, organism,
               'organism' as ontology_term_name, organism as string_value,
               null as number_value
        from TranscriptAttributes
        
    UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id, atr.organism,
               'long_lranscript_novelty' as ontology_term_name, ltr.transcript_novelty string_value,
               null as number_value
        from TranscriptAttributes atr
        ,apidb.longreadtranscript ltr
        where 
        ltr.gene_source_id = atr.gene_source_id
        
    UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id, atr.organism,
        'intron_junction' as ontology_term_name, gj.annotated_intron string_value,
            null as number_value
        from 
        GeneIntronJunction gj
        ,TranscriptAttributes atr
        where gj.gene_source_id =  atr.gene_source_id
        
     UNION
        select atr.gene_source_id, atr.source_id, atr.taxon_id, atr.organism,
        'unique_reads' as ontology_term_name, null as string_value , gj.total_unique number_value           
        from 
        GeneIntronJunction gj
        ,TranscriptAttributes atr
        where gj.gene_source_id =  atr.gene_source_id
     )
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IntronUtrCoords">
    <comment>
      Stores, for each transcript, a string containing the gene-relative coordinates
      of all its introns and UTRs.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <sql>
      <![CDATA[
      CREATE TABLE IntronUtrCoords&1 NOLOGGING AS
      SELECT na_feature_id, source_id,
            '[' || regexp_replace(rtrim(xmlagg(XMLELEMENT(e,text,',').EXTRACT('//text()') ORDER BY start_min).GetClobVal(),','), '.quot;', '"') || ']' AS gen_rel_intron_utr_coords
      FROM (SELECT na_feature_id, source_id, start_min,
                   '["' || feature_type || '",' || start_min || ',' || end_max || ']' AS text
            FROM (SELECT fl.feature_type, tl.na_feature_id, tl.feature_source_id AS source_id,
                   CASE
                     WHEN tl.is_reversed = 1
                     THEN tl.end_max - fl.end_max + 1
                     ELSE fl.start_min - tl.start_min + 1
                   END AS start_min,
                   CASE
                     WHEN tl.is_reversed = 1
                     THEN tl.end_max - fl.start_min + 1
                     ELSE fl.end_max - tl.start_min + 1
                   END AS end_max
                  FROM
                   apidb.TranscriptLocation tl, apidb.FeatureLocation fl
                  WHERE
                    tl.na_feature_id = fl.parent_id 
                    and fl.feature_type in('five_prime_UTR', 'three_prime_UTR', 'Intron')
                    and tl.is_top_level = 1
                    and fl.is_top_level = 1
                  )
           )
      GROUP BY
        na_feature_id, source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX iuc_srcid_ix&1
          ON IntronUtrCoords&1 (source_id, na_feature_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX iuc_nfid_ix&1
          ON IntronUtrCoords&1 (na_feature_id, source_id)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. 
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <ancillaryTable name="SpeciesInfo"/>
    <sql>
      <![CDATA[
	    CREATE TABLE &prefixGeneAttributes&1 NOLOGGING AS
	    SELECT DISTINCT project_id
	        , ta.gene_source_id AS source_id
		, gene_na_feature_id AS na_feature_id
		, na_sequence_id
		, is_reversed
		, gene_start_min AS start_min
		, gene_end_max AS end_max
                , decode(strand,'forward','+','reverse','-',null) as strand_plus_minus
		, sequence_id
		, gene_name AS name
		, nvl(aggregates.product, aggregates.transcript_product) as product
		, gene_type
                , gene_ebi_biotype
		, gene_id
		, aggregates.is_pseudo
		, organism
		, species
		, taxon_id
		, species as genus_species
                , strain
		, ncbi_tax_id
		, so_id
		, so_term_name
		, so_term_definition
		, so_version
		, anticodon
		, external_db_name
		, external_db_version
		, external_db_rls_id
		, chromosome
		, chromosome_order_num
		, sequence_type
		, gene_transcript_count AS transcript_count
		, gene_exon_count as exon_count
		, gene_previous_ids as previous_ids
		, is_deprecated
		, gene_paralog_number as paralog_number
		, gene_ortholog_number as ortholog_number
		, gene_context_start as context_start
		, gene_context_end as context_end
		, orthomcl_name
		, gene_total_hts_snps as total_hts_snps
		, gene_hts_nonsynonymous_snps as hts_nonsynonymous_snps
		, gene_hts_stop_codon_snps as hts_stop_codon_snps
		, gene_hts_noncoding_snps as hts_noncoding_snps
		, gene_hts_synonymous_snps as hts_synonymous_snps
		, gene_hts_nonsyn_syn_ratio as hts_nonsyn_syn_ratio
		, comment_string
		, uniprot.uniprot_id
		, uniprot.uniprot_id_internal
		, gene_entrez_id as entrez_id
		, representative_transcript
                , gene_zoom_context_start as zoom_context_start
                , gene_zoom_context_end as zoom_context_end
                , cast (null as number) as strain_count
                , ta.gene_locations as locations
            FROM &prefixTranscriptAttributes ta,
                 (SELECT gene_source_id, MIN(is_pseudo) AS is_pseudo, MIN(gene_product) AS product,
                         cast( substr(rtrim(xmlagg(xmlelement(e, transcript_product, ', ').extract('//text()') order by transcript_product).GetClobVal(), ', ') , 1, 240) as varchar2(80)) AS transcript_product
                  FROM &prefixTranscriptAttributes
                  GROUP BY gene_source_id) aggregates,
                 (select na_feature_id,
                         substr(listagg (uniprot_id, ',') within group (order by uniprot_id), 1, 240) as uniprot_id,
                         substr(listagg (uniprot_id, '+or+') within group (order by uniprot_id), 1, 240) as uniprot_id_internal
                  from (select distinct t.parent_id as na_feature_id, dr.primary_identifier as uniprot_id
                        from sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                             sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
                        where dr.db_ref_id = x.DB_REF_ID
                        and (x.na_feature_id = t.na_feature_id -- 
                             or x.na_feature_id = t.parent_id)
                        and dr.external_database_release_id = r.external_database_release_id
                        and r.external_database_id = d.external_database_id
                        and (d.name like '%uniprot_dbxref_RSRC'
                             or d.name like '%dbxref_gene2Uniprot_RSRC'
                             or d.name = 'Links to Uniprot Genes'
                             or d.name like '%_dbxref_uniprot_from_annotation_RSRC')
                       )
                  group by na_feature_id
                )  uniprot
            WHERE ta.gene_source_id = aggregates.gene_source_id
              AND ta.gene_na_feature_id = uniprot.na_feature_id(+)
            ORDER BY ta.gene_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table &prefixSpeciesInfo&1 nologging as
select genus_species, count(distinct organism) as strain_count
from &prefixGeneAttributes&1
group by genus_species
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixGeneAttributes&1 ga
set strain_count
    = (select strain_count
       from &prefixSpeciesInfo&1 si
       where si.genus_species = ga.genus_species)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index GeneAttr_srcPrj&1
       ON &prefixGeneAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_exon_ix&1
       ON &prefixGeneAttributes&1 (exon_count, source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_loc_ix&1
       ON &prefixGeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed, na_feature_id, is_deprecated)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_feat_ix&1
       ON &prefixGeneAttributes&1 (na_feature_id, na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orthoname_ix&1
       on &prefixGeneAttributes&1
          (orthomcl_name, source_id, taxon_id, gene_type, na_feature_id,
           na_sequence_id, start_min, end_max, organism, species,
           product, project_id)
       tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_ortholog_ix&1
       ON &prefixGeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orgsrc_ix&1
       ON &prefixGeneAttributes&1 (organism, source_id, na_sequence_id, start_min, end_max)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_prjsrc_ix&1
       ON &prefixGeneAttributes&1 (project_id, organism, source_id, NVL(IS_DEPRECATED,0))
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_txid_ix&1
       ON &prefixGeneAttributes&1 (taxon_id, source_id, gene_type, na_feature_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_ids_ix&1
       ON &prefixGeneAttributes&1 (na_feature_id, source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_loc_intjunc_ix&1
       ON &prefixGeneAttributes&1 (NA_SEQUENCE_ID, START_MIN, IS_REVERSED, END_MAX)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributes" prefixEnabled="true">
    <comment>Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables, Includes only NGS SNPs.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="apidb.Snp" noTrigger="true"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixSnpAttributes&1 NOLOGGING AS
WITH allele_total
     AS (SELECT ref_na_sequence_id, location, COUNT(*) AS allele_total
         FROM apidb.SequenceVariation
         GROUP BY ref_na_sequence_id, location),
     stop_codon_snps
     AS (SELECT DISTINCT ref_na_sequence_id, location, 1 as has_stop_codon
         FROM apidb.SequenceVariation
         WHERE product = '*')
SELECT chromosome_info.project_id,
       ed.name as dataset,
       sequence.na_sequence_id,
       sequence.source_id as seq_source_id,
       snp.location,
       snp.source_id,
       snp.reference_strain, 
       snp.reference_na, 
       snp.reference_aa, 
       decode(snp.reference_aa, null, 0, 1) as is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       -- has_nonsynonymous should be false if any products are stops
       case when stop_codon_snps.has_stop_codon is null
              then snp.has_nonsynonymous_allele
            else 0
       end as has_nonsynonymous_allele,
       snp.major_allele, 
       snp.minor_allele,
       snp.major_allele_count, 
       snp.minor_allele_count,
       round(snp.major_allele_count / allele_total.allele_total, 2) as major_allele_frequency,
       round(snp.minor_allele_count / allele_total.allele_total, 2) as minor_allele_frequency,
       snp.major_product, 
       snp.minor_product,
       snp.distinct_strain_count,
       snp.distinct_allele_count,
       nvl(stop_codon_snps.has_stop_codon, 0) AS has_stop_codon,
       case when snp.reference_aa is null then 1 else 0 end as is_noncoding_snp,
       fl.feature_source_id as gene_source_id,
       fl.na_feature_id as gene_na_feature_id,
       decode(fl.is_reversed,0,'forward',1,'reverse',null) as gene_strand,
       CAST(SUBSTR(sequence.sequence, snp.location - 30, 30) AS VARCHAR2(30)) AS lflank,
       CAST(SUBSTR(sequence.sequence, snp.location + 1, 30) AS VARCHAR2(30)) AS rflank,
       chromosome_info.organism as organism,
       chromosome_info.ncbi_tax_id,
       chromosome_info.chromosome,
       chromosome_info.chromosome_order_num
FROM apidb.Snp, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     dots.NaSequence sequence, stop_codon_snps,
     allele_total,
     (SELECT feature_source_id, is_reversed, na_feature_id
      FROM apidb.FeatureLocation
      WHERE is_top_level = 1 and feature_type = 'GeneFeature') fl,
     &prefixGenomicSeqAttributes chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.na_sequence_id = snp.na_sequence_id
  AND chromosome_info.na_sequence_id = snp.na_sequence_id
  AND fl.na_feature_id(+) = snp.gene_na_feature_id
  AND snp.na_sequence_id = allele_total.ref_na_sequence_id(+)
  AND snp.location = allele_total.location(+)
  AND snp.na_sequence_id = stop_codon_snps.ref_na_sequence_id(+)
  AND snp.location = stop_codon_snps.location(+)
ORDER BY edr.external_database_release_id, sequence.na_sequence_id, snp.location
      ]]>
    </sql>

    <sql>
      <![CDATA[
create unique index SnpAttr_source_id&1 ON &prefixSnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_nafeat_dataset_ix&1
       ON &prefixSnpAttributes&1 (dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Seq_ix&1
       ON &prefixSnpAttributes&1 (na_sequence_id, dataset, location)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Freq_ix&1
       ON &prefixSnpAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttr_ds_org_ix&1 on &prefixSnpAttributes&1 (dataset,organism)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpVariantIx&1 on &prefixSnpAttributes&1 (dataset, source_id, gene_source_id, location, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <comment> Each row represents one EST. Used widely in the model, and to make the
         tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAttributes&1 NOLOGGING AS
select
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       replace(l.dbest_name, '''', '-') as dbest_name,
       nvl(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
       nvl(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, replace(l.dbest_name, '''', '-') as library_dbest_name
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.OntologyTerm oterm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = oterm.ontology_term_id
  AND oterm.name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <comment> Each row represents a colocated EST alignment - gene pair. Used by the
         model, by generateGeneMetrics, and in the creation of the
         OrganismAttributes tuning table
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.gene_end_max)
         - greatest(ba.target_start, ga.gene_start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.gene_source_id AS gene
  FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
       TranscriptAttributes ga, GenomicSeqAttributes sequence,
       dots.NaSequence query_sequence, sres.OntologyTerm so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.gene_end_max) - greatest(ba.target_start, ga.gene_start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.ontology_term_id
    AND so.name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION /* define datatype for null column */
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( /* set of blat_alignment_ids not in in first leg of UNION */
    /* (because they overlap no genes) */
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.OntologyTerm so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM EstAlignmentNoGene
UNION
SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_libOverlap_ix&1
             ON EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_estSite_ix&1
             ON EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record. 
     </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpStrains&1 NOLOGGING AS
with seq_var_pan as (select pan.name as protocol_app_node_name
                          , pan.protocol_app_node_id
                          , d.name
                          , pan.external_database_release_id
                          , replace(pan.name, ' (Sequence Variation)', '') as strain
                          , tn.name as organism
                      from study.protocolappnode pan
                         , sres.externaldatabaserelease r
                         , sres.externaldatabase d
                         , apidb.organism o
                         , sres.taxonname tn
                      where pan.external_database_release_id = r.external_database_release_id
                      and r.external_database_id = d.external_database_id
                      and d.name like o.abbrev || '%'
                      and o.taxon_id = tn.taxon_id
                      and tn.name_class = 'scientific name'
                      and pan.name like '% (Sequence Variation)'), 
ref_pan as (select svp.*
             from seq_var_pan svp
                , apidb.organism o
             where svp.strain = o.public_abbrev),
o_pan as (select distinct svp.*
          from seq_var_pan svp
             , dots.nasequence s
          where svp.external_database_release_id = s.external_database_release_id)
select * from o_pan
union
select * from ref_pan
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpChipStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record.
     </comment>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpChipStrains&1 NOLOGGING AS
select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism, ds.subtype as platform
from study.study s
   , study.studylink sl
   , study.protocolappnode pan
   , apidb.datasource ds
   , SRES.EXTERNALDATABASE d
   , SRES.EXTERNALDATABASERELEASE r
   , sres.taxonname tn
   , results.seqvariation sv
where ds.type = 'isolates'
and ds.subtype != 'HTS_SNP'
and ds.name = d.name
and ds.version = r.version
and d.EXTERNAL_DATABASE_ID = r.EXTERNAL_DATABASE_ID
and r.EXTERNAL_DATABASE_RELEASE_ID = s.EXTERNAL_DATABASE_RELEASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and ds.taxon_id = tn.taxon_id
and tn.name_class = 'scientific name'
and pan.PROTOCOL_APP_NODE_ID = sv.PROTOCOL_APP_NODE_ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpChipStrains_ix&1 ON SnpChipStrains&1(strain,organism,platform)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PopsetAttributes">
    <comment> The BFMV for the WDK popset record. Widely used in the model for
         queries related to popsets.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.ProtocolAppNode"/>

    <sql>
      <![CDATA[
        create table PopsetAttributes&1 nologging as
        select ens.source_id, lower(ens.source_id) as lower_source_id,
               pi.name AS project_id, ens.na_sequence_id, pan.protocol_app_node_id,
               sr.segment_result_id, ens.taxon_id, tn.name as organism,
               pan.description, ens.external_database_release_id,
               ed.name as external_db_name, edr.version as external_db_version,
               isolation_source.value as isolation_source,
               cast (null as varchar2(40)) as curated_isolation_source,
               note.value as note,
               gene_name.value as gene_name,
               product.value as product,
               geographic_location.value as geographic_location,
               cast (null as varchar2(40)) as curated_geographic_location,
               lat_lon.latitude, lat_lon.longitude,
               lat_lon.value as lat_lon,
               pcr_primers.value as pcr_primers,
               host.value as host,
               host_tax_id.ncbi_tax_id as host_ncbi_tax_id,
               popset.value as popset,
               strain.value as strain,
               ens.length
        from dots.ExternalNaSequence ens, core.Projectinfo pi, results.SegmentResult sr,
             study.ProtocolAppNode pan, sres.TaxonName tn,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolation_source') isolation_source,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'note') note,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'gene') gene_name,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'product') product,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'country') geographic_location,
             (-- for decimal latitude and longitude with one-letter compass points
              --  (e.g. '12.96 S 38.46 W') parse out the latitude and longitude
              select c.protocol_app_node_id,
                     case
                       when regexp_replace(c.value, '[0-9.]* [NS] [0-9.]* [EW]', 'latitude direction longitude direction')
                            = 'latitude direction longitude direction'
                         then
                           to_number(substr(c.value, 1, instr(c.value, ' ') - 1))
                           * case substr(c.value, instr(c.value, ' ') + 1, 1)
                               when 'S' then -1
                               else 1
                             end
                       else null
                     end as latitude,
                     case
                       when regexp_replace(c.value, '[0-9.]* [NS] [0-9.]* [EW]', 'latitude direction longitude direction')
                            = 'latitude direction longitude direction'
                         then
                           to_number(substr(c.value, instr(c.value, ' ', 1, 2) + 1,
                                            instr(substr(c.value, instr(c.value, ' ', 1, 2) + 1, 99), ' ') - 1))
                           * case substr(c.value, -1, 1)
                               when 'W' then -1
                               else 1
                             end
                       else null
                     end as longitude,
                     c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'lat_lon') lat_lon,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'PCR_primers') pcr_primers,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host') host,
             (select c.protocol_app_node_id, min(t.ncbi_tax_id) as ncbi_tax_id
              from study.Characteristic c, sres.OntologyTerm ot,
                   sres.TaxonName tn, sres.Taxon t
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host'
                and c.value = tn.name
                and tn.taxon_id = t.taxon_id
              group by c.protocol_app_node_id) host_tax_id,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolate') popset,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'strain') strain
        where pi.project_id = ens.row_project_id
          and ens.na_sequence_id = sr.na_sequence_id
          and sr.protocol_app_node_id = pan.protocol_app_node_id
          and pan.name = ens.source_id
          and ens.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ens.taxon_id = tn.taxon_id(+)
          and tn.name_class = 'scientific name'
          and pan.protocol_app_node_id = isolation_source.protocol_app_node_id(+)
          and pan.protocol_app_node_id = note.protocol_app_node_id(+)
          and pan.protocol_app_node_id = gene_name.protocol_app_node_id(+)
          and pan.protocol_app_node_id = product.protocol_app_node_id(+)
          and pan.protocol_app_node_id = geographic_location.protocol_app_node_id(+)
          and pan.protocol_app_node_id = lat_lon.protocol_app_node_id(+)
          and pan.protocol_app_node_id = pcr_primers.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host_tax_id.protocol_app_node_id(+)
          and pan.protocol_app_node_id = popset.protocol_app_node_id(+)
          and pan.protocol_app_node_id = strain.protocol_app_node_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = geographic_location
            where geographic_location in (select name from sres.OntologyTerm ot)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.geographic_location
                                 and os.ontology_term_id = ot.ontology_term_id)
        where curated_geographic_location is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source = (select max(ot.name) from SRES.ONTOLOGYterm ot
                where ot.name = PopsetAttributes&1.isolation_source
                and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source =  (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.isolation_source
                                 and os.ontology_term_id = ot.ontology_term_id
                               and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
        where curated_isolation_source is null 
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1 a
        set (a.latitude, a.longitude) = (select g.lat, g.lng
                                from apidb.IsolateGPS g, sres.OntologyTerm ot
                               where a.curated_geographic_location = ot.name
                                 and ot.source_id = g.gazetteer_id )
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index PopsetAttr_sourceId_idx&1
        on PopsetAttributes&1 (source_id,PROJECT_ID)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PopsetAttr_org_idx&1
          on PopsetAttributes&1(organism, source_id)
          tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PopsetAttr_lwrsrc_idx&1
          on PopsetAttributes&1(lower_source_id, source_id, project_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="ChIPProtocolParams">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by GBrowse.
     </comment>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table ChIPProtocolParams&1 NOLOGGING AS
select pp.*, e.experiment_name from
(
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and p.name in ('ChIP chip Smoothed',
               'ChIP chip Peak Calls',
                /* legacy ones too */
                'NimbleScan_ChIP_Hakimi_called_peaks',
                'NimbleScan_ChIP_Hakimi',
                'NimbleGen_ChIP_Myler_Lmajor',
                'ChIP_chip_Einstein',
                'ChIP_chip_Einstein_called_peaks',
                'ChIP_chip_Einstein_ME1',
                'ChIP_chip_Einstein_ME1_Peak_Calls')
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
) pp, (
select replace(d.name, '_' || a.name || '_chipChipSample_RSRC', '') as experiment_name, a.analysis_id
from sres.ExternalDatabase d, rad.analysis a
where d.name like '%' || a.name ||'%_chipChipSample_RSRC') e
where pp.analysis_id = e.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chp_prtparam_idx&1 ON ChIPProtocolParams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="ChIPchipTranscript">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
         generateGeneMetrics. Also an input to OrganismAttributes.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
      create table ChIPchipTranscript&1 NOLOGGING AS
      select distinct ta.source_id, ta.gene_source_id, ta.project_id, sr.protocol_app_node_id,
      CASE 
        WHEN ta.is_reversed = 0 
        THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ta.is_reversed = 0 
            THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
          END > 0 
        THEN 
          CASE 
            WHEN ta.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ta.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
      sr.score1 as score
from  TranscriptAttributes ta,
      Results.segmentresult sr,
      Study.StudyLink sl, 
      Study.Study s
where   sr.na_sequence_id = ta.na_sequence_id
  and   s.study_id = sl.study_id
  and   sl.protocol_app_node_id = sr.protocol_app_node_id
  and   lower(s.name) like '%chip%peaks'
  and   ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                  or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipTranscript&1 (protocol_app_node_id, source_id, gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChipSeqTranscript">
    <comment> Used by the GenesByChipSeq query
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="InferredParams"/>
    <internalDependency name="DefaultChars"/>
    <externalDependency name="results.SegmentResult"/>
    <sql>
      <![CDATA[
      create table ChipSeqTranscript&1 NOLOGGING AS
      select distinct ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
      CASE 
        WHEN ta.is_reversed = 0 
        THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ta.is_reversed = 0 
            THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
          END > 0 
        THEN 
          CASE 
            WHEN ta.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ta.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
      sr.score1 as score
from  TranscriptAttributes ta,
      results.SegmentResult sr
where sr.na_sequence_id = ta.na_sequence_id
  and sr.protocol_app_node_id
          in (      select protocol_app_node_id from DefaultChars where dataset_subtype = 'chipseq'
              union select protocol_app_node_id from InferredParams where dataset_subtype = 'chipseq'
              union select protocol_app_node_id from InferredChars where dataset_subtype = 'chipseq')
  and ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                  or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpsq_id_idx&1 ON ChipSeqTranscript&1 (protocol_app_node_id, source_id, gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TFBSGene">
    <comment> Used by gene queries, as well as by generateGeneMetrics. Also an input
         to OrganismAttributes.
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.BindingSiteFeature"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table TFBSGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.organism as organism,
      ga.genus_species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
        aef.*
from  dots.BindingSiteFeature aef,
      apidb.FeatureLocation arrloc,
      GeneAttributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index geneid_tfbs_idx&1 ON TFBSGene&1 (tfbs_na_feature_id,gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Subcellular">
    <comment> Each record maps a gene onto a subcellular location. Used by
         GenesBySubcellularLocalization.
     </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
CREATE TABLE Subcellular&1 NOLOGGING AS
select distinct gi.gene as source_id, targetting_domain
from (
select paf.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
) sc, GeneId gi
where gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index subc_ix&1 ON Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SimilaritySpanLocation">
    <comment> Like dots.SimilaritySpan, except that for sequences that are mapped by
         SequencePiece into parts of other sequences, both locations are stored.
         Used by GBrowse, and also in the creation of the Blastx tuning table.
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
create table SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.start_position <= sim.min_query_start
  and sp.end_position >= sim.max_query_end
  and sim.query_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
        on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTS">
    <comment>
         SNP Chip only, such as Plasmo barcode, 3k_chp and hd_array

         Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpAttributesDoTS&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       ed.name AS dataset,
       snp.name as type,
       ds.subtype as platform,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       snp.is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       SUBSTR(snp.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(snp.minor_product, 1, 40) AS minor_product,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min - 30, 30)) AS lflank,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min + 1, 30)) AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, sres.ontologyterm so, apidb.FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence, apidb.datasource ds,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND ed.name = ds.name
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  AND gene_info.na_feature_id(+) = snp.parent_id
  AND snp.sequence_ontology_id = so.ontology_term_id
  AND so.name != 'indel'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SnpAttrDots_source_id&1 ON SnpAttributesDoTS&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDots_nafeat_dataset_ix&1
       ON SnpAttributesDoTS&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Seq_ix&1
       ON SnpAttributesDoTS&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Freq_ix&1
       ON SnpAttributesDoTS&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttrdots_ds_org_ix&1 on snpattributesdots&1 (dataset,organism,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDotsVariantIx&1 on SnpAttributesDoTS&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTSPostprocess">
    <comment>
        this otherwise-unneeded tuning table, which depends on SnpAttributesDoTS,
        exists so that the view SnpChipAttributes can be created as a side-effect
     </comment>
    <internalDependency name="SnpAttributesDoTS"/>
    <sql>
      <![CDATA[
        create table SnpAttributesDoTSPostprocess&1 as select * from dual
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create or replace view SnpChipAttributes as
        select * from SnpAttributesDots
        where platform in ('Broad_3k_array', 'Broad_75K_array',
                           'NIH_10k', 'Broad_barcode')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        grant select on SnpChipAttributes to gus_r
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastp">
    <comment> Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <sql>
      <![CDATA[
create table Blastp&1 nologging as
select rownum as blastp_id, ga.source_id, ga.gene_source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, /* TaxonSpecies st, */
     sres.TaxonName tn, TranscriptAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.na_feature_id = t.na_feature_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and ga.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id =
/*    st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out */
                     tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update Blastp&1
set pvalue_exp = (select min(pvalue_exp) from Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_src_ix&1 on Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_query_ix&1 on Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_text_ix&1 on Blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Blastp_pvalfunc_ix&1
             on Blastp&1 
                (pvalue_exp, gene_source_id,
                 replace (external_database_name,'_RSRC',''))
             tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenePopsetOverlap">
    <comment> Each record stores a colocated (gene, popset) 2-tuple. Used by the
         gene page as well as the PopsetByOverlap query.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table GenePopsetOverlap&1 nologging as
select substr(ia.source_id, 1, 30) as popset_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from PopsetAttributes ia, dots.Similarity sim, apidb.FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_i_ix&1 on GenePopsetOverlap&1 (popset_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_g_ix&1 on GenePopsetOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <comment>Each record maps a taxon_id of interest onto the taxon_id of that taxon's
         taxon-tree ancestor whose rank is "species". Used by
         gene queries, and as an input in the
         creation of several tuning tables, including GeneAttributes
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="TaxonOfInterest"/>
    <sql>
      <![CDATA[
        create table &prefixTaxonOfInterest nologging as
          select taxon_id
          from &prefixGenomicSeqAttributes
        union
          select ns.taxon_id
          from dots.NaSequence ns, dots.Est
          where est.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
  create table &prefixTaxonSpecies&1 nologging as
  -- recursively walk taxon tree to find ancestor with rank "species"
  select taxon_id, ancestor_taxon_id as species_taxon_id
  from (
          select connect_by_root taxon_id as taxon_id,
                 taxon_id as ancestor_taxon_id, rank
          from sres.Taxon
          start with taxon_id
                     in (select taxon_id from &prefixTaxonOfInterest)
          connect by taxon_id = prior parent_id
                     and prior rank != 'species'
       )
  where rank = 'species'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastx">
    <comment> Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     </comment>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table Blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptSequence" prefixEnabled="true">
    <comment> Each record stores the transcript sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptSequence&1 NOLOGGING AS
SELECT ta.source_id, ta.project_id, sns.sequence
FROM &prefixTranscriptAttributes ta, dots.SplicedNaSequence sns
WHERE ta.source_id = sns.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index XScriptSeq_ix&1 on &prefixTranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE CodingSequence&1 NOLOGGING AS
SELECT ta.source_id, ta.project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM TranscriptAttributes ta, dots.SplicedNaSequence sns, dots.TranslatedAaFeature tf
WHERE ta.source_id = sns.source_id
 AND ta.na_feature_id = tf.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool, as well as by
         buildTrackOldAnnotationTT. Propagated to the portal.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <internalDependency name="ProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE ProteinSequence&1 NOLOGGING AS
WITH pAttr AS (
   SELECT distinct source_id, aa_sequence_id
   FROM ProteinAttributes)
SELECT pa.source_id, pi.name AS project_id, tas.sequence
FROM pAttr pa, dots.TranslatedAaSequence tas, core.Projectinfo pi
WHERE pa.aa_sequence_id = tas.aa_sequence_id
  AND pi.project_id = tas.row_project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceSequence">
    <comment> Each record stores the nucleotide sequence for one genomic sequence
         that is "official" (in the sense that it can be instantiated as a WDK
         sequence record. Used by generatePathoLogicFile and the sequence
         retrieval tool Propagated to portal instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM GenomicSeqAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GenomicSeq_ix&1 on GenomicSequenceSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <comment> Each record stores the nucleotide sequence of an EST, for use by the
         relevant attribute query in the WDK EST record. Propagated to portal
         instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.OntologyTerm oterm, sres.TaxonName tn
WHERE oterm.name = 'EST'
  AND oterm.ontology_term_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="NameMappingGIJ">
    <comment>
      Mapping table of experiment and sample names to junction protocol_app_node_id
    </comment>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
<!--     <internalDependency name="DatasetPresenter"/> --><!-- uncomment on master after release -->
    <internalDependency name="PANIO"/>
    <intermediateTable name="JunExpGIJtmp"/>
    <intermediateTable name="MappingStatsGIJtmp"/>

    <sql>
      <![CDATA[
CREATE TABLE JunExpGIJtmp  NOLOGGING as
select ij.junctions_pan_id, 
max(ij.expression_pan_id) keep (dense_rank first order by ij.avg_value desc) as exp_pan_id, 
max(ij.sample_name) keep (dense_rank first order by ij.avg_value desc) as sample_name, 
CASE WHEN max(ij.exp_name) keep (dense_rank first order by ij.avg_value desc) like '%secondstrand%' THEN 'true' ELSE 'false' END as switch_strands,
stats.multiplier
from (
select pj.output_pan_id as junctions_pan_id, p.output_pan_id as expression_pan_id, avg(nafe.value) as avg_value,pan.name as exp_name,
regexp_replace(pan.name, ' \[htseq-union.*', '') as sample_name 
from panio p, panio pj, results.nafeatureexpression nafe, study.protocolappnode pan
where pj.output_pan_id in (select distinct protocol_app_node_id from apidb.intronjunction)
and pj.input_pan_id = p.input_pan_id
and p.output_pan_id = pan.protocol_app_node_id
and pan.name like '%tpm - unique%'
and p.output_pan_id = nafe.protocol_app_node_id
group by pj.output_pan_id, p.output_pan_id, pan.name
order by pj.output_pan_id
) ij, (select protocol_app_node_id, 'total' as type, count(*) as total_junctions,
              sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
       from apidb.IntronJunction
       where unique_reads >= 1
       group by protocol_app_node_id) stats
where ij.junctions_pan_id = stats.protocol_app_node_id
group by ij.junctions_pan_id, stats.multiplier
order by junctions_pan_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index junexpgijtmp_ix on JunExpGIJtmp(junctions_pan_id,exp_pan_id) tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
create table MappingStatsGIJtmp (
    junctions_pan_id,
    read_length,
    mapped_reads,
    avg_mapping_coverage,
    num_replicates,
    CONSTRAINT mpstats_pk_ix&1 PRIMARY KEY (junctions_pan_id,read_length,mapped_reads,avg_mapping_coverage,num_replicates) 
)
  ORGANIZATION index
  nologging
  as
   select junctions_pan_id, round(avg(average_read_length - 2),1) as read_length,
              round(avg(number_mapped_reads),1) as mapped_reads,
              round(avg(avg_mapping_coverage) * ((avg(average_read_length) - 2) / avg(average_read_length)),2)
                as avg_mapping_coverage,
              count(*) as num_replicates
       from (select je.junctions_pan_id, to_number(ca.value) as average_read_length,
                    to_number(cb.value) as number_mapped_reads,
                    to_number(cc.value) as avg_mapping_coverage
             from junexpgijtmp je, STUDY.CHARACTERISTIC ca, sres.ontologyterm ota,
                  PANIO ioa, STUDY.CHARACTERISTIC cb, sres.ontologyterm otb,
                  STUDY.CHARACTERISTIC cc, sres.ontologyterm otc
             where je.junctions_pan_id = ioa.output_pan_id
               and ioa.input_pan_id = ca.protocol_app_node_id
               and ca.value is not null
               and ca.QUALIFIER_ID = ota.ONTOLOGY_TERM_ID
               AND ota.source_id IN ('EuPathUserDefined_00504','EuPathUserDefined_00508','EuPathUserDefined_00512'
                                    ,'EuPathUserDefined_00516','EuPathUserDefined_00520','EuPathUserDefined_00524'
                                    ,'EuPathUserDefined_00528') --  '%average read length'
               and ca.protocol_app_node_id = cb.protocol_app_node_id
               and cb.value is not null
               and cb.QUALIFIER_ID = otb.ONTOLOGY_TERM_ID
               AND otb.source_id IN ('EuPathUserDefined_00503','EuPathUserDefined_00507','EuPathUserDefined_00511'
                                    ,'EuPathUserDefined_00515','EuPathUserDefined_00519','EuPathUserDefined_00523'
                                    ,'EuPathUserDefined_00527') -- '%number mapped reads'
               and ca.protocol_app_node_id = cc.protocol_app_node_id
               and cc.value is not null
               and cc.QUALIFIER_ID = otc.ONTOLOGY_TERM_ID
               AND otc.source_id IN ('EuPathUserDefined_00501','EuPathUserDefined_00505','EuPathUserDefined_00509'
                                    ,'EuPathUserDefined_00513','EuPathUserDefined_00517','EuPathUserDefined_00521'
                                    ,'EuPathUserDefined_00525') -- '%average mapping coverage'
               )
       group by Junctions_Pan_Id
      ]]>
    </sql>
    
    <sql>
      <![CDATA[
create table NameMappingGIJ&1 NOLOGGING AS
select distinct edp.dataset_presenter_display_name as exp_name,
                edp.external_database_name, je.sample_name,
                je.junctions_pan_id, je.exp_pan_id,
                to_char(substr(dp.value, 1, 4000)) as presenter_switch_strands,
                to_char(substr(sj.value, 1, 4000)) as show_intron_junctions,
                to_char(substr(uj.value, 1, 4000)) as include_unified_junctions,
                ms.read_length, ms.mapped_reads, ms.avg_mapping_coverage, ms.num_replicates,
                je.switch_strands, je.multiplier
from junexpgijtmp je, study.StudyLink sl, study.Study s, ExternalDbDatasetPresenter edp,
     DatasetProperty dp, DatasetProperty sj, DatasetProperty uj, mappingstatsgijtmp ms
where sl.protocol_app_node_id = je.junctions_pan_id
  and je.junctions_pan_id = ms.junctions_pan_id
  and s.study_id = sl.study_id
  and s.name like '%[junctions]'
  and s.external_database_release_id = edp.external_database_release_id
  and dp.dataset_presenter_id = edp.dataset_presenter_id
  and dp.property = 'switchStrandsProfiles'
  and sj.dataset_presenter_id = edp.dataset_presenter_id
  and sj.property = 'showIntronJunctions'
  and uj.dataset_presenter_id = edp.dataset_presenter_id
  and uj.property = 'includeInUnifiedJunctions'
  and (to_char(substr(sj.value, 1, 10)) = 'true' or to_char(substr(uj.value, 1, 10)) = 'true')
      ]]>
    </sql>

    <sql>
      <![CDATA[
               create index namemappinggij_ix&1 on NameMappingGIJ&1(junctions_pan_id,exp_pan_id) tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneIntronJunction">
    <comment>
      Table collects up single row / intronjunction (identified as all junctions with same start, end and strand).  Statistics are generated including percentages of max intron score and ratios vs expression on an overall level.  
    </comment>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <internalDependency name="NameMappingGIJ"/>
    <ancillaryTable name="GeneIdLocGIJ"/>
    <intermediateTable name="PanIOgij"/>
    <intermediateTable name="annotgij"/>
    <intermediateTable name="GIJtmp"/>

    <!-- some remedial tables -->
    <!-- PanIO:  can just generate minimal one with: -->
    <sql>
      <![CDATA[
               create table PanIOgij as
               select i.protocol_app_id, i.protocol_app_node_id as input_pan_id, o.protocol_app_node_id as output_pan_id 
               from study.output o, study.input i
               where o.protocol_app_node_id in (select distinct protocol_app_node_id
               from study.protocolappnode where name like '%junctions%' or name like '%htseq%')
               and o.protocol_app_id = i.protocol_app_id
      ]]>
    </sql>
               
<!-- table with single row per annotated intron -->
    <sql>
      <![CDATA[
create table annotgij (
    na_sequence_id,
    start_min,
    end_max,
    is_reversed,
    feature_type,
    CONSTRAINT annottmpnew_pk_ix PRIMARY KEY (na_sequence_id,start_min,end_max,is_reversed,feature_type) 
)
  ORGANIZATION index
  nologging
  as
   select il.na_sequence_id, il.start_min,il.end_max, il.is_reversed, 'Intron' as feature_type
   from  apidb.IntronLocation il
   group by il.na_sequence_id, il.start_min,il.end_max,il.is_reversed
      ]]>
    </sql>
<!-- table mapping gene source ids to their location including strand information -->
    <sql>
      <![CDATA[
create table GeneIdLocGIJ&1 (
    na_sequence_id      number(10),
    start_min           number,
    is_reversed         number,
    end_max             number,
    na_feature_id       number(10),
    source_id           varchar2(100),
    total_expression    number,
    CONSTRAINT gnattidloc_pk_ix&1 PRIMARY KEY (na_sequence_id,start_min,is_reversed,end_max,na_feature_id,source_id,total_expression) 
)
ORGANIZATION index
      ]]>
    </sql>
    <sql>
      <![CDATA[
 BEGIN
  FOR idlist IN (
    select distinct na_sequence_id from apidb.intronjunction
 )
 LOOP
  insert into GeneIdLocGIJ&1 nologging (
  select gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id,
    round(sum(nafe.value),2) as total_expression
   from  dots.genefeature gf, dots.nalocation l, namemappinggij je, results.nafeatureexpression nafe
   where gf.na_sequence_id = idlist.na_sequence_id
   and l.na_feature_id = gf.na_feature_id
   and gf.na_feature_id = nafe.na_feature_id
   and nafe.protocol_app_node_id = je.exp_pan_id
   group by gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id
  );
    commit;
   END LOOP;
END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index gnidloc_nafid_ix&1 on GeneIdLocGIJ&1 (na_feature_id) tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create table GIJtmp (
               NA_SEQUENCE_ID               NUMBER(10),    
               SEQUENCE_SOURCE_ID           VARCHAR2(100),    
               SEGMENT_START                NUMBER,    
               SEGMENT_END                  NUMBER,    
               TOTAL_UNIQUE                 NUMBER,        
               TOTAL_ISRPM                  NUMBER,        
               IS_REVERSED                  NUMBER(1),     
               INTRON_FEATURE_ID            VARCHAR2(200), 
               MATCHES_GENE_STRAND          NUMBER,        
               GENE_SOURCE_ID               VARCHAR2(100),  
               GENE_NA_FEATURE_ID           NUMBER,        
               ANNOTATED_INTRON             VARCHAR2(10)
               )
      ]]>
    </sql>
<!-- should add is_contained to this table ... although if gene_source_id is not null then is_contained = 1 -->
    <sql>
      <![CDATA[
declare
  iter_length number := 4999;
  i_first_pos number := 1;
  i_last_pos number := i_first_pos + iter_length;
 BEGIN
  FOR idlist IN (
    select na_sequence_id, length, taxon_id, CASE WHEN step_mult > 500000 THEN 500000 ELSE step_mult END as seq_step_mult from (
    select gs.na_sequence_id, gs.length, gs.taxon_id, 25000 * (1 + floor(gs.length/count(*))) as step_mult 
      from apidb.intronjunction ij,  dots.nasequence gs
      where gs.na_sequence_id = ij.na_sequence_id 
      group by gs.na_sequence_id, gs.length, gs.taxon_id
      ) order by taxon_id
    )
 LOOP
  iter_length := idlist.seq_step_mult;
  i_first_pos := 1;
  i_last_pos := i_first_pos + iter_length;
  WHILE i_first_pos < idlist.length
  LOOP
  insert into GIJtmp nologging (
    select junc.*,
              CASE
                WHEN max(ga.is_reversed) keep (dense_rank first order by ga.total_expression desc) = junc.is_reversed 
                  THEN 1
                  ELSE 0
              END as matches_gene_strand,
              CASE
                WHEN max(ga.source_id) is not null
                  THEN max(ga.source_id) keep (dense_rank first order by ga.total_expression desc)
                  ELSE null
              END as gene_source_id, 
              CASE
                WHEN max(ga.na_feature_id) is not null
                  THEN max(ga.na_feature_id) keep (dense_rank first order by ga.total_expression desc)
                  ELSE null
              END as gene_na_feature_id, 
              decode(ag.feature_type,'Intron','Yes','No') as annotated_intron
from (
select ij.na_sequence_id,seq.source_id as sequence_source_id,ij.segment_start,ij.segment_end, 
sum(ij.unique_reads) as total_unique, round(sum(ij.unique_reads * je.multiplier),2) as total_isrpm,
ij.is_reversed,seq.source_id || '_' || ij.segment_start || '_' || ij.segment_end || '_' || ij.is_reversed as intron_feature_id
from apidb.intronjunction ij, namemappinggij je, dots.nasequence seq
where ij.na_sequence_id = idlist.na_sequence_id
and ij.segment_start between i_first_pos and i_last_pos
and ij.na_sequence_id = seq.na_sequence_id
and ij.unique_reads >= 1
and je.junctions_pan_id = ij.protocol_app_node_id
and je.multiplier < 20
group by ij.na_sequence_id,ij.segment_start,ij.segment_end, ij.is_reversed,seq.source_id
) junc, GeneIdLocGIJ&1 ga, annotgij ag
where junc.na_sequence_id = ga.na_sequence_id(+)  
         and junc.segment_start >= ga.start_min(+)
         and junc.segment_end <= ga.end_max(+)
         and junc.is_reversed = ga.is_reversed(+)
         and junc.na_sequence_id = ag.na_sequence_id(+)
         and junc.segment_start = ag.start_min(+)
         and junc.segment_end = ag.end_max(+)
         and junc.is_reversed = ag.is_reversed(+)         
group by junc.na_sequence_id,junc.sequence_source_id,junc.segment_start,junc.segment_end, junc.is_reversed, junc.intron_feature_id,junc.total_unique, junc.total_isrpm,ag.feature_type
having (junc.total_unique >= 1 or ag.feature_type = 'Intron')
  );
    commit;
    i_first_pos := i_last_pos + 1;
    i_last_pos := i_first_pos + iter_length;
    END LOOP;
   END LOOP;
END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index gijtmp_gnscid_ix on gijtmp (gene_source_id) tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create table GeneIntronJunction&1 NOLOGGING as
select junc.*, CASE WHEN maxv.gene_source_id is not null and maxv.max_isrpm > 0 THEN round((junc.total_isrpm / maxv.max_isrpm) * 100,2) ELSE null END as percent_max,
CASE WHEN maxv.gene_source_id is not null THEN 1 ELSE 0 END as contained,
cast (null as number(10)) as taxon_id
from ( 
select gene_source_id,max(total_unique) as max_unique, max(total_isrpm) as max_isrpm
from gijtmp
where gene_source_id is not null
group by gene_source_id) maxv, gijtmp junc
where junc.gene_source_id = maxv.gene_source_id(+) 
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update GeneIntronJunction&1 gij
        set taxon_id
            = (select taxon_id
               from dots.NaSequence
               where na_sequence_id = gij.na_sequence_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index gijnew_loc_ix&1 on GeneIntronJunction&1 (na_sequence_id,segment_start,segment_end,is_reversed) tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index gijnew_gnscid_ix&1 on GeneIntronJunction&1 (intron_feature_id) tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index gijnew_txnloc_ix&1
                 on GeneIntronJunction&1
                    (taxon_id, na_sequence_id, segment_start, segment_end, is_reversed,
                     total_unique, total_isrpm, annotated_intron) tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneIntJuncStats">
    <comment> Stores statistics for annotated introns used for configuring JBrowse tracks based on organism.
     </comment>
    <internalDependency name="GeneIntronJunction"/>
    <sql>
      <![CDATA[
create table GeneIntJuncStats&1 nologging as
with org_tot as (
select gs.organism, 
min(gij.total_unique) as min_annot_score, PERCENTILE_cont(0.005) within group (order by gij.total_unique asc) as perc005_annot_score, 
PERCENTILE_cont(0.01) within group (order by gij.total_unique asc) as perc01_annot_score,
min(gij.percent_max) as min_annot_percent_max, PERCENTILE_cont(0.0001) within group (order by gij.percent_max asc) as perc0001_annot_percent_max,
PERCENTILE_cont(0.0005) within group (order by gij.percent_max asc) as perc0005_annot_percent_max,
floor(max(gij.segment_end - gij.segment_start) * 1.25) as max_intron_length
from geneintronjunction gij, genomicseqattributes gs
where gs.na_sequence_id = gij.na_sequence_id
and gij.annotated_intron = 'Yes'
group by gs.organism
)
select gs.na_sequence_id, gs.source_id, ot.*
from genomicseqattributes gs, org_tot ot
where gs.organism = ot.organism
and gs.na_sequence_id in (select distinct na_sequence_id from apidb.intronjunction)
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index GeneIntJuncStat_ix&1 on GeneIntJuncStats&1 (na_sequence_id) tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneMaxIntronGIJ">
    <comment> Stores maximum values per gene for each sample so percent max intron can be computed for sample table.
     </comment>
    <internalDependency name="GeneIntronJunction"/>
    <internalDependency name="NameMappingGIJ"/>
    <externalDependency name="apidb.IntronJunction"/>
    <sql>
      <![CDATA[
create table GeneMaxIntronGIJ&1 (
    protocol_app_node_id    number(10),
    gene_source_id          varchar2(200),
    max_unique              number,
    max_isrpm               number
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
BEGIN
  FOR idlist IN (
    select distinct na_sequence_id
      from GeneIdLocGIJ
    )
  LOOP
  insert into GeneMaxIntronGIJ&1 nologging (
select j.protocol_app_node_id, ga.source_id, max(unique_reads) as max_unique, max(round(j.unique_reads * mult.multiplier,2)) as max_isrpm
from apidb.intronjunction j, GeneIdLocGIJ ga, namemappinggij mult
where ga.na_sequence_id = idlist.na_sequence_id
and ga.na_sequence_id = j.na_sequence_id
and ga.start_min <= j.segment_start
and ga.end_max >= j.segment_end
and ga.is_reversed = j.is_reversed
and j.protocol_app_node_id = mult.junctions_pan_id
group by j.protocol_app_node_id, ga.source_id
    );
    commit;
   END LOOP;
END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index GnMxIntGIJ_ix&1 on GeneMaxIntronGIJ&1 (gene_source_id,protocol_app_node_id) tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PopsetSequence">
    <comment> Each record stores the nucleotide sequence of one popset. Used in the
         relevant attribute query of the WDK popset record, as well as by
         PopsetClustalOmega. Propagated to portal instances.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE PopsetSequence&1 NOLOGGING AS
SELECT ia.source_id, ia.project_id,
       ns.sequence
FROM PopsetAttributes ia, dots.NaSequence ns
WHERE ia.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PopsetSeq_ix&1 on PopsetSequence&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviation">
    <comment> Each record maps an organism name onto an abbreviation, getting the
         pair either from apidb.Organism or (in the case of Tvag), hardwired
         into the below SQL. This table will eventually be replaced by workflow.
      </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 NOLOGGING AS
       select organism, abbreviation
       From (
  select tn.name as organism, o.name_for_filenames as abbreviation
  from apidb.Organism o, sres.TaxonName tn
  where o.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
       )
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
         names. Each record maps an organism name onto this abbreviation, as
         well as the species name and project ID. Used by the model and as an
         input in the creation of the OrganismAbbreviationBlast tuning table.
         Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationWS&1 nologging as
       select oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       from OrganismAbbreviation oa, OrganismTree ot
       where ot.term = oa.organism
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProjectIdTaxonLevel">
    <comment> Groups projects by higher level taxonomy. Used in the creation of the
         OldOrganismTree tuning table.
      </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 NOLOGGING AS
       SELECT p.project_id, taxon_node, organism
          FROM (SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node 
		FROM dual
		UNION 
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node 
		FROM dual
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		FROM dual
		UNION
		SELECT 'HostDB' AS project_id,
		           'Chordata' AS taxon_node
		FROM dual
        ) p,
        (select distinct project_id, organism from GenomicSeqAttributes) s
        where p.project_id = s.project_id
        union 
        SELECT distinct s.project_id as project_id, 
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Allomyces%')
            then 'Blastocladiomycetes'
            when (s.organism like 'Batrachochytrium%' or
                  s.organism like 'Spizellomyces%') 
            then 'Chytridiomycetes'
            when (s.organism like 'zymoseptoria%' or
                  s.organism like 'Zymoseptoria%' or
                  s.organism like 'Cenococcum%')
            then 'Dothideomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Amauroascus%' or
                  s.organism like 'Byssoonygena%' or
                  s.organism like 'Chrysosporium%' or
                  s.organism like 'Cladophialophora%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Cyphellophora%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Exophiala%' or
                  s.organism like 'Fonsecaea%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Paracoccidioides%' or
                  s.organism like 'Uncinocarpus%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Rhizophagus%')
            then 'Glomeromycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or 
                  s.organism like 'Botryotinia%')
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Saprolegnia%' or
                  s.organism like 'Albugo%' or
                  s.organism like 'Aphanomyces%' or
                  s.organism like 'Pythium%')
            then 'Oomycetes'
            when (s.organism like 'Pneumocystis%')
            then 'Pneumocystidomycetes'
            when (s.organism like 'Puccinia%' or
                  s.organism like 'Melampsora%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Yarrowia%' or
                  s.organism like 'Clavispora%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes' 
            when (s.organism like 'Neurospora%' or 
                  s.organism like 'Magnaporthe%' or 
                  s.organism like 'Fusarium%' or 
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Lomentospora%' or
                  s.organism like 'Scedosporium%' or
                  s.organism like 'Sordaria%' or
                  s.organism like 'Sporothrix%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Kwoniella%' or
                  s.organism like 'Naganishia%' or
                  s.organism like 'Cryptococcus%')
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or 
                  s.organism like 'Sporisorium%') 
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%' or
                  s.organism like 'Phycomyces%')
            then 'Zygomycetes'
            when (s.organism like 'Ixodes%')
            then 'Ixodida'
            when (s.organism like 'Pediculus%')
            then 'Phthiraptera'
            when (s.organism like 'Leptotrombidium%')
            then 'Trombidiformes'
            when s.organism like 'Sarcoptes%'
            then 'Sarcoptiformes'
            when (s.organism like 'Cimex%' or
                  s.organism like 'Rhodnius%')
            then 'Hemiptera'
            when (s.organism like 'Aedes%' or
                  s.organism like 'Anopheles%' or
                  s.organism like 'Glossina%' or
                  s.organism like 'Culex%' or
                  s.organism like 'Lutzomyia%' or
                  s.organism like 'Musca%' or
                  s.organism like 'Phlebotomus%' or
                  s.organism like 'Stomoxys%')
            then 'Diptera'
            when (s.organism like 'Biomphalaria%')
            then 'Gastropoda'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from GenomicSeqAttributes s
        where s.project_id in ('FungiDB', 'VectorBase')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OldOrganismTree">
    <comment> Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree, as well as
         apidb.project_id(), the function that maps an organism name to a
         project. Propagated to portal instances.
      </comment>
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
CREATE TABLE StrainTree NOLOGGING AS
SELECT *
FROM (         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           /* all organisms from GenomicSeqAttributes as organism, organism as term, parentterm is species            */
           SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           AND t.rank != 'species'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, species as term, parentterm is genus   */
           /* we are getting a row for species level AND for children here */
           SELECT DISTINCT sa.organism,  
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION 
           SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, genus as term, parentterm from taxonlevel */
           SELECT DISTINCT sa.organism,      
                           SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
           AND ptl.organism = sa.organism
           and ptl.organism not like 'Chromera%'
           and ptl.organism not like 'Vitrella%' 
           UNION
           /* all organisms from GenomicSeqAttributes as organism, taxon_node as term, parentterm is null */
           SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id not in ('FungiDB','MicrosporidiaDB')
            and ptl.organism not like 'Chromera%'
            and ptl.organism not like 'Vitrella%' 
            UNION
            -- add the kingdom for Fungi organism (this includes MicrosporidiaDB organisms)
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Fungi' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Fungi' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            -- add the kingdom for Oomycetes in FungiDB
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Oomycetes' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Oomycetes' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
                        UNION
            -- add the phylum for chomera and vitrella
          SELECT DISTINCT sa.organism,               
                            SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           'Chromerida' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Chromerida' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'           
))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OldOrganismTree&1 NOLOGGING AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
               SELECT * from StrainTree
               UNION
               SELECT stn.name as organism,
                      st.term as term,
                      st.parentTerm as parentTerm,
                      st.internal as internal,
                      st.project_id as project_id
               FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
               WHERE tn.taxon_id = ts.taxon_id
                 AND stn.taxon_id = ts.species_taxon_id
                 AND st.organism = tn.name
                 AND tn.name_class = 'scientific name'
                 AND stn.name_class = 'scientific name'
                 AND st.organism != st.term
          )
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismTree">
    <comment>
         Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree. Propagated to portal
         instances.
      </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <ancillaryTable name="DistinctTaxonLink"/>
    <sql>
      <![CDATA[
        create table DistinctTaxonLink&1 nologging as
        select taxon_id, max(rank) as rank, max(parent_id) as parent_id,
               max(tree_level) as tree_level,
               max(display_reason) as display_reason
        from (with datasets_taxon
                   as (select taxon_id
                       from GenomicSeqAttributes
                      )
              select taxon_id, rank, parent_id, level as tree_level,
                     case
                       when taxon_id
                            in (select taxon_id from datasets_taxon)
                         then 'has data'
                       when rank
                            in ('kingdom', 'phylum', 'class', 'order', 'family',
                                'genus', 'species')
                         then 'major rank'
                       when taxon_id
                            in ( select taxon_id 
                                 from sres.taxon 
                                 where ncbi_tax_id in (44542 -- gambiae species complex
                                                     , 554915 -- Amoebozoa
                                                     , 5796 -- Coccidia
                                                     , 1280412 -- Conoidasida 
                                ))
                         then 'hardwired'
                       else 'none'
                     end as display_reason
              from sres.Taxon
              start with taxon_id
                         in (select taxon_id from datasets_taxon)
              connect by taxon_id = prior parent_id
             )
        group by taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index dtl_ix&1
        on DistinctTaxonLink&1 (taxon_id)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        BEGIN
          FOR skiplist
              IN (select taxon_id, max(parent_id) as parent_id, max(tree_level)
                  from DistinctTaxonLink&1
                  where display_reason in ('none', 'has data')
                  group by taxon_id
                  order by max(tree_level) desc
                 )
          LOOP
            update DistinctTaxonLink&1
            set parent_id
                = (select max(parent_id)
                   from DistinctTaxonLink&1
                   where taxon_id = skiplist.taxon_id)
            where parent_id = skiplist.taxon_id;

          END LOOP;

          commit;
        END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        delete from DistinctTaxonLink&1 where display_reason = 'none'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table OrganismTree&1 nologging as
        select leaf_name.name as organism,
               tn.name as term, parent_name.name parentterm,
               dtl.taxon_id as internal,
               apidb.project_id(leaf_name.name) as project_id,
               dtl.tree_level, dtl.rank
        from (select connect_by_root taxon_id as leaf_taxon_id, taxon_id,
                     parent_id, rank, tree_level
              from DistinctTaxonLink&1
              start with display_reason = 'has data'
                         or rank = 'species'
              connect by taxon_id = prior parent_id
             ) dtl,
             sres.TaxonName leaf_name, sres.TaxonName tn,
             (select taxon_id, name
              from sres.TaxonName
              where name_class = 'scientific name') parent_name
        where dtl.leaf_taxon_id = leaf_name.taxon_id
          and leaf_name.name_class = 'scientific name'
          and dtl.taxon_id = tn.taxon_id
          and tn.name_class = 'scientific name'
          and dtl.parent_id = parent_name.taxon_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
               create index OrgTree_term_pterm_ix&1 on OrganismTree&1(TERM, PARENTTERM)
               TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
         BLAST-query parameters. Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationBlast&1 nologging as
         select organism, parent, abbreviation, substr(project_id, 1, 20) as project_id
         from OrganismAbbreviationWS
       union
         -- all familes for popsets
         select distinct family_name_for_files
                           || ' Popset/Genbank Isolates' as organism, '' as parent,
                         family_name_for_files as abbreviation,
                         substr(project_name, 1, 20) as project_id
         from apidb.Organism 
         where family_name_for_files is not null
           and abbrev || '_isolates_genbank_RSRC'
               in (select external_db_name  as db_name
                   from PopsetAttributes)
           and family_name_for_files
                 not in ('Culicosporidae', 'Dubosqiidae', 'Ordosporidae')
       union
         select special.organism, special.parent, special.abbreviation,
                substr(ot.project_id, 1, 20) as project_id
         from OrganismTree ot,
              ( -- all species and speciesAbbreviations from apidb.Organism where we have ests
                 select distinct
                        sp.name as organism, ot.parentTerm as parent,
                        regexp_replace(org.name_for_filenames,
                               replace( org.strain_abbrev, '/','_'),'', 1, 1)
                          as abbreviation
                 from sres.TaxonName sp, TaxonSpecies ts, apidb.Organism org,
                      OrganismTree ot
                 where org.taxon_id = ts.taxon_id
                   and ts.species_taxon_id = sp.taxon_id
                   and sp.name_class = 'scientific name'
                   and ot.term = sp.name
                   and org.strain_abbrev is not null
                   and org.name_for_filenames is not null
                   and sp.taxon_id
                       in (select etn.taxon_id
                           from sres.TaxonName etn
                           where etn.name in (select organism from EstAttributes))
               union
                 select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism,
                        'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation
                 from dual
              ) special
         where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
         species. Used in BLAST param queries. Propagated to portal instances.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       create table BlastTypes&1 nologging as
  /* Standard GENES */
  select distinct organism, project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where organism not in ('Toxoplasma gondii RH') and (gene_type = 'protein coding' or gene_type = 'protein coding gene')
  UNION
  /* GiardiaDB Deprecated Genes */
  select 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  UNION
  /* GiardiaDB Scaffolds */
  select 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'Genome' as type from dual)
  UNION  
  /* Standard GENOME */
  select distinct organism, project_id, type 
  from GenomicSeqAttributes,
       (select 'Genome' as type from dual)
  UNION
  /* Mitochondrial GENES and GENOME */
  select distinct organism || ' mitochondrial', project_id, type 
  from GenomicSeqAttributes,       
  (select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0000819'
  and not project_id='PlasmoDB' 
  UNION
  /* Plastid GENES and GENOME */
  select distinct organism || ' plastid' as organism, project_id, type 
  from GenomicSeqAttributes,       
  (select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0001259'
  and not project_id='PlasmoDB' 
  UNION
  /* Regular ESTs (all species from estattributes) */
  select distinct sp.name as organism, ea.project_id, 'ESTs' as type
  from EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
  where ea.organism = tn.name
  and (tn.taxon_id = ts.taxon_id or tn.taxon_id=ts.species_taxon_id)
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  UNION
  /* regular Isolates */
  select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'PopSet'
  from apidb.Organism 
  where family_name_for_files is not null
  and abbrev || '_isolates_genbank_RSRC' in (SELECT DISTINCT external_db_name  AS db_name FROM PopsetAttributes)
  UNION
  /* isolates are hard coded */
  select 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'PopSet' as type from dual
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundProperties"  prefixEnabled="true">
    <comment> Properties table for ChEBI Compounds.
    </comment>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <!-- externalDependency name="chebi.Names"/ -->
    <!-- externalDependency name="chebi.Chemical_Data"/ -->
    <sql>
      <![CDATA[
CREATE TABLE CompoundProperties&1 NOLOGGING AS
SELECT c.ID, c.chebi_accession AS source_id, c.parent_id,
    c.name AS compound_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(cn.name)) AS apidb.varchartab)), ';'), 1, 1000) AS other_names,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(ciup.iupac_name)) AS apidb.varchartab)), ';'), 1, 1000) AS iupac_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(csyn.syn)) AS apidb.varchartab)), ';'), 1, 1000) AS syn,
    c.definition, m.mass,
    apidb.tab_to_string(set(cast(COLLECT(formu.formula order by formu.formula) as apidb.varchartab)), ';') AS formula,
    apidb.tab_to_string(set(cast(COLLECT(sec.chebi_accession order by sec.chebi_accession) as apidb.varchartab)), ';') AS secondary_ids
FROM  chebi.compounds c, 
  ( SELECT compound_id,  NAME FROM chebi.names WHERE TYPE='NAME') cn,
  ( SELECT compound_id,  MIN(NAME) AS iupac_name FROM chebi.names WHERE TYPE='IUPAC NAME' GROUP BY compound_id) ciup,
  ( SELECT compound_id,  MIN(NAME) AS syn FROM chebi.names WHERE type='SYNONYM' GROUP BY compound_id) csyn,
  ( SELECT compound_id, chemical_data AS formula FROM chebi.chemical_data WHERE TYPE='FORMULA') formu,
  ( SELECT compound_id, chemical_data AS mass FROM chebi.chemical_data WHERE TYPE='MASS' and chemical_data != 'NaN') m,
  ( SELECT parent_id, chebi_accession FROM chebi.compounds) sec
WHERE NOT c.status in ('D', 'F')
AND c.ID = cn.compound_id (+)
AND c.ID = ciup.compound_id (+)
AND c.ID = csyn.compound_id (+)
AND c.ID = formu.compound_id (+)
AND c.ID = m.compound_id (+)
AND c.ID = sec.parent_id (+)
GROUP BY c.ID, c.chebi_accession, c.parent_id, c.name, c.definition, m.mass
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes"  prefixEnabled="true">
    <comment> The BFMV for the compound WDK record type. Used by the model for the
         compound record and queries, as well as in the creation of the
         PathwayCompounds tuning table. Propagated to portal instances.
         Note: children of ChEBI compounds are excluded, but data of these is gathered in the (parent) entries.
      </comment>
    <internalDependency name="CompoundProperties"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCompoundAttributes&1 NOLOGGING AS
SELECT p.ID
, p.source_id
, p.compound_name
, apidb.tab_to_string(SET(CAST(COLLECT(childc.other_names ORDER BY childc.other_names) AS apidb.varchartab)), ';') AS other_names
, apidb.tab_to_string(SET(CAST(COLLECT(childc.iupac_name ORDER BY childc.iupac_name) AS apidb.varchartab)), ';') AS iupac_name
, apidb.tab_to_string(SET(CAST(COLLECT(childc.syn ORDER BY childc.syn) AS apidb.varchartab)), ';') AS syn
, p.definition  
, p.secondary_ids
, apidb.tab_to_string(SET(CAST(COLLECT(childc.formula ORDER BY childc.formula) AS apidb.varchartab)), ';') AS formula
, (avg(childc.mass)) AS mass
FROM CompoundProperties p
, (SELECT id, parent_id, other_names, iupac_name, syn, mass, formula FROM CompoundProperties ) childc
WHERE p.parent_id IS NULL
AND  (p.ID = childc.parent_id OR p.ID =childc.ID )
GROUP BY p.ID, p.source_id, p.compound_name, p.definition, p.secondary_ids
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundId" prefixEnabled="true">
    <comment> Alias table for Compounds.
    Compound column is the source_id from CompoundAttributes (chEBI_ID).
    ID can have this same ID, or mapping KEGG ID, or Name, or Synonym.
    </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="CompoundProperties"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCompoundId&1 NOLOGGING AS
      SELECT source_id AS id, source_id AS compound, 'same ID' AS type, '' as source 
      FROM &prefixCompoundAttributes
      UNION
      SELECT p.source_id AS id, ca.source_id AS compound, 'child ID' AS type, '' as source 
      FROM &prefixCompoundAttributes ca, CompoundProperties p
      WHERE ca.id = p.parent_id
      UNION
      SELECT da.accession_number AS id,  p.source_id AS compound, 'KEGG'  AS type, '' as source 
      FROM chebi.database_accession da, &prefixCompoundAttributes p
      WHERE da.type='KEGG COMPOUND accession' 
      AND  da.compound_id = p.id
      UNION
      SELECT  distinct da.accession_number AS id,  p.chebi_accession AS compound, 'KEGG'  as type, '' as source 
      FROM chebi.database_accession da, chebi.compounds c, chebi.compounds p
      WHERE NOT p.status in ('D', 'F') AND da.type='KEGG COMPOUND accession' 
      AND da.compound_id = c.id AND c.parent_id=p.id
      UNION
      SELECT n.name as id, ca.source_id as compound, 'name' as type, n.source
      FROM &prefixCompoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'NAME' 
      UNION
      SELECT n.name as id, ca.source_id as compound, 'synonym' as type, n.source
      FROM &prefixCompoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'SYNONYM'
      ]]>
    </sql>
    <sql>
      <![CDATA[
      CREATE INDEX &prefixCompoundId_idx&1 ON &prefixCompoundId&1 (id, compound)
      TABLESPACE indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="PathwayCompounds">
    <comment> Each record represents a 5-tuple of (reaction, compound, pathway,
         enzyme, type). Used extensively in the model for pathway-related
         queries, as well as by getImageMap.pl.
      </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
    CREATE TABLE PathwayCompounds&1 NOLOGGING AS
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'substrate' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
    union
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'product' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PthCmpd_id_ix&1
        on PathwayCompounds&1(pathway_id, reaction_id, ext_db_name)
        tablespace indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="PathwayReactions">
    <comment>Aggregates reactions irrespective of pathway.  Required to determine if BioCyc reactions are reversible.  Used extensively in the model in conjunction with pathwaycompounds for pathway related queries</comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <internalDependency name="PathwayCompounds"/>

    <sql>
      <![CDATA[
        CREATE TABLE PathwayReactions&1 NOLOGGING AS
        select o.*
        , (case when o.expasy_url is not null then '<a href="' || o.expasy_url || '">' || o.enzyme || '</a>' else o.enzyme end) as expasy_html
        from (
            select i.*
            , (case when i.enzyme like '%.%.%.%' and i.enzyme != '-.-.-.-' then 'http://enzyme.expasy.org/cgi-bin/enzyme/enzyme-search-ec?field1='
                ||ec.ec_number_1
                ||decode(ec.ec_number_2, null, null,chr(38) || 'field2='||ec.ec_number_2)
                ||decode(ec.ec_number_3, null, null,chr(38) || 'field3='||ec.ec_number_3)
                ||decode(ec.ec_number_4, null, null,chr(38) || 'field4='||ec.ec_number_4) else reaction_url end ) as expasy_url
            , ec.description as enzyme_description
            from (
                select
                reaction_id
                , reaction_source_id
                , reaction_url
                , ext_db_name
                , ext_db_version
                , enzyme
                , substrates_html || ' ' || sign || ' ' || products_html as equation_html
                , substrates_text || ' ' || sign || ' ' || products_text as equation_text
                , case when sign = '<=>' then 1 else 0 end as is_reversible
                , substrates_text
                , products_text
                from (
                    select
                    reaction_id
                    , reaction_source_id
                    , reaction_url
                    , ext_db_name
                    , ext_db_version
                    , enzyme
                    , (case when (listagg (case when type_list like '%substrate%' then compound end, ',') within group (order by compound)) = (listagg (case when type_list like '%product%' then compound end, ',') within group (order by compound)) or is_reversible = 1 then '<=>' else '=>' end) as sign
                    , listagg (case when type like '%substrate%' then compound_url end, ' + ') within group (order by compound_url) as substrates_html
                    , listagg (case when type like '%substrate%' then compound end, ' + ') within group (order by compound) as substrates_text
                    , listagg (case when type like '%product%' then compound_url end, ' + ') within group (order by compound_url) as products_html
                    , listagg (case when type like '%product%' then compound end, ' + ') within group (order by compound) as products_text
                    from (
                      select distinct
                      pr.PATHWAY_REACTION_ID as reaction_id
                      , pr.SOURCE_ID as reaction_source_id
                      , (case (replace (replace (ed.name, 'Pathways_', ''), '_RSRC', ''))
                        when 'KEGG' then 'https://www.genome.jp/dbget-bin/www_bget?rn:' || pr.source_id
                        when 'MetaCyc' then 'https://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'TrypanoCyc' then 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'LeishCyc' then 'http://vm-trypanocyc.toulouse.inra.fr/LEISH/new-image?tyrp=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'FungiCyc' then null
                        end) as reaction_url
                      , ed.NAME as ext_db_name
                      , edr.VERSION as ext_db_version
                      , cast(pn.DISPLAY_LABEL as varchar2(20)) as enzyme
                      , listagg (pc.type, ',') within group (order by pc.pathway_id) as type_list
                      , max (prel.is_reversible) KEEP (DENSE_RANK LAST ORDER BY prel.is_reversible) over (partition by pr.pathway_reaction_id) as is_reversible
                      , nvl(ca.compound_name, pc.compound_source_id) as compound
                      , (case when nvl(pc.CHEBI_ACCESSION, pc.compound_source_id) like 'CHEBI%' then '<a href="/a/app/record/compound/' || nvl(pc.chebi_accession, pc.compound_source_id) || 
                            '" title="' || nvl(pc.chebi_accession, pc.compound_source_id) || '">' || nvl(ca.compound_name, pc.compound_source_id) || '</a>' 
                            else nvl(pc.chebi_accession, pc.compound_source_id) end) as compound_url
                      , min(pc.type) KEEP (DENSE_RANK FIRST ORDER BY p.pathway_id) as type
                      from
                      sres.pathway p
                      , apidb.pathwayreaction pr
                      , APIDB.PATHWAYREACTIONREL prr
                      , SRES.PATHWAYNODE pn
                      , SRES.PATHWAYRELATIONSHIP prel
                      , SRES.EXTERNALDATABASE ed
                      , SRES.EXTERNALDATABASERELEASE edr
                      , SRES.ONTOLOGYTERM ot
                      , PathwayCompounds pc
                      , CompoundAttributes ca
                      where p.PATHWAY_ID = prr.PATHWAY_ID
                      and pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
                      and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
                      and prel.NODE_ID = pn.PATHWAY_NODE_ID
                      and ot.name = 'enzyme'
                      and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
                      and pc.EXT_DB_NAME = ed.NAME
                      and pc.EXT_DB_VERSION = edr.VERSION
                      and ed.EXTERNAL_DATABASE_ID = edr.EXTERNAL_DATABASE_ID
                      and pc.PATHWAY_ID = p.PATHWAY_ID
                      and pc.REACTION_id = pr.PATHWAY_REACTION_ID
                      and pc.chebi_accession = ca.source_id (+)
                      group by pr.pathway_reaction_id, pr.SOURCE_ID, ed.NAME, edr.VERSION, pn.DISPLAY_LABEL, prel.IS_REVERSIBLE, nvl(pc.chebi_accession, pc.compound_source_id), pn.display_label
                        , nvl(ca.compound_name, pc.compound_source_id)
                      )
                    group by reaction_id, reaction_source_id, reaction_url, ext_db_name, ext_db_version, enzyme, is_reversible
                    )
                ) i
                LEFT OUTER JOIN sres.enzymeclass ec ON i.enzyme = ec.ec_number
            ) o
        ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathRcts_id_ix&1
        on PathwayReactions&1 (reaction_id, reaction_source_id, enzyme, expasy_url, ext_db_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayNodes">
    <comment>Nodes and edges for pathway maps</comment>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayNodeGene"/>
    <internalDependency name="CompoundId"/>
    <internalDependency name="PathwayReactions"/>
    <ancillaryTable name="PathwayEdges"/>
    <intermediateTable name="NodesWithTypes"/>
    <intermediateTable name="ReactionsWithReversibility"/>
    <intermediateTable name="EnzymeEdges"/>
    <intermediateTable name="ParentNodes"/>
    <intermediateTable name="NodesWithParents"/>
    <intermediateTable name="EnzymeReactions"/>
    <intermediateTable name="ParentsForEdges"/>
    <sql>
      <![CDATA[
        CREATE TABLE NodesWithTypes NOLOGGING AS
            SELECT pn.pathway_id
            , CASE WHEN pa.name IS NOT NULL THEN pa.name ELSE pn.display_label END AS display_label
            , pa.url
            , CASE WHEN pa.name IS NOT NULL THEN pa.name ELSE pn.display_label END AS name
            , pa.source_id AS node_identifier
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , NULL AS gene_count
            , NULL AS default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , PathwayAttributes pa
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND pn.display_label = pa.source_id (+)
            AND ot.name = 'metabolic process'
            UNION ALL
            SELECT pn.pathway_id
            , pn.display_label
            , NULL AS url
            , nvl(ec.description, pn.display_label) AS name
            , ec.ec_number AS node_identifier
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , count (tp.gene_source_id) as gene_count
            , NULL AS default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , sres.enzymeclass ec
            , PathwayNodeGene tp
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND ot.name = 'enzyme'
            AND pn.row_id = ec.enzyme_class_id (+)
            AND pn.pathway_node_id = tp.pathway_node_id (+)
            GROUP BY pn.pathway_id
            , pn.display_label
            , ec.description
            , ec.ec_number
            , to_char(pn.pathway_node_id)
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name
             UNION ALL
            SELECT pn.pathway_id
            , pn.display_label
            , NULL AS url
            , nvl(c.name, pn.display_label) AS name
            , c.chebi_accession AS node_identifier  
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , NULL AS gene_count
            , st.default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , chebi.compounds c
            , (SELECT n.compound
                , s.structure AS default_structure
                FROM chebi.structures s
                , (SELECT id
                    , compound
                    FROM CompoundId
                    WHERE type IN ('same ID', 'child ID')
                    ) n
                WHERE n.id = 'CHEBI:' || s.compound_id
                AND s.type = 'mol'
                AND s.dimension = '2D'
                AND s.default_structure = 'Y'
            ) st
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND ot.name = 'molecular entity'
            AND pn.row_id = c.id (+)
            AND c.chebi_accession = st.compound (+)
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE ReactionsWithReversibility NOLOGGING AS
            SELECT DISTINCT spr.pathway_relationship_id
            , tpr.is_reversible
            , tpr.reaction_source_id
            FROM sres.pathwayrelationship spr
            , apidb.pathwayreactionrel prr
            , PathwayReactions tpr
            WHERE prr.pathway_relationship_id = spr.pathway_relationship_id
            AND tpr.reaction_id = prr.pathway_reaction_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE EnzymeEdges NOLOGGING AS
            SELECT DISTINCT nwt.pathway_id AS pathway_id
            , nwt.pathway_node_id AS e_id
            , nwt.type
            , i.associated_node_id AS m1_id
            , rri.is_reversible AS ir1
            , o.node_id AS m2_id
            , rro.is_reversible AS ir2
            , i.associated_node_id || '_' || o.node_id || '_' || rri.is_reversible || '_' || rro.is_reversible as io
            FROM sres.pathwayrelationship i
            , sres.pathwayrelationship o
            , NodesWithTypes nwt
            , ReactionsWithReversibility rri
            , ReactionsWithReversibility rro
            WHERE i.node_id = nwt.pathway_node_id
            AND o.associated_node_id = nwt.pathway_node_id
            AND i.pathway_relationship_id = rri.pathway_relationship_id
            AND o.pathway_relationship_id = rro.pathway_relationship_id
            AND nwt.type = 'enzyme'
            AND rri.is_reversible = rro.is_reversible
            AND rri.reaction_source_id = rro.reaction_source_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE ParentNodes NOLOGGING AS
            WITH AllEnzymeEdges AS (
                SELECT listagg(io, ',') WITHIN GROUP (ORDER BY io) AS all_edges
                , e_id
                , pathway_id
                FROM EnzymeEdges
                GROUP BY pathway_id
                , e_id
            )
            , pn as (
                SELECT pathway_id
                , all_edges
                , listagg(e_id, '_') WITHIN GROUP (ORDER BY e_id) AS parent
                FROM AllEnzymeEdges
                GROUP BY pathway_id
                , all_edges
                HAVING COUNT (*) > 1
            )
            SELECT aee.e_id, pn.*
            FROM pn
            , AllEnzymeEdges aee
            WHERE aee.all_edges = pn.all_edges
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE NodesWithParents NOLOGGING AS
            SELECT DISTINCT ee.e_id AS pathway_node_id
            , pn.parent
            , ee.type AS node_type
            , ee.pathway_id
            FROM EnzymeEdges ee
            , ParentNodes pn
            WHERE pn.pathway_id = ee.pathway_id
            AND ee.e_id = pn.e_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE EnzymeReactions NOLOGGING AS
            SELECT DISTINCT pn.PATHWAY_NODE_ID node_id
            , pr.SOURCE_ID AS reaction_source_id
            FROM sres.pathwaynode pn
            , apidb.pathwayreaction pr
            , APIDB.PATHWAYREACTIONREL prr
            , SRES.PATHWAYRELATIONSHIP prel
            , sres.ontologyterm ot
            WHERE (prel.NODE_ID = pn.PATHWAY_NODE_ID OR prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID)
            AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
            AND pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
            AND ot.name = 'enzyme'
            AND pn.PATHWAY_NODE_TYPE_ID = ot.ONTOLOGY_TERM_ID
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE ParentsForEdges NOLOGGING AS
            SELECT ee.e_id
                , ee.m1_id
                , ee.ir1
                , ee.m2_id
                , ee.ir2
                , np.parent
                FROM EnzymeEdges ee
                , NodesWithParents np
                WHERE ee.e_id = np.pathway_node_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
         CREATE TABLE PathwayEdges&1 NOLOGGING AS
        SELECT pa.source_id
        , pa.pathway_source
        , rel.*
        FROM (
            SELECT DISTINCT ee.pathway_id
            , nvl(pe.parent, ee.e_id) AS source
            , to_char(ee.m1_id) AS target
            , max(ee.ir1) AS is_reversible
            FROM EnzymeEdges ee
            , ParentsForEdges pe
            WHERE ee.e_id = pe.e_id (+)
            GROUP BY ee.pathway_id, ee.m1_id, nvl(pe.parent, ee.e_id)
            UNION
            SELECT DISTINCT ee.pathway_id
            , to_char(ee.m2_id) AS source
            , nvl(pe.parent, ee.e_id) AS target
            , max(ee.ir2) AS is_reversible
            FROM EnzymeEdges ee
            , ParentsForEdges pe
            WHERE ee.e_id = pe.e_id (+)
            GROUP BY ee.pathway_id, ee.m2_id, nvl(pe.parent, ee.e_id)
            UNION
            SELECT pn1.pathway_id
            , to_char(pr.node_id) AS source
            , to_char(pr.associated_node_id) AS target
            , pr.is_reversible
            FROM sres.pathwayrelationship pr
            , sres.pathwaynode pn1
            , sres.pathwaynode pn2
            , sres.ontologyterm ot1
            , sres.ontologyterm ot2
            WHERE pr.node_id = pn1.pathway_node_id
            AND pr.associated_node_id = pn2.pathway_node_id
            AND pn1.pathway_node_type_id = ot1.ontology_term_id
            AND pn2.pathway_node_type_id = ot2.ontology_term_id
            AND ot1.name != 'enzyme'
            AND ot2.name != 'enzyme'
        ) rel
        , PathwayAttributes pa
        WHERE pa.pathway_id = rel.pathway_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE PathwayNodes&1 NOLOGGING AS
        SELECT pa.source_id
        , pa.pathway_source
        , pn.display_label
        , pn.x
        , pn.y
        , pn.width
        , pn.height
        , pn.cellular_location
        , nvl(pn.url,
            CASE WHEN nvl(type, nodes_with_parents.node_type) = 'enzyme' THEN
                CASE WHEN REGEXP_LIKE (display_label, '^\d+\.(\d|-)+\.(\d|-)+\.(\d|-)+$') THEN 'https://enzyme.expasy.org/EC/' || display_label
                WHEN pa.pathway_source = 'KEGG' THEN 'https://www.genome.jp/dbget-bin/www_bget?rn:' || reaction_source_id
                WHEN pa.pathway_source = 'MetaCyc' THEN 'https://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || reaction_source_id
                WHEN pa.pathway_source = 'TrypanoCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || reaction_source_id
                WHEN pa.pathway_source = 'LeishCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/LEISH/new-image?tyrp=REACTION' || chr(38) || 'object=' || reaction_source_id
                ELSE NULL END
            ELSE NULL END) AS url
        , pn.name
        , pn.node_identifier
        , nodes_with_parents.pathway_node_id AS id
        , nodes_with_parents.parent
        , reaction_source_id
        , nvl(type, nodes_with_parents.node_type) AS node_type
        , pn.gene_count
        , pn.default_structure
        FROM
            (SELECT e_id AS pathway_node_id
            , nwp.parent
            , type AS node_type
            , ee.pathway_id
            , er.reaction_source_id
            FROM EnzymeEdges ee
            , NodesWithParents nwp
            , EnzymeReactions er
            WHERE ee.e_id = nwp.pathway_node_id (+)
            AND er.node_id = ee.e_id
            UNION
            SELECT nwp.parent
            , NULL 
            , 'nodeOfNodes'
            , pathway_id
            , NULL
            FROM NodesWithParents nwp
            UNION
            SELECT nwt.pathway_node_id AS pathway_node_id
            , NULL AS parent
            , nwt.type
            , nwt.pathway_id
            , NULL
            FROM NodesWithTypes nwt
            WHERE nwt.type != 'enzyme'
            ) nodes_with_parents
        , NodesWithTypes pn
        , PathwayAttributes pa
        WHERE nodes_with_parents.pathway_node_id = pn.pathway_node_id (+)
        AND nodes_with_parents.pathway_id = pa.pathway_id
      ]]>
    </sql>
    <!--TODO index -->
  </tuningTable>

  <!--MetabolicPathwaySres table - simplify model query to improve download performance -->
  <tuningTable name="PathwaysGeneTable">
    <comment>Used by pathway table on gene pages</comment>
    <internalDependency name="TranscriptPathway"/>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwaysGeneTable&1 NOLOGGING AS
        SELECT DISTINCT gene_source_id
        , project_id
        , pathway_source_id
        , pathway_name
        , count(reaction_source_id) as reactions
        , enzyme
        , expasy_url
        , pathway_source
        , exact_match
        FROM (
            SELECT DISTINCT tp.gene_source_id
            , tp.project_id
            , tp.pathway_source_id
            , tp.pathway_name
            , pr.reaction_source_id
            , pr.enzyme
            , pr.expasy_url
            , tp.pathway_source
            , decode(max(tp.exact_match), 1, 'Yes', 0, 'No') AS exact_match
            FROM TranscriptPathway tp
            , PathwayAttributes pa
            , PathwayCompounds pc
            , PathwayReactions pr
            WHERE tp.pathway_id = pa.pathway_id
            AND pc.pathway_id = pa.pathway_id
            AND pr.reaction_id = pc.reaction_id
            AND pr.ext_db_name = pc.ext_db_name
            AND tp.ec_number_pathway = pr.enzyme
            AND tp.wildcard_count_gene <= tp.wildcard_count_pathway
            AND pr.enzyme != '-.-.-.-'
            GROUP BY tp.gene_source_id, tp.project_id, tp.pathway_name, tp.pathway_source_id, pr.reaction_source_id, pr.enzyme, pr.expasy_url, tp.pathway_source
            )
        GROUP BY gene_source_id, project_id, pathway_source_id, pathway_name, enzyme, expasy_url, pathway_source, exact_match
        ORDER BY pathway_source, lower(pathway_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index pgt_ix&1 on PathwaysGeneTable&1
             (gene_source_id, project_id, pathway_source_id, pathway_name, 
              reactions, enzyme, expasy_url, pathway_source, exact_match)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>
    

  <tuningTable name="CompoundTypeAheads">
    <comment> for use in GenesByReactionCompounds question </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <sql>
      <![CDATA[
        CREATE TABLE CompoundTypeAheads&1 NOLOGGING AS
        SELECT ca.source_id AS compound_id,
              TO_CHAR(ca.source_id)  || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
        UNION
        SELECT ca.source_id AS compound_id,
              pc.compound_source_id || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
         one experiment for one gene. Used for mass spec queries in the model,
         GBrowse, and PBrowse, and also in the creation of the MSTranscriptSummary
         tuning table.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <intermediateTable name="MSExptTrustedSpectrum"/>
    <sql>
      <![CDATA[
create table MSExptTrustedSpectrum nologging as        
select distinct mss.external_database_release_id, mss.protocol_app_node_id, pan.name
from apidb.massspecsummary mss, dots.massspecfeature msf, study.protocolappnode pan
where mss.mass_spec_summary_id = msf.mass_spec_summary_id
and mss.PROTOCOL_APP_NODE_ID = pan.protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table MSPeptideSummary&1 nologging as
select  pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER
from (select dbms_lob.SUBSTR(seq.SEQUENCE,
pep.aa_end_max - pep.aa_start_min + 1,
                            pep.aa_start_min) as peptide_sequence,
       pep.*
from dots.aasequence seq, (
select ga.source_id, 
       ga.gene_source_id,
       ga.project_id,
       mss.protocol_app_node_id, 
       dsp.display_name as experiment,
       d.name as external_database_name,
       sum(msf.spectrum_count) as spectrum_count,
       mss.aa_sequence_id,
       msf.aa_feature_id as peptide_aa_feature_id,
       msf.na_feature_id as peptide_na_feature_id,
       l.start_min as aa_start_min,
       l.end_max as aa_end_max,
       good.name as sample
from apidb.massspecsummary mss, dots.massspecfeature msf, dots.aalocation l, 
     transcriptattributes ga, Msexpttrustedspectrum good, sres.externaldatabase d,
     sres.externaldatabaserelease r,  datasetnametaxon dsnt, datasetpresenter dsp
where mss.mass_spec_summary_id = msf.mass_spec_summary_id
and msf.aa_feature_id = l.aa_feature_id
and mss.aa_sequence_id = ga.aa_sequence_id (+)
and mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and d.name = dsnt.name (+)
and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
and mss.external_database_release_id = good.external_database_release_id (+)
and mss.protocol_app_node_id = good.protocol_app_node_id (+)
group by d.name, ga.source_id, ga.gene_source_id, ga.project_id, mss.protocol_app_node_id, dsp.display_name, 
         mss.aa_sequence_id, msf.aa_feature_id, msf.na_feature_id,mss.spectrum_count, l.start_min, l.end_max, good.external_database_release_id, good.name
) pep
where pep.aa_sequence_id = seq.aa_sequence_id) pep,
sampledisplayinfo sdi
where sdi.dataset_name = pep.external_database_name
and sdi.sample = replace (pep.sample ,' (MS Summary)', '') 
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index sample_ix&1 on MSPeptideSummary&1 (sample)
      tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index mspep_ix&1
        on MSPeptideSummary&1
             (aa_sequence_id, external_database_name, peptide_aa_feature_id, 
              aa_start_min, aa_end_max, sample, source_id, spectrum_count, experiment, 
              sample_display_name, html_color, peptide_sequence)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AnnotatedGenomeSummary">
    <comment> Stores summary information from annotated genomes to facilitate overview section of gene page
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        create table AnnotatedGenomeSummary&1 nologging as
        select ga.external_db_name as external_db_name, ga.organism, ga.taxon_id,
               o.is_reference_strain,
               (select value
                from DatasetProperty 
                where dataset_presenter_id = dsp.dataset_presenter_id
                  and property = 'isCurated') as is_curated_genome,
               (select value
                from DatasetProperty
                where dataset_presenter_id = dsp.dataset_presenter_id
                  and property = 'updatedAnnotationText') as updated_link_text,
               (select value
                from DatasetProperty 
                where dataset_presenter_id = dsp.dataset_presenter_id 
                  and property = 'specialLinkDisplayText') as special_link_text,
               (select rel.id_url
                from DatasetProperty p,  sres.ExternalDatabase db, sres.ExternalDatabaseRelease rel
                where p.dataset_presenter_id = dsp.dataset_presenter_id
                  and db.name = cast(substr(p.value, 1, 4000) as varchar2(4000))
                  and db.external_database_id = rel.external_database_id
                  and p.property = 'specialLinkExternalDbName') as link_url,
               dsp.release_policy
        from DatasetPresenter dsp, apidb.Organism o,
             (select distinct external_db_name, taxon_id, organism from GeneAttributes) ga
        where ga.external_db_name like '%_primary_genome_RSRC'
          and dsp.name (+) = ga.external_db_name
          and o.taxon_id = ga.taxon_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSTranscriptSummary">
    <comment> Mass-spec experiment results for a transcript. Used in the model for queries
         related to transcripts.
      </comment>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
create table MSTranscriptSummary&1 nologging as
select msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
from mspeptidesummary msps
where source_id is not null
group by msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msgs_ix&1 on MSTranscriptSummary&1 (source_id, gene_source_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSModifiedPeptideSummary">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
         and PBrowse.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table MSModifiedPeptideSummary&1 nologging as
select
       dbms_lob.substr(seq.sequence, pep.aa_end_max - pep.aa_start_min + 1,
              pep.aa_start_min)                                   as
       peptide_sequence,
       dbms_lob.substr(seq.sequence, 1, pep.residue_location + 1) as residue,
       pep.*
from   dots.aasequence seq,
       (select ga.source_id                     as source_id,
               ga.gene_source_id                as gene_source_id,
               so.name                     as modification_type,
               nvl(dsp.display_name, sample)    as experiment,
               ed.name                          as external_database_name,
               mss.external_database_release_id as external_database_release_id,
               mst.sample_display_name          as Sample_display,
               mst.sample                       as sample,
               pan.protocol_app_node_id         as protocol_app_node_id,
               mss.aa_sequence_id               as aa_sequence_id,
               msf.aa_feature_id                as peptide_aa_feature_id,
               msf.spectrum_count               as spectrum_count,
               mst.html_color                   as html_color,
               aal.start_min                    as residue_location,
               aalp.start_min                   as aa_start_min,
               aalp.end_max                     as aa_end_max,
               pot.description                  as description
        from   dots.posttranslationalmodfeature pot,
               dots.massspecfeature msf,
               apidb.massspecsummary mss,
               dots.aalocation aal,
               dots.aalocation aalp,
               sampledisplayinfo mst,
               sres.ontologyterm so,
               transcriptattributes ga,
               sres.externaldatabase ed,
               sres.externaldatabaserelease edr,
               datasetnametaxon dsnt,
               datasetpresenter dsp, 
               study.protocolappnode pan
        where  pot.parent_id = msf.aa_feature_id
           and pot.aa_feature_id = aal.aa_feature_id
           and msf.aa_feature_id = aalp.aa_feature_id
           and msf.mass_spec_summary_id = mss.mass_spec_summary_id
           and mss.aa_sequence_id = ga.aa_sequence_id
           and mss.external_database_release_id =
               edr.external_database_release_id
           and ed.name = dsnt.name (+)
           and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
           and mss.protocol_app_node_id = pan.protocol_app_node_id
           and ed.name = mst.dataset_name
           and mst.sample = replace (pan.name ,' (MS Summary)', '')
           and edr.external_database_id = ed.external_database_id
           and pot.sequence_ontology_id = so.ontology_term_id) pep
where  pep.aa_sequence_id = seq.aa_sequence_id 
      ]]>
    </sql>
    <sql>
      <![CDATA[
      alter table MSModifiedPeptideSummary&1 modify (modification_type null)
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msmodps_tx_ix&1 on MSModifiedPeptideSummary&1 (source_id, gene_source_id)
      tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msmodps_gn_ix&1 on MSModifiedPeptideSummary&1 (gene_source_id, source_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Ssgcid" alwaysUpdate="true">
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
         populated from their web service. Used in the gene record.
      </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model and GBrowse, as well as an input in the creation of
         the tuning tables like MSModifiedPeptideSummary and MSPeptideSummary.
      </comment>
    <program commandLine="buildSampleDisplayInfoTT"/>
  </tuningTable>


  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model when writing profile data
      </comment>
    <program commandLine="buildProfileSetDisplayInfoTT"/>
  </tuningTable>


  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Organism"/>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>


  <tuningTable name="SpliceSiteTranscripts">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.SpliceSiteGenes"/>
    <externalDependency name="apidb.PolyAGenes"/>
    <program commandLine="buildSpliceSitesTT"/>
  </tuningTable>


  <tuningTable name="GenomicsInternalHyperlink" alwaysUpdate="true">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="OrganismAttributes"/>
    <sql>
      <![CDATA[
create table GenomicsInternalHyperlink&1 nologging as
with 
rnaseqgenes as (
select p.DATASET_NAME
      , p.source_id as gene_source_id
      , ga.sequence_id as sequence_id
      , row_number() over(partition by p.dataset_name
                          order by p.max_value desc, p.source_id, ga.sequence_id) as rn
from profile p, geneattributes ga
where dataset_type = 'transcript_expression' and dataset_subtype =  'rnaseq'
and p.source_id = ga.source_id),
proteomicsgenes as (
select ga.gene_source_id,
       ga.SEQUENCE_ID,
       ga.protein_source_id,
       d.name,
       row_number() over(partition by d.name
                         order by mss.aa_seq_percent_covered desc, ga.gene_source_id) as rn
from apidb.MassSpecSummary mss, TranscriptAttributes ga,
     sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
where mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and mss.aa_sequence_id = ga.aa_sequence_id) ,
sequences as (
select sa.source_id
     , sa.taxon_id
     , row_number() over(partition by sa.taxon_id
                         order by sa.chromosome_order_num, sa.length desc) as rn
from GenomicSeqAttributes sa 
where sa.is_top_level = 1),
macros as (
select dnt.dataset_presenter_id
     , o.name_for_filenames
     , o.project_id
     , o.public_abbrev as org_abbrev
     , o.source_id as org_pk
     , dnt.name
     , dsp.name as dataset_presenter_name
     , sa.source_id as sequence_source_id
     , pg.sequence_id as p_sequence_source_id
     , pg.gene_source_id as p_gene_id
     , pg.protein_source_id as p_protein_id
     , rg.sequence_id as r_sequence_source_id
     , rg.gene_source_id as r_gene_id
from organismattributes o
   , datasetnametaxon dnt
   , datasetpresenter dsp
   , sequences sa
   , (select * from proteomicsgenes where rn = 1) pg
   , (select * from rnaseqgenes where rn = 1) rg
where o.component_taxon_id = dnt.taxon_id
and dnt.taxon_id = sa.taxon_id
and dnt.dataset_presenter_id = dsp.dataset_presenter_id
and sa.rn = 1
and dnt.name = pg.name (+)
and dnt.name = rg.dataset_name (+)
)
select distinct
       h.dataset_link_id, h.dataset_presenter_id, h.description
     , replace(h.text, 'DEFAULT_PROJECT', macros.project_id) as text
     , replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(h.url
                                            , 'DEFAULT_PROJECT', macros.project_id) 
                                            , 'ORGANISM_FILE_NAME', macros.name_for_filenames)
                                            , 'DEFAULT_SEQUENCE', macros.sequence_source_id)
                                            , 'DEFAULT_ORG_ABBREV', macros.org_abbrev)
                                            , 'DEFAULT_PROTEOMICS_SEQUENCE', macros.p_sequence_source_id)
                                            , 'DEFAULT_PROTEOMICS_GENE', macros.p_gene_id)
                                            , 'DEFAULT_PROTEOMICS_PROTEIN', macros.p_protein_id)
                                            , 'DEFAULT_RNASEQ_GENE', macros.r_gene_id)
                                            , 'DEFAULT_RNASEQ_SEQUENCE', macros.r_sequence_source_id)
                                            , 'DEFAULT_DATASET_NAME', macros.name) 
                                            , 'DEFAULT_DATASET_PRESENTER_NAME', macros.dataset_presenter_name) 
                                            , 'DEFAULT_ORGANISM_PK', macros.org_pk) as url
     , h.isPublication
from datasetpresenter dsp, macros, datasethyperlink h
where macros.dataset_presenter_id = dsp.dataset_presenter_id
and h.dataset_presenter_id = macros.dataset_presenter_id
and h.url like '/%'
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
    <comment> Stores changes in gene annotation. Used by the model for gene ID and
         table queries.
      </comment>
    <program commandLine="buildTrackOldAnnotationTT"/>
  </tuningTable>
-->

  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
      create table ProteomicsCitation&1 nologging as
      with pubs
           as (select name, id, contact_email,
                      listagg(publication, ',') WITHIN GROUP (order by publication) as pmids
               from (select ds.name as name, ds.dataset_presenter_id as id,
                                    c.email as contact_email, p.pmid as publication
                     from DatasetPresenter ds, DatasetContact c,
                          DatasetPublication p
                     where ds.dataset_presenter_id = c.dataset_presenter_id
                       and ds.dataset_presenter_id = p.dataset_presenter_id
                       and c.is_primary_contact = 1
                       and ds.type = 'protein_expression'
                       and ds.subtype is null)
               group by name, id, contact_email),
           samples
           as (select name, id,
                      listagg(sample_i, chr(10)) WITHIN GROUP (order by sample) as sample_table
               from (select distinct ds.name as name,
                                     ds.dataset_presenter_id as id, sample,
                                     '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
                     from MSPeptideSummary mps, DatasetPresenter ds
                     -- consider using the tuning table ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
                     where (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern))
               group by name, id)
      select name,
             dbms_lob.substr(description, 4000, 1) || ' Primary Contact Email: '|| nvl(email, 'unavailable')
             || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
             || sample_table || chr(10) ||
             ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
      from (select ds.name as name, ds.summary as description, pubs.contact_email as email,
                   pubs.pmids as publications, samples.sample_table as sample_table
            from DatasetPresenter ds, pubs, samples
            where ds.dataset_presenter_id = pubs.id
              and ds.dataset_presenter_id = samples.id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EqtlSpan">
    <externalDependency name="dots.ChromosomeElementFeature"/>
    <externalDependency name="apidb.NaFeatureHaploblock"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.NaLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table eqtlSpan&1 nologging as
        select gene_source_id, project_id, haplotype_block_name as hapblock_id, sequence_id,
               start_min, end_max, start_max, end_min,
               max(score) as lod_score, organism
        from (select ga.gene_source_id, ga.project_id, gls.haplotype_block_name,
                     ens.source_id as sequence_id, nl.start_min, nl.end_max, nl.start_max, nl.end_min,
                     to_binary_double(gls.lod_score_mant|| 'e' || gls.lod_score_exp) as score,
                     replace (ga.organism, ' ', '+') as organism
              from dots.ChromosomeElementFeature cef, apidb.NAFeatureHaploblock gls,
                   dots.ExternalNaSequence ens, dots.NaLocation nl, TranscriptAttributes ga
              where gls.na_feature_id = ga.gene_na_feature_id
                and cef.name = gls.haplotype_block_name
                and nl.na_feature_id = cef.na_feature_id
                and cef.na_sequence_id = ens.na_sequence_id
                and to_binary_double(gls.lod_score_mant || 'e' || gls.lod_score_exp) >= 1.5)
        group by gene_source_id, project_id, sequence_id, haplotype_block_name,
                 start_min, end_max, start_max, end_min, organism
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index eqtlSpan_ix&1
        on eqtlSpan&1 (gene_source_id, project_id, hapblock_id, sequence_id, start_min, end_max, start_max, end_min, organism, lod_score)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Pubmed" alwaysUpdate="true">
    <!-- PubMed info
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <program commandLine="buildPubmedTT"/>
  </tuningTable>


  <tuningTable name="GenePubmed">
    <!-- PubMed records mapped to genes
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="Pubmed"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <sql>
      <![CDATA[
        create table GenePubmed&1 nologging as
        with feat_pm as (
        select dbref_subset.na_feature_id,
               pm.pubmed_id, pm.doi, pm.title,
               dbms_lob.substr(pm.authors, 2000, 1) authors
        from Pubmed pm,
             (select dbna.na_feature_id, db.primary_identifier
              from dots.DbRefNaFeature dbna,
                   sres.DbRef db
              where db.db_ref_id = dbna.db_ref_id
               and db.external_database_release_id
                   in (  select external_database_release_id
                         from ExternalDbDatasetPresenter
                         where lower(dataset_presenter_display_name) like '%pubmed%'
                       union
                         select edr.external_database_release_id
                         from sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
                         where ed.external_database_id = edr.external_database_id
                           and lower(ed.name) like '%pubmed%'
                      )
             ) dbref_subset
        where dbref_subset.primary_identifier = to_char(pm.pubmed_id)
        )
        select ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors from TranscriptAttributes ta, feat_pm 
        where ta.na_feature_id = feat_pm.na_feature_id
        union
        select ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors from TranscriptAttributes ta, feat_pm 
        where ta.gene_na_feature_id = feat_pm.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_gene_idx&1
          on GenePubmed&1 (gene_source_id, source_id, project_id, pubmed_id, doi, title, authors)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_tx_idx&1
          on GenePubmed&1 (source_id, gene_source_id, project_id, pubmed_id, doi, title, authors)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


<!-- old version
  <tuningTable name="Profile">
    <! One profile per gene per dataset. Used for graphs
      >
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PANResults"/>
    <externalDependency name="apidb.OntologyTermResult"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="apidb.NaFeatureMetacycle"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      create table Profile&1 nologging as
      SELECT
             /* gene profiles */
             ds.name AS dataset_name, ds.type AS dataset_type,
             ds.subtype AS dataset_subtype, profile.profile_type,
             ga.source_id, profile.study_id AS profile_study_id,
             ps.name AS profile_set_name,
             cast(case
                    when regexp_replace(ps.name, '\[.+\]', '') like '% - %' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), '.+ - ', '')
                      /* special cases for legacy datasets */
                    when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%' 
                      then regexp_replace(regexp_replace(regexp_replace(regexp_replace(regexp_replace(ps.name, '\[.+ nonunique\]', ''), '\[.+ unique\]', ' - unique'), '\[.+\]', ''), 'aligned with cds coordinates ', 'cds coordinates'), 'T.brucei paired end RNA-Seqdata from Horn ', '')
                    else null
                  end as varchar2(50)
                 ) as profile_set_suffix,
             profile.profile_as_string, profile.max_value, profile.min_value,
             profile.max_timepoint, profile.min_timepoint
      FROM apidb.DataSource ds, sres.ExternalDatabase d, sres.ExternalDatabaseRelease r,
           study.study i, study.study ps, GeneAttributes ga,
           (SELECT res.na_feature_id, res.profile_type, sl.study_id,
                   CASE
                     WHEN (s.NAME ='Apicoplast and ER Proteomes')
                       THEN listagg(nvl(to_char(round(res.VALUE, 6)), 'NA'), chr(9)) WITHIN GROUP(ORDER BY pan.node_order_num)
                     ELSE listagg(NVL(TO_CHAR(ROUND(res.value, 2)), 'NA'), CHR(9)) within GROUP(ORDER BY pan.node_order_num)
                   END  AS profile_as_string,
                   max(res.value) AS max_value, min(value) as min_value,
                   max(pan.name) keep(dense_rank last order by value) as max_timepoint,
                   max(pan.name) keep(dense_rank FIRST ORDER BY value) AS min_timepoint
            FROM study.StudyLink sl, study.study s, study.ProtocolAppNode pan,
                 (select distinct sl.study_id
                  from study.studylink sl, PanResults panr
                  where sl.protocol_app_node_id = panr.pan_id
                    and panr.result_table = 'Results::NAFeatureDiffResult') dr,
                 (SELECT gene_profiles.*
                  FROM
                       (SELECT DISTINCT
                               'values' AS profile_type,
                               MAX(value) AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM results.NaFeatureHostResponse
                        GROUP BY na_feature_id, protocol_app_node_id
                      UNION ALL
                        SELECT DISTINCT
                               'values' AS profile_type,
                                mean_phenotype,
                                na_feature_id,
                                protocol_app_node_id
                        FROM apidb.CrisprPhenotype
                      UNION ALL
                        SELECT DISTINCT
                               'values' AS profile_type,
                               score,
                               na_feature_id,
                               protocol_app_node_id
                        FROM apidb.PhenotypeScore
                      UNION ALL
                        SELECT DISTINCT
                               'values' AS profile_type,
                               relative_growth_rate,
                               na_feature_id,
                               protocol_app_node_id
                        FROM apidb.PhenotypeGrowthRate
                      UNION ALL
                        SELECT DISTINCT
                               'values' AS profile_type,
                                value,
                                na_feature_id,
                                protocol_app_node_id
                        FROM results.NaFeatureExpression
                      UNION ALL
                        SELECT DISTINCT
                               'channel1_percentiles' AS profile_type,
                               percentile_channel1 AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM results.NaFeatureExpression
                      UNION ALL
                        SELECT DISTINCT
                               'channel2_percentiles' AS profile_type,
                                percentile_channel2 AS value,
                                na_feature_id,
                                protocol_app_node_id
                        FROM results.NaFeatureExpression
                      UNION ALL
                        SELECT DISTINCT
                               'standard_error' AS profile_type,
                               standard_error AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM results.NaFeatureExpression
                      UNION ALL
                        SELECT DISTINCT
                               'pvalue' AS profile_type,
                               pvalue AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM apidb.NaFeatureMetacycle
                      UNION ALL
                        SELECT DISTINCT
                               'amplitude' AS profile_type,
                               amplitude AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM apidb.NaFeatureMetacycle
                      UNION ALL
                        SELECT DISTINCT
                               'period' AS profile_type,
                               period AS value,
                               na_feature_id,
                               protocol_app_node_id
                        FROM apidb.NaFeatureMetacycle
                       ) gene_profiles
                 ) res
            WHERE sl.protocol_app_node_id = pan.protocol_app_node_id
              AND pan.protocol_app_node_id = res.protocol_app_node_id
              AND sl.study_id IN (SELECT study_id FROM study.Study WHERE investigation_id IS NOT NULL)
              AND sl.study_id = dr.study_id (+)
              AND sl.study_id = s.study_id
              AND dr.study_id is null
            GROUP BY res.na_feature_id, res.profile_type, sl.study_id, s.name
           ) profile
      WHERE ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
        AND profile.na_feature_id = ga.na_feature_id
    UNION ALL
      /* non-gene profiles */
      SELECT
             ds.name AS dataset_name, ds.type AS dataset_type,
             ds.subtype AS dataset_subtype, profile.profile_type,
             profile.source_id, profile.study_id AS profile_study_id,
             ps.name AS profile_set_name,
             cast(case
                    when regexp_replace(ps.name, '\[.+\]', '') like '% - %' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), '.+ - ', '')
                      /* special cases for legacy datasets */
                    when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %' 
                      then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                    when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%' 
                      then regexp_replace(regexp_replace(regexp_replace(regexp_replace(regexp_replace(ps.name, '\[.+ nonunique\]', ''), '\[.+ unique\]', ' - unique'), '\[.+\]', ''), 'aligned with cds coordinates ', 'cds coordinates'), 'T.brucei paired end RNA-Seqdata from Horn ', '')
                    else null
                  end as varchar2(50)
                 ) as profile_set_suffix,
             profile.profile_as_string, profile.max_value, profile.min_value,
             profile.max_timepoint, profile.min_timepoint
      FROM apidb.DataSource ds, sres.ExternalDatabase d, sres.ExternalDatabaseRelease r,
           study.study i, study.study ps,
           (SELECT res.source_id, res.profile_type, sl.study_id, res.id,
                   CASE
                     WHEN (s.NAME ='Apicoplast and ER Proteomes')
                       THEN listagg(nvl(to_char(round(res.VALUE, 6)), 'NA'), chr(9)) WITHIN GROUP(ORDER BY pan.node_order_num)
                     ELSE listagg(NVL(TO_CHAR(ROUND(res.value, 2)), 'NA'), CHR(9)) within GROUP(ORDER BY pan.node_order_num)
                   END  AS profile_as_string,
                   max(res.value) AS max_value, min(value) as min_value,
                   max(pan.name) keep(dense_rank last order by value) as max_timepoint,
                   max(pan.name) keep(dense_rank FIRST ORDER BY value) AS min_timepoint
            FROM study.StudyLink sl, study.study s, study.ProtocolAppNode pan,
                 (select distinct sl.study_id
                  from study.studylink sl, PanResults panr
                  where sl.protocol_app_node_id = panr.pan_id
                    and panr.result_table = 'Results::NAFeatureDiffResult') dr,
                 (
                  SELECT DISTINCT
                         'value' AS profile_type,
                         otr.value,
                         otr.ontology_term_id AS id,
                         otr.protocol_app_node_id,
                         ot.name as source_id
                  FROM apidb.OntologyTermResult otr, sres.ontologyterm ot
                  WHERE ot.ontology_term_id = otr.ontology_term_id
                UNION ALL
                  SELECT DISTINCT
                         'values' AS profile_type,
                         value,
                         subject_result_id as id,
                         protocol_app_node_id,
                         subject as source_id
                  FROM apidb.SubjectResult
                UNION ALL
                  SELECT DISTINCT
                         compound_profiles.profile_type,
                         compound_profiles.value,
                         compound_profiles.id,
                         compound_profiles.protocol_app_node_id,
                         CASE
                           WHEN compound_profiles.isotopomer is null
                             THEN ca.source_id
                           ELSE ca.source_id || '|' || compound_profiles.isotopomer
                         END as source_id
                  FROM CompoundAttributes ca,
                       (SELECT DISTINCT
                               'values' AS profile_type,
                               MAX(value) AS value,
                               compound_id AS id,
                               protocol_app_node_id,
                               isotopomer
                        FROM results.CompoundMassSpec
                        GROUP BY compound_id, protocol_app_node_id, isotopomer
                       ) compound_profiles
                  WHERE ca.id = compound_profiles.id
                UNION ALL
                  SELECT DISTINCT
                         compound_profiles.profile_type,
                         compound_profiles.value,
                         compound_profiles.peak_id as id,
                         compound_profiles.protocol_app_node_id,
                         CASE
                           WHEN compound_profiles.isotopomer IS NULL
                             THEN ca.source_id
                           ELSE ca.source_id || '|' || compound_profiles.isotopomer
                         END as source_id
                  FROM CompoundAttributes ca,
                       (SELECT DISTINCT
                               'values' AS profile_type,
                               res.value as value,
                               cpc.compound_id AS id,
                               cpc.compound_peaks_id as peak_id,
                               res.protocol_app_node_id,
                               cpc.isotopomer
                        FROM apidb.CompoundmassSpecResult res, apidb.Compoundpeaks cp,
                             apidb.compoundPeaksChebi cpc, study.ProtocolAppNode pan
                        WHERE cp.compound_peaks_id = res.compound_peaks_id
                          AND cpc.compound_peaks_id = cp.compound_peaks_id
                          AND pan.protocol_app_node_id = res.protocol_app_node_id
                          AND pan.name like '%mean%'
                       ) compound_profiles
                  WHERE ca.id = compound_profiles.id
                 ) res
            WHERE sl.protocol_app_node_id = pan.protocol_app_node_id
              AND pan.protocol_app_node_id = res.protocol_app_node_id
              AND sl.study_id IN (SELECT study_id FROM study.Study WHERE investigation_id IS NOT NULL)
              AND sl.study_id = dr.study_id (+)
              AND sl.study_id = s.study_id
              AND dr.study_id is null
            GROUP BY res.source_id, res.profile_type, sl.study_id, s.name, res.id
           ) profile
      WHERE ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
    UNION ALL
      /* end of non-gene profiles
         HaplotypeResult is broken out into a separate subquery
         because its values are not numbers */
      SELECT DISTINCT
             ds.name AS dataset_name,
             ds.type AS dataset_type,
             ds.subtype AS dataset_subtype,
             profile.profile_type,
             profile.source_id,
             profile.study_id AS profile_study_id,
             ps.name AS profile_set_name,
             cast(case when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                         then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), '.+ - ', '')
                       else null
                  end as varchar2(50))
               as profile_set_suffix,
             profile.profile_as_string,
             profile.max_value,
             profile.min_value,
             profile.max_timepoint,
             profile.min_timepoint
      FROM apidb.DataSource ds, sres.ExternalDatabase d, sres.ExternalDatabaseRelease r,
           study.study i, study.study ps,
           (SELECT res.source_id, res.profile_type, sl.study_id, res.id,
                   listagg(NVL(TO_CHAR(ROUND(res.value, 2)), 'NA'), CHR(9)) within GROUP(ORDER BY pan.node_order_num)
                     AS profile_as_string,
                   cast (null as number(1)) AS max_value,
                   cast (null as number(1)) AS min_value,
                   max(pan.name) keep(dense_rank last order by value) as max_timepoint,
                   max(pan.name) keep(dense_rank first order by value) as min_timepoint
            FROM study.StudyLink sl, study.ProtocolAppNode pan,
                 (select distinct sl.study_id
                  from study.StudyLink sl, panresults panr
                  where sl.protocol_app_node_id = panr.pan_id
                    and panr.result_table = 'Results::NAFeatureDiffResult') dr,
                 (SELECT gene_profiles.*, ga.source_id
                  FROM GeneAttributes ga,
                       (SELECT DISTINCT
                               'value' AS profile_type,
                               value AS value,
                               na_feature_id AS id,
                               protocol_app_node_id
                        FROM apidb.HaplotypeResult
                       ) gene_profiles
                  WHERE gene_profiles.id = ga.na_feature_id
                 ) res
            WHERE sl.protocol_app_node_id = pan.protocol_app_node_id
              AND pan.protocol_app_node_id = res.protocol_app_node_id
              and sl.study_id = dr.study_id (+)
              and dr.study_id is null
            GROUP BY res.source_id, res.profile_type, sl.study_id, res.id
           ) profile
      WHERE ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET dataset_name = 'tbruTREU927_Rijo_Circadian_Regulation_rnaSeq_RSRC'
        WHERE dataset_name= 'tbruTREU927_RNASeq_Rijo_Circadian_Regulation_RSRC'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET profile_as_string = NULL
        WHERE replace(profile_as_string, 'NA' || CHR(9), '') = 'NA'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_ix&1
          on Profile&1 (source_id, profile_type, profile_set_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->


  <tuningTable name="Profile">
    <!-- One profile per gene per dataset. Used for graphs -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="CompoundAttributes"/>
    <externalDependency name="apidb.OntologyTermResult"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="apidb.NaFeatureMetacycle"/>
    <externalDependency name="apidb.LopitResults"/>
    <externalDependency name="apidb.EigenGeneWgcnaResults"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
               create table Profile&1 (
               DATASET_NAME	        VARCHAR2(200),
               DATASET_TYPE	        VARCHAR2(50),
               DATASET_SUBTYPE	        VARCHAR2(50),
               PROFILE_TYPE	        VARCHAR2(30),
               SOURCE_ID	        VARCHAR2(500),
               PROFILE_STUDY_ID	        NUMBER(7),
               PROFILE_SET_NAME	        VARCHAR2(400),
               PROFILE_SET_SUFFIX	VARCHAR2(50),
               PROFILE_AS_STRING	VARCHAR2(4000),
               MAX_VALUE	        NUMBER,
               MIN_VALUE	        NUMBER,
               MAX_TIMEPOINT	        VARCHAR2(200),
               MIN_TIMEPOINT	        VARCHAR2(200)
               )
      ]]>
    </sql>
    <sql>
      <![CDATA[
 declare
  ctrows number := 0;
  commit_after number := 10000;
 BEGIN
  FOR pf_rows IN (
  SELECT
         ds.name as dataset_name, ds.type as dataset_type,
         ds.subtype as dataset_subtype, profile.profile_type,
         profile.source_id, profile.study_id as profile_study_id,
         ps.name as profile_set_name,
         cast(case
                when regexp_replace(ps.name, '\[.+\]', '') like '% - %' 
                  then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                -- special cases for legacy datasets
                when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%' 
                  then regexp_replace(
                           regexp_replace(
                               regexp_replace(
                                   regexp_replace(
                                       regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                  '\[.+ unique\]', ' - unique'),
                                              '\[.+\]', ''),
                                          'aligned with cds coordinates ', 'cds coordinates'),
                                      'T.brucei paired end RNA-Seqdata from Horn ', '')
                else null
              end as varchar2(50)
             ) as profile_set_suffix,
         CASE WHEN replace(profile.profile_as_string, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string END as profile_as_string, 
         profile.max_value, profile.min_value,
         profile.max_timepoint, profile.min_timepoint 
  from apidb.DataSource ds, sres.ExternalDatabase d,
       sres.ExternalDatabaseRelease r, study.Study ps, study.Study i,
       (
        -- gene profiles
        select gene_profile.study_id, ga.source_id, gene_profile.profile_type,
               gene_profile.profile_as_string, gene_profile.max_value, gene_profile.min_value,
               gene_profile.max_timepoint, gene_profile.min_timepoint
        from GeneAttributes ga,
             (  select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.value) as max_value, min(result.value) as min_value,
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     (select na_feature_id, protocol_app_node_id, max(value) as value
                      from results.NaFeatureHostResponse
                      group by na_feature_id, protocol_app_node_id) result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.mean_phenotype, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.mean_phenotype) as max_value, min(result.mean_phenotype) as min_value,
                       max(pan.name) keep(dense_rank last order by result.mean_phenotype) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.mean_phenotype) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.CrisprPhenotype result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.score, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.score) as max_value, min(result.score) as min_value,
                       max(pan.name) keep(dense_rank last order by result.score) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.score) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.PhenotypeScore result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.relative_growth_rate, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.relative_growth_rate) as max_value, min(result.relative_growth_rate) as min_value,
                       max(pan.name) keep(dense_rank last order by result.relative_growth_rate) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.relative_growth_rate) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.PhenotypeGrowthRate result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.value) as max_value, min(result.value) as min_value,
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     results.NaFeatureExpression result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'channel1_percentiles' as profile_type,
                       listagg(nvl(to_char(round(result.percentile_channel1, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.percentile_channel1) as max_value, min(result.percentile_channel1) as min_value,
                       max(pan.name) keep(dense_rank last order by result.percentile_channel1) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.percentile_channel1) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     results.NaFeatureExpression result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'channel2_percentiles' as profile_type,
                       listagg(nvl(to_char(round(result.percentile_channel2, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.percentile_channel2) as max_value, min(result.percentile_channel2) as min_value,
                       max(pan.name) keep(dense_rank last order by result.percentile_channel2) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.percentile_channel2) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     results.NaFeatureExpression result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'standard_error' as profile_type,
                       listagg(nvl(to_char(round(result.standard_error, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.standard_error) as max_value, min(result.standard_error) as min_value,
                       max(pan.name) keep(dense_rank last order by result.standard_error) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.standard_error) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     results.NaFeatureExpression result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'pvalue' as profile_type,
                       listagg(nvl(to_char(round(result.pvalue, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.pvalue) as max_value, min(result.pvalue) as min_value,
                       max(pan.name) keep(dense_rank last order by result.pvalue) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.pvalue) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.NaFeatureMetacycle result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'amplitude' as profile_type,
                       listagg(nvl(to_char(round(result.amplitude, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.amplitude) as max_value, min(result.amplitude) as min_value,
                       max(pan.name) keep(dense_rank last order by result.amplitude) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.amplitude) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.NaFeatureMetacycle result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
                select sl.study_id, result.na_feature_id, 'period' as profile_type,
                       listagg(nvl(to_char(round(result.period, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       to_number(max(result.period)) as max_value, to_number(min(result.period)) as min_value,
                       max(pan.name) keep(dense_rank last order by result.period) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.period) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.NaFeatureMetacycle result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
              UNION ALL
	      select sl.study_id, lr.na_feature_id, 'probability_mean' as profile_type,                                    
	             listagg(nvl(to_char(round(lr.probability_mean, 2)), 'NA'), chr(9))           
		       within group (order by pan.node_order_num)                                                                 
		       as profile_as_string,                                                                                      
                     max(lr.probability_mean) as max_value, min(lr.probability_mean) as min_value,                             
		     max(pan.name) keep(dense_rank last order by lr.probability_mean) as max_timepoint,         
		     max(pan.name) keep(dense_rank first order BY lr.probability_mean) as min_timepoint                        
	      from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,                                                  
                   apidb.LopitResults lr                                                                            
		   where lr.protocol_app_node_id = sl.protocol_app_node_id                                                  
		     and lr.protocol_app_node_id = pan.protocol_app_node_id                                                   
                     and sl.study_id = s.study_id                                                                                 
                     and s.investigation_id is not null                                                                           
                group by sl.study_id, lr.na_feature_id   
              UNION ALL
	      select sl.study_id, lr.na_feature_id, 'sd' as profile_type,                                    
	             listagg(nvl(to_char(round(lr.sd, 2)), 'NA'), chr(9))           
		       within group (order by pan.node_order_num)                                                                 
		       as profile_as_string,                                                                                      
                     max(lr.sd) as max_value, min(lr.sd) as min_value,                             
		     max(pan.name) keep(dense_rank last order by lr.sd) as max_timepoint,         
		     max(pan.name) keep(dense_rank first order BY lr.sd) as min_timepoint                        
	      from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,                                                  
                   apidb.LopitResults lr                                                                            
		   where lr.protocol_app_node_id = sl.protocol_app_node_id                                                  
		     and lr.protocol_app_node_id = pan.protocol_app_node_id                                                   
                     and sl.study_id = s.study_id                                                                                 
                     and s.investigation_id is not null                                                                           
                group by sl.study_id, lr.na_feature_id   
              UNION ALL
	      select sl.study_id, lr.na_feature_id, 'lower_CI' as profile_type,                                    
	             listagg(nvl(to_char(round(lr.lower_CI, 2)), 'NA'), chr(9))           
		       within group (order by pan.node_order_num)                                                                 
		       as profile_as_string,                                                                                      
                     max(lr.lower_CI) as max_value, min(lr.lower_CI) as min_value,                             
		     max(pan.name) keep(dense_rank last order by lr.lower_CI) as max_timepoint,         
		     max(pan.name) keep(dense_rank first order BY lr.lower_CI) as min_timepoint                        
	      from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,                                                  
                   apidb.LopitResults lr                                                                            
		   where lr.protocol_app_node_id = sl.protocol_app_node_id                                                  
		     and lr.protocol_app_node_id = pan.protocol_app_node_id                                                   
                     and sl.study_id = s.study_id                                                                                 
                     and s.investigation_id is not null                                                                           
                group by sl.study_id, lr.na_feature_id   
              UNION ALL
	      select sl.study_id, lr.na_feature_id, 'upper_CI' as profile_type,                                    
	             listagg(nvl(to_char(round(lr.upper_CI, 2)), 'NA'), chr(9))           
		       within group (order by pan.node_order_num)                                                                 
		       as profile_as_string,                                                                                      
                     max(lr.upper_CI) as max_value, min(lr.upper_CI) as min_value,                             
		     max(pan.name) keep(dense_rank last order by lr.upper_CI) as max_timepoint,         
		     max(pan.name) keep(dense_rank first order BY lr.upper_CI) as min_timepoint                        
	      from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,                                                  
                   apidb.LopitResults lr                                                                            
		   where lr.protocol_app_node_id = sl.protocol_app_node_id                                                  
		     and lr.protocol_app_node_id = pan.protocol_app_node_id                                                   
                     and sl.study_id = s.study_id                                                                                 
                     and s.investigation_id is not null                                                                           
                group by sl.study_id, lr.na_feature_id   

              UNION ALL
                select sl.study_id, result.na_feature_id, 'values' as profile_type,
                       listagg(nvl(result.value, 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       cast (null as number) as max_value,
                       cast (null as number) as min_value,
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.HaplotypeResult result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.na_feature_id
               ) gene_profile
        where ga.na_feature_id = gene_profile.na_feature_id
      UNION ALL
        -- compound profiles
        select compound_profile.study_id, 
               case
                 WHEN compound_profile.isotopomer IS NOT NULL
                    THEN ca.source_id || '|' || compound_profile.isotopomer
                 WHEN compound_profile.mass IS NOT NULL
                    THEN ca.source_id || '|' || compound_profile.mass || '|' || compound_profile.retention_time
                 ELSE ca.source_id
               END as source_id,
               compound_profile.profile_type,
               compound_profile.profile_as_string, compound_profile.max_value, compound_profile.min_value,
               compound_profile.max_timepoint, compound_profile.min_timepoint
        from CompoundAttributes ca,
             (  select sl.study_id, result.compound_id, result.isotopomer, 'values' as profile_type,
                       NULL as compound_peaks_id, NULL as mass, NULL as retention_time,
                       listagg(nvl(to_char(round(result.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.value) as max_value, min(result.value) as min_value,
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     (select max(value) as value, compound_id, protocol_app_node_id, isotopomer
                      from results.CompoundMassSpec
                      group by compound_id, protocol_app_node_id, isotopomer
                     ) result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.compound_id, result.isotopomer
              UNION ALL
                select sl.study_id, cpc.compound_id, cpc.isotopomer, 'values' as profile_type,
                       cpc.compound_peaks_id, cp.mass, cp.retention_time,
                       listagg(nvl(to_char(round(cmsr.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(cmsr.value) as max_value, min(cmsr.value) as min_value,
                       max(pan.name) keep(dense_rank last order by cmsr.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY cmsr.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.CompoundMassSpecResult cmsr, apidb.Compoundpeaks cp,
                     apidb.CompoundPeaksChebi cpc
                     where cmsr.protocol_app_node_id = sl.protocol_app_node_id
                       and cmsr.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                       and cp.compound_peaks_id = cmsr.compound_peaks_id
                       and cpc.compound_peaks_id = cp.compound_peaks_id
                       and pan.name like '%mean%'
                group by sl.study_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time
              UNION ALL
                select sl.study_id, cpc.compound_id, cpc.isotopomer, 'percentiles' as profile_type,
                    cpc.compound_peaks_id, cp.mass, cp.retention_time,
                    listagg(nvl(to_char(round(cmsr.percentile, 2)), 'NA'), chr(9))
                        within group (order by pan.node_order_num) as profile_as_string,
                    max(cmsr.percentile) as max_value, min(cmsr.percentile) as min_value,
                    max(pan.name) keep(dense_rank last order by cmsr.value) as max_timepoint,
                    max(pan.name) keep(dense_rank first order BY cmsr.value) as min_timepoint
                from study.protocolAppNode pan, study.studylink sl, study.study s,
                    apidb.compoundmassspecresult cmsr, apidb.compoundpeaks cp,
                    apidb.compoundpeakschebi cpc
                where cmsr.protocol_app_node_id = sl.protocol_app_node_id
                    and cmsr.protocol_app_node_id = pan.protocol_app_node_id
                    and sl.study_id = s.study_id
                    and s.investigation_id is not null
                    and cp.compound_peaks_id = cmsr.compound_peaks_id
                    and cpc.compound_peaks_id = cp.compound_peaks_id
                    and pan.name like '%mean%'
                group by sl.study_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time
             ) compound_profile
        where ca.id = compound_profile.compound_id
      UNION ALL
        -- OntologyTermResult
        select sl.study_id, ot.name as source_id, 'value' as profile_type,
               listagg(nvl(to_char(round(otr.value, 2)), 'NA'), chr(9))
                 within group (order by pan.node_order_num)
                 as profile_as_string,
               max(otr.value) as max_value, min(otr.value) as min_value,
               max(pan.name) keep(dense_rank last order by otr.value) as max_timepoint,
               max(pan.name) keep(dense_rank first order BY otr.value) as min_timepoint
        from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
             apidb.OntologyTermResult otr, sres.OntologyTerm ot
        where ot.ontology_term_id = otr.ontology_term_id
          and otr.protocol_app_node_id = sl.protocol_app_node_id
          and otr.protocol_app_node_id = pan.protocol_app_node_id
          and sl.study_id = s.study_id
          and s.investigation_id is not null
        group by sl.study_id, ot.name
      UNION ALL
        -- SubjectResult
        select sl.study_id, result.subject as source_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string,
                       max(result.value) as max_value, min(result.value) as min_value,
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint,
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.SubjectResult result
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.subject
        UNION ALL
        -- wgcna eigengene results
               select sl.study_id, result.module_name as source_id, 'values' as profile_type,
                       listagg(nvl(to_char(round(result.value, 2)), 'NA'), chr(9))
                         within group (order by pan.node_order_num)
                         as profile_as_string, 
                       max(result.value) as max_value, min(result.value) as min_value, 
                       max(pan.name) keep(dense_rank last order by result.value) as max_timepoint, 
                       max(pan.name) keep(dense_rank first order BY result.value) as min_timepoint
                from study.ProtocolAppNode pan, study.StudyLink sl, study.Study s,
                     apidb.EigenGeneWgcnaResults result 
                     where result.protocol_app_node_id = sl.protocol_app_node_id
                       and result.protocol_app_node_id = pan.protocol_app_node_id
                       and sl.study_id = s.study_id
                       and s.investigation_id is not null
                group by sl.study_id, result.module_name
       ) profile
  where ds.name = d.name
    and ps.investigation_id = i.study_id
    and ds.version = r.version
    and d.external_database_id = r.external_database_id
    and r.external_database_release_id = i.external_database_release_id
    and i.investigation_id is null
    and profile.study_id = ps.study_id
    )
  LOOP
    ctrows := ctrows + 1;
    insert into Profile&1 nologging
        (DATASET_NAME, DATASET_TYPE, DATASET_SUBTYPE, PROFILE_TYPE, SOURCE_ID, PROFILE_STUDY_ID, PROFILE_SET_NAME, 
        PROFILE_SET_SUFFIX, PROFILE_AS_STRING, MAX_VALUE, MIN_VALUE, MAX_TIMEPOINT, MIN_TIMEPOINT) 
        values
        (pf_rows.DATASET_NAME, pf_rows.DATASET_TYPE, pf_rows.DATASET_SUBTYPE, pf_rows.PROFILE_TYPE, pf_rows.SOURCE_ID, pf_rows.PROFILE_STUDY_ID, pf_rows.PROFILE_SET_NAME, 
        pf_rows.PROFILE_SET_SUFFIX, pf_rows.PROFILE_AS_STRING, pf_rows.MAX_VALUE, pf_rows.MIN_VALUE, pf_rows.MAX_TIMEPOINT, pf_rows.MIN_TIMEPOINT);
    IF ctrows >= commit_after
      THEN
         COMMIT;  
         ctrows := 0;  
    END IF;  
    END LOOP;
  commit;
  END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_idx&1
          on Profile&1 (source_id, profile_type, profile_set_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index profset_idx&1
          on Profile&1 (profile_set_name, profile_type)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index srcdset_idx&1
          on Profile&1 (source_id, dataset_subtype, dataset_type) 
        tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET dataset_name = 'tbruTREU927_Rijo_Circadian_Regulation_rnaSeq_RSRC'
        WHERE dataset_name= 'tbruTREU927_RNASeq_Rijo_Circadian_Regulation_RSRC'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileType">
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProfileType&1 nologging AS
	SELECT DISTINCT dataset_name, profile_study_id, profile_set_name, profile_set_suffix, profile_type, 
	       dataset_type, dataset_subtype
	FROM profile
	WHERE profile_as_string IS NOT NULL
	ORDER BY  dataset_name, profile_set_name,  profile_type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileSamples">
    <internalDependency name="ProfileType"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      CREATE TABLE ProfileSamples&1 nologging AS
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.nafeatureexpression r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id
	AND pt.profile_type not in ('pvalue', 'period', 'amplitude', 'probability_mean','sd','lower_CI','upper_CI','correlation_coefficient')
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
          REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
          pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
          pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
        FROM profileType pt, study.study s, study.studyLink sl, 
          study.protocolAppNode pan, apidb.NAFeatureMetacycle r
        WHERE pt.profile_study_id = s.study_id
        AND sl.study_id = s.study_id
        AND sl.protocol_app_node_id = pan.protocol_app_node_id
        AND  pan.protocol_app_node_id =r.protocol_app_node_id
        AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
          REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
          pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
          pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
        FROM profileType pt, study.study s, study.studyLink sl, 
          study.protocolAppNode pan, apidb.LopitResults r
        WHERE pt.profile_study_id = s.study_id
        AND sl.study_id = s.study_id
        AND sl.protocol_app_node_id = pan.protocol_app_node_id
        AND  pan.protocol_app_node_id =r.protocol_app_node_id
        AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')

      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.compoundMassSpec r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
    SELECT DISTINCT s.name AS study_name, s.study_id,                                                                                                                                                  
          REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
          pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
          pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
        FROM profileType pt, study.study s, study.studyLink sl, 
          study.protocolAppNode pan, APIDB.compoundmassspecresult r
        WHERE pt.profile_study_id = s.study_id
        AND sl.study_id = s.study_id
        AND sl.protocol_app_node_id = pan.protocol_app_node_id
        AND  pan.protocol_app_node_id =r.protocol_app_node_id
        and pan.name like '%mean%'
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, apidb.ontologytermresult r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.nafeaturehostresponse r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl,
	  study.protocolAppNode pan, apidb.crisprphenotype r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl,
	  study.protocolAppNode pan, apidb.phenotypescore r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl,
	  study.protocolAppNode pan, apidb.phenotypegrowthrate r
	WHERE pt.profile_study_id = s.study_id
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id
      UNION
        SELECT DISTINCT s.name AS study_name, s.study_id, 
          REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
          pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
          pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
        FROM profileType pt, study.study s, study.studyLink sl,
          study.protocolAppNode pan, apidb.subjectresult r
        WHERE pt.profile_study_id = s.study_id
        AND sl.study_id = s.study_id
        AND sl.protocol_app_node_id = pan.protocol_app_node_id
        AND  pan.protocol_app_node_id =r.protocol_app_node_id
      UNION
        SELECT DISTINCT s.name AS study_name, s.study_id, 
          REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
          pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
          pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
        FROM profileType pt, study.study s, study.studyLink sl,
          study.protocolAppNode pan, apidb.EigenGeneWgcnaResults r
        WHERE pt.profile_study_id = s.study_id
        AND sl.study_id = s.study_id
        AND sl.protocol_app_node_id = pan.protocol_app_node_id
        AND  pan.protocol_app_node_id =r.protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psamp_ix&1
          on ProfileSamples&1
            (dataset_name, profile_type, study_id, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_name,
             protocol_app_node_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psampstdy_ix&1
          on ProfileSamples&1
            (study_name, profile_type, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_id,
             protocol_app_node_name, dataset_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="GeneGroupProfile">
    <comment> For all datasets, list all genes (source_id) of a gene_group where one of them (profile_graph_id) 
              has data for a profile_set. 
    </comment>      
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <internalDependency name="OrthologousTranscripts"/>
    <sql>
      <![CDATA[
        create table GeneGroupProfile&1 nologging as
          select distinct other_gene.source_id, p.dataset_name,
               this_gene.source_id as profile_graph_id
          from OrthologousTranscripts ot
             , Profile p
             , GeneAttributes this_gene
             , GeneAttributes other_gene
          where p.source_id = ot.source_id
            and ot.source_id = this_gene.source_id
            and ot.ortho_gene_source_id = other_gene.source_id
            and this_gene.species = other_gene.species
            and ot.is_syntenic = 1
        union
          select ga.source_id, p.dataset_name, p.source_id as profile_graph_id
          from Profile p, GeneAttributes ga
          where p.source_id = ga.source_id
    ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ggp_ix&1
          on GeneGroupProfile&1
            (source_id, dataset_name, profile_graph_id)
        tablespace indx
    ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExpressionGraphsData">
    <comment>
       for gene-page expression graphs
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ProfileSamples"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExpressionGraphsData&1 NOLOGGING  as
          -- RNASeq
          select distinct ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast(case when ps.profile_set_suffix is null then ps.protocol_app_node_name
                          when ps.protocol_app_node_name ='value' then ps.profile_set_suffix 
                          else ps.protocol_app_node_name || ' - ' || ps.profile_set_suffix end ||
                      case when to_char(substr(dp.value, 1, 10)) in ('0', 'false') and pan.name like '% firststrand %' then '- sense' 
                           when to_char(substr(dp.value, 1, 10)) in ('0', 'false') and pan.name like '% secondstrand %' then '- antisense' 
                           when to_char(substr(dp.value, 1, 10)) in ('1', 'true') and pan.name like '% firststrand %' then '- antisense' 
                           when to_char(substr(dp.value, 1, 10)) in ('1', 'true') and pan.name like '% secondstrand %' then '- sense' 
                           else '' end ||
                      case when pan.name like '% unique%' then ' - unique' 
                           else '' end
                       as varchar2(300)) AS sample_name,
                 round(nfe.value, 2) as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetPresenter dnt, DatasetProperty dp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and ps.dataset_name = dnt.name
            and dnt.dataset_presenter_id = dp.dataset_presenter_id
            and dp.property = 'switchStrandsProfiles'
            and ps.study_name not like '%cuff%'
            and ps.study_name not like '%htseq-intersection-nonempty%'
            and ps.study_name not like '%htseq-intersection-strict%'
        UNION
          -- Splice Site data
          select ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                            else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                        end as varchar2(300)) AS sample_name,
                 round(nfe.value, 2) as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt,DatasetProperty dp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and d.name = dnt.name
            and dnt.dataset_presenter_id = dp.dataset_presenter_id
            and dp.property = 'type' and to_char(substr(dp.value, 1, 10)) = 'Splice Site'
        UNION
          -- microarray expression, quantitative proteomics, and eQTL
          select ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                             else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                       end as varchar2(300)) AS sample_name,
                 CASE WHEN (d.NAME ='pfal3D7_quantitativeMassSpec_Apicoplast_ER_RSRC') THEN round(nfe.VALUE, 6) 
                    ELSE round(nfe.value, 2)END as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt, DatasetPresenter dsp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and d.name = dnt.name
            and dnt.dataset_presenter_id = dsp.dataset_presenter_id
            and dsp.subtype != 'rnaseq'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edg_ix&1
          on ExpressionGraphsData&1
            (source_id, dataset_id, sample_name, value, standard_error, percentile_channel1, percentile_channel2)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Taxonomy">
    <comment>
       For each distinct organism in GeneAttributes, all ancestors in the taxon tree. For the gene page.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE Taxonomy&1 NOLOGGING as
          SELECT tax.*, 
                   CONNECT_BY_ROOT name AS organism,
                   rownum orderNum
            FROM (SELECT t.taxon_id, t.parent_id, t.ncbi_tax_id,
                         cast(tn.name as varchar2(80)) as name,
                         cast(t.rank as varchar2(24)) as rank
                  FROM sres.Taxon t, sres.TaxonName tn
                  WHERE t.taxon_id = tn.taxon_id
                    AND tn.name_class = 'scientific name'
                 ) tax
            WHERE tax.name != 'root'
            START WITH name IN (SELECT DISTINCT organism FROM GeneAttributes)
            CONNECT BY prior parent_id = taxon_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tax_ix&1
          on Taxonomy&1
            (organism, ordernum, taxon_id, parent_id, ncbi_tax_id, name, rank)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneModelDump">
    <comment>
       Materialization of GeneTables.GeneModelDump.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneModelDump&1 NOLOGGING as
         SELECT source_id, project_id, sequence_id, gm_start,gm_end, type, is_reversed,
  listagg(transcript_id, ',') within GROUP(ORDER BY transcript_id) AS transcript_ids
 from ( select distinct ta.source_id as transcript_id, ta.gene_source_id as source_id, '@PROJECT_ID@' as project_id,
                ta.sequence_id,gm.start_min as gm_start, gm.end_max as gm_end,
                gm.type, gl.is_reversed
         from
              apidb.FeatureLocation gl, dots.NaSequence s,
              TranscriptAttributes ta,
              (select  decode(el.feature_type,'ExonFeature','Exon',el.feature_type) as type, el.parent_id as na_feature_id,
                       el.start_min as start_min , el.end_max as end_max
               from apidb.FeatureLocation el
               where el.feature_type in  ('ExonFeature','five_prime_UTR', 'three_prime_UTR','CDS','Intron')
               and el.is_top_level = 1
              ) gm
         where gm.na_feature_id = ta.na_feature_id
         and s.na_sequence_id = gl.na_sequence_id
         and ta.na_feature_id = gl.na_feature_id
         and gl.is_top_level = 1
         )
         group by source_id, project_id, sequence_id,
                 gm_start,  gm_end,
                type, is_reversed
         order by case when is_reversed = 1 then -1 * gm_start else gm_start end
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gmd_ix&1
          on GeneModelDump&1
            (source_id, project_id, sequence_id, gm_start, gm_end, is_reversed, type, transcript_ids)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="RflpGenotypes">
    <comment>
       Ordered list of distinct genotypes for each protocol_app_node_id in apidb.RflpGenotypes
    </comment>
    <externalDependency name="apidb.RflpGenotype"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        create table RflpGenotypes&1 nologging as
        select sd.protocol_app_node_id, sd.output_pan_id,
               cast (listagg(genotype, ', ') within group (order by genotype) as varchar2(80)) as genotypes
        from (select distinct genotype, protocol_app_node_id from apidb.RflpGenotype) rg,
             SampleProcess sd
        where sd.output_pan_id = rg.protocol_app_node_id
        group by sd.protocol_app_node_id, sd.output_pan_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index rflpG_ix&1
          on RflpGenotypes&1
            (protocol_app_node_id, output_pan_id, genotypes)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneSummaryFilter">
    <comment>
       Distinct filter_name for gene query summary. For the initial version,
       at least, it's (GeneAttriutes.species UNION GeneAttributes.organism).
       Note that the UNION implies set bahavior and therefore distinctness.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneSummaryFilter&1 NOLOGGING AS
        SELECT CAST(filter_name AS VARCHAR2(80)) AS filter_name
        FROM (SELECT species as filter_name
              FROM GeneAttributes
            UNION
              SELECT organism as filter_name
              FROM GeneAttributes)
       ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AaSequenceInfo">
    <comment>
       Info from dots.ExternalAaSequence records for BLAT alignments
    </comment>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <sql>
      <![CDATA[
        CREATE TABLE AaSequenceInfo&1 NOLOGGING AS
        SELECT aa_sequence_id, source_id,
               CAST(description AS VARCHAR2(300)) AS description
        FROM dots.ExternalAaSequence
        WHERE aa_sequence_id IN (SELECT query_aa_sequence_id
                                 FROM apidb.BlatProteinAlignment)
        ORDER by aa_sequence_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX aaSeqInf_ix&1
          ON AaSequenceInfo&1 (aa_sequence_id, source_id, description)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologousTranscripts">
    <comment>
       Materialization of the orthology transform. Also useful for GeneTables.Orthologs.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.SyntenicGene"/>
    <externalDependency name="apidb.Organism"/>
    <intermediateTable name="SyntenicPairs"/>
    <sql>
      <![CDATA[
         create table SyntenicPairs as
         select distinct ga.na_feature_id, sg.syn_na_feature_id
         from apidb.SyntenicGene sg, GeneAttributes ga
         where sg.na_sequence_id = ga.na_sequence_id
           and sg.end_max >= ga.start_min
           and sg.start_min <= ga.end_max
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SynPair_idx&1
          on SyntenicPairs (na_feature_id, syn_na_feature_id)
          tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create table OrthologousTranscripts&1 as 
with all_pairs
     as (select ga.source_id
              , ga.project_id
              , ga.na_feature_id
              , ota.source_id as ortho_source_id
              , ota.gene_source_id as ortho_gene_source_id
              , ota.project_id as ortho_project_id
              , ota.gene_na_feature_id as ortho_na_feature_id
              , ota.transcript_product as ortho_product
              , ga.name as ortho_name
              , ota.organism as ortho_organism
              , ota.taxon_id as ortho_taxon_id
              , o.is_reference_strain
         from Geneattributes ga
            , TranscriptAttributes ota
            , apidb.Organism o
         where ga.ORTHOMCL_NAME = ota.ORTHOMCL_NAME
         and ota.taxon_id = o.taxon_id
         ),
     syn_pairs
     as (select na_feature_id, syn_na_feature_id, 1 as is_syntenic
         from SyntenicPairs
        )
select all_pairs.*
     , nvl(syn_pairs.is_syntenic, 0) as is_syntenic
from all_pairs
     left join syn_pairs
     on all_pairs.na_feature_id = syn_pairs.na_feature_id 
        and all_pairs.ortho_na_feature_id = syn_pairs.syn_na_feature_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ot_idx&1
          on OrthologousTranscripts&1 (source_id, project_id, is_syntenic desc, ortho_source_id,
                                       ortho_project_id, ortho_gene_source_id, ortho_product,
                                       ortho_name, ortho_organism, ortho_taxon_id, is_reference_strain)
          tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ot_smol_idx&1
          on OrthologousTranscripts&1 (is_syntenic, ortho_taxon_id, source_id, ortho_source_id,
                                       ortho_project_id, ortho_gene_source_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetGeneList">
    <comment>
    For each RNA-Seq Dataset, compute the top 500 ratios of max/min gene expression.
    </comment>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE DatasetGeneList&1 AS
          SELECT source_id, organism, orthomcl_name, profile_study_id, dataset_name, dataset_presenter_id,
            fdiff, fdiff_abs, min_value, min_timepoint, max_value, max_timepoint,
            row_number() OVER (PARTITION BY dataset_name,profile_study_id order by fdiff_abs DESC) AS myrow
          FROM
            (SELECT p.source_id, ga.organism, ga.orthomcl_name, p.profile_study_id, p.dataset_name
              , dp.dataset_presenter_id 
              , ROUND ( max_value / CASE WHEN min_value < 1 THEN 1 ELSE min_value END,2) AS fdiff
              , ABS (ROUND ( max_value / CASE WHEN min_value < 1 THEN 1 ELSE min_value END,2)) AS fdiff_abs
              , ROUND (p.min_value, 2) as min_value 
              , REGEXP_REPLACE (p.min_timepoint, ' \[.+\] \(.+\)', '') as min_timepoint
              , ROUND( p.max_value, 2) as max_value
              , REGEXP_REPLACE (p.max_timepoint, ' \[.+\] \(.+\)', '') as max_timepoint
            FROM Profile p, DatasetPresenter dp, DatasetProperty dprop, GeneAttributes ga
            WHERE p.dataset_type        = 'transcript_expression'
            AND p.dataset_subtype       = 'rnaseq'
            AND p.profile_type          = 'values'
            AND p.dataset_name          = dp.NAME
            AND dp.dataset_presenter_id = dprop.dataset_presenter_id
	    AND p.profile_set_name like '%- unique]'
            AND property                = 'switchStrandsProfiles'
            AND ((to_char(substr(dprop.value, 1, 10)) = 'false' AND p.min_timepoint LIKE '%firststrand%')
              OR (to_char(substr(dprop.value, 1, 10)) = 'true' AND p.min_timepoint LIKE '%secondstrand%')
              OR (p.min_timepoint LIKE '%unstranded%'))
            AND p.source_id = ga.source_id
            )
          ORDER BY DATASET_NAME, profile_study_id, fdiff_abs DESC
       ]]>
    </sql>

    <sql>
      <![CDATA[
create index DsGl_source_id_idx&1 ON DatasetGeneList&1 (source_id,organism)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
create index DsGl_omcl_nme_idx&1 ON DatasetGeneList&1 (orthomcl_name,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="RodMalPhenotype">
    <comment>
      for GeneTables.RodMalPhenotypeTable
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.NaFeaturePhenotypeModel"/>
    <externalDependency name="apidb.PhenotypeModel"/>
    <externalDependency name="apidb.PhenotypeResult"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE RodMalPhenotype&1 NOLOGGING AS
        WITH mut
             AS (SELECT DISTINCT ga.source_id, ga.project_id, pm.source_id as rmgmid,
                                 pm.pubmed_id, pm.modification_type as mod_type,
                                 pm.is_successful as suc_of_gen_mod,
                                 pm.mutation_description, ot.name,
                                 DBMS_LOB.SUBSTR(pr.phenotype_post_composition, 4000, 1) as phenotype1,
                                 DBMS_LOB.SUBSTR(pr.phenotype_post_composition, 4000, 4001) as phenotype2,
                                 pm.has_multiple_mutations AS multiple, na.NA_FEATURE_ID as id,
                                 pm.phenotype_model_id
                 FROM apidb.PhenotypeResult pr
                      LEFT OUTER JOIN sres.OntologyTerm ot
                        ON pr.life_cycle_stage_term_id = ot.ontology_term_id,
                      apidb.PhenotypeModel pm, GeneAttributes ga,
                      apidb.NaFeaturePhenotypeModel na
                 WHERE pm.phenotype_model_id = pr.phenotype_model_id
                   AND na.phenotype_model_id = pm.phenotype_model_id
                   AND na.na_feature_id = ga.na_feature_id
                ),
             knockdown
             AS (SELECT DISTINCT genes.source_id, mods.phenotype_model_id as model_id
                 FROM apidb.PhenotypeModel mods, apidb.NaFeaturePhenotypeModel nod,
                      GeneAttributes genes, mut m
                 WHERE mods.phenotype_model_id = m.phenotype_model_id
                   AND m.phenotype_model_id = nod.phenotype_model_id
                   AND mods.phenotype_model_id = nod.phenotype_model_id
                   AND m.id != nod.na_feature_id
                   AND genes.na_feature_id = nod.na_feature_id
                   AND m.source_id != genes.source_id
                -- AND mods.has_multiple_mutations = 1
                ),
             results
             AS (SELECT CAST (m.source_id AS VARCHAR2(30)) AS source_id,
                    --  m.project_id,
                        CAST (m.rmgmid AS VARCHAR2(12)) AS rmgmid, m.pubmed_id,
                        CAST (m.mod_type AS VARCHAR2(20)) as mod_type,
                        CASE
                          WHEN m.suc_of_gen_mod = 0
                            THEN 'NO'
                          ELSE 'YES'
                        END AS suc_of_gen_mod,
                        CAST(m.mutation_description AS VARCHAR2(150)) AS mutation_description,
                        CAST(LISTAGG(m.name, ', ') WITHIN GROUP (ORDER BY m.name)
                             AS VARCHAR2(250)) AS life_cycle_stage,
                        CONCAT(TO_CLOB(phenotype1), TO_CLOB(phenotype2)) AS phenotype,
                        m.phenotype_model_id
                 FROM mut m
                 GROUP BY m.source_id, m.project_id, m.rmgmid, m.pubmed_id, m.mod_type,
                          m.suc_of_gen_mod, m.mutation_description, m.phenotype1,
                          m.phenotype2,m.phenotype_model_id
                )
        SELECT results.*,
               CAST(knockdown.source_id AS VARCHAR2(30)) as other_source_id
        FROM results
             LEFT JOIN knockdown ON results.phenotype_model_id = knockdown.model_id
        WHERE knockdown.source_id <> results.source_id
           OR knockdown.source_id is null
        ORDER BY results.source_id, results.rmgmid
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX RodMal_ix&1
        ON RodMalPhenotype&1(source_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChrCopyNumbers">
    <comment>Chromosome data for CNV queries</comment>
    <internalDependency name="PANIO"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <sql>
        <![CDATA[
            CREATE TABLE ChrCopyNumbers&1 NOLOGGING AS
                SELECT DISTINCT ta.na_sequence_id
                , ta.chromosome
                , ccn.chr_copy_number AS ploidy
                , io.input_pan_id
                , io.output_pan_id
                FROM apidb.ChrCopyNumber ccn
                , TranscriptAttributes ta
                ,  PANIo io
                WHERE ta.na_sequence_id = ccn.na_sequence_id
                AND ta.chromosome IS NOT NULL
                AND ccn.protocol_app_node_id = io.output_pan_id
        ]]>
    </sql>
    <sql>
        <![CDATA[
        CREATE INDEX ChrCN_ix&1
        ON ChrCopyNumbers&1(input_pan_id, na_sequence_id)
        TABLESPACE indx
        ]]>
    </sql>
    <sql>
        <![CDATA[
        CREATE INDEX ChrCN_output&1
        ON ChrCopyNumbers&1(output_pan_id)
        TABLESPACE indx
        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneCopyNumbers">
    <comment>Gene Data for CNV queries</comment>
    <internalDependency name="PANIO"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
        <![CDATA[
            CREATE TABLE GeneCopyNumbers&1 NOLOGGING AS
                SELECT DISTINCT ta.project_id
                , ta.source_id
                , ta.gene_source_id
                , REGEXP_REPLACE(pan.name, '_[A-Za-z0-9]+ (.+)$', '') AS strain
                , gcn.haploid_number AS raw_estimate
                , gcn.ref_copy_number AS ref_cn
                , CASE WHEN (gcn.haploid_number < 0.01) THEN 0
                    WHEN (0.01 < gcn.haploid_number AND gcn.haploid_number < 1.85) THEN 1
                    ELSE round(gcn.haploid_number) END AS haploid_number
                , ta.chromosome
                , ta.na_sequence_id
                , io.input_pan_id
                , io.output_pan_id
                FROM apidb.genecopynumber gcn
                , study.protocolappnode pan
                , TranscriptAttributes ta
                ,  PANIo io
                WHERE gcn.protocol_app_node_id = pan.protocol_app_node_id
                AND gcn.na_feature_id = ta.gene_na_feature_id
                AND gcn.protocol_app_node_id = io.output_pan_id
                AND (ta.gene_type = 'protein coding' or ta.gene_type = 'protein coding gene')
        ]]>
    </sql>
    <sql>
        <![CDATA[
            CREATE INDEX GeneCN_ix&1
            ON GeneCopyNumbers&1(input_pan_id, na_sequence_id)
            TABLESPACE indx
        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Stringdb" alwaysUpdate="true">
    <comment> Data from STRING-DB.org, populated from their web service.
         Used in the gene record.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <program commandLine="buildStringdbTT"/>
  </tuningTable>


  <tuningTable name="InterproData">
    <comment>for TranscriptAttributes.InterproColumns</comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.DomainFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>

    <sql>
        <![CDATA[
          create table InterproData&1 nologging as
          with iprows
          as (select *
              from (select distinct
                           dr.primary_identifier as primary_id,
                           dr.remark, xd1.name as interpro_name, ta.source_id
                    from TranscriptAttributes ta, dots.AaLocation al,
                         sres.ExternalDatabaseRelease xdr1, sres.ExternalDatabase xd1,
                         sres.ExternalDatabaseRelease xdr3, sres.ExternalDatabase xd3,
                         sres.DbRef dr, dots.DbRefAaFeature draf, dots.DomainFeature df,
                         dots.DomainFeature df2
                    where xd3.name
                          in ('InterproscanData_RSRC', 'INTERPRO', 'InterProScan',
                              'PFAM', 'PIRSF', 'PROSITEPROFILES',
                              'SMART', 'SUPERFAMILY', 'TIGRFAM')
                      and ta.aa_sequence_id = df.aa_sequence_id
                      and df.aa_feature_id = draf.aa_feature_id
                      and df.aa_feature_id = al.aa_feature_id
                      and draf.db_ref_id = dr.db_ref_id
                      and dr.external_database_release_id = xdr1.external_database_release_id
                      and xdr1.external_database_id = xd1.external_database_id
                      and df.external_database_release_id = xdr3.external_database_release_id
                      and xdr3.external_database_id = xd3.external_database_id
                      and df.parent_id = df2.aa_feature_id (+)
                   )
              pivot (listagg(primary_id, ';') within group (order by primary_id) as id,
                     listagg(remark, ';') within group (order by primary_id) as description
                     for interpro_name
                         in ('INTERPRO' interpro,
                             'InterProScan' interpro2,
                             'PFAM' pfam,
                             'PIRSF' pirsf,
                             'PROSITEPROFILES' prositeprofiles,
                             'SMART' smart,
                             'SUPERFAMILY' superfamily,
                             'TIGRFAM' tigrfam
                            )
                    )
             )
          select source_id, 
                 substr(interpro_id, 1, 200)||substr(interpro2_id, 1, 200) as interpro_id,
                 substr(interpro_description, 1, 3000)||substr(interpro2_description, 1, 3000) as interpro_description,
                 substr(pfam_id, 1, 200) as pfam_id,
                 substr(pfam_description, 1, 3000) as pfam_description,
                 substr(pirsf_id, 1, 200) as pirsf_id,
                 substr(pirsf_description, 1, 3000) as pirsf_description,
                 substr(prositeprofiles_id, 1, 200) as prositeprofiles_id,
                 substr(prositeprofiles_description, 1, 3000) as prositeprofiles_description,
                 substr(smart_id, 1, 200) as smart_id,
                 substr(smart_description, 1, 3000) as smart_description,
                 substr(superfamily_id, 1, 200) as superfamily_id,
                 substr(superfamily_description, 1, 3000) as superfamily_description,
                 substr(tigrfam_id, 1, 200) as tigrfam_id,
                 substr(tigrfam_description, 1, 3000) as tigrfam_description
          from iprows
        ]]>
    </sql>
    <sql>
        <![CDATA[
            create index ipd_ix&1
            on InterproData&1(source_id)
            tablespace indx
        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ApolloUpdate" alwaysUpdate="true">
    <comment>annotation updates from Apollo</comment>
    <ancillaryTable name="ApolloID"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <program commandLine="loadGffApolloTT"/>
  </tuningTable>


  <tuningTable name="GeneLocations" prefixEnabled="true">
    <comment>semicolon-delimited list of formatted genomic locations for each gene</comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <sql>
        <![CDATA[
          create table &prefixGeneLocations&1 nologging as
          select source_id,
                 listagg(location, '; ') within group(order by is_top_level desc) as locations
          from (select fl.feature_source_id as source_id, fl.is_top_level,
                       fl.sequence_source_id || ':'
                       || trim(to_char(fl.start_min,'999,999,999')) || '..'
                       || trim(to_char(fl.end_max,'999,999,999')) || '('
                       || decode(nvl(fl.is_reversed, 0), 0, '+', 1, '-', fl.is_reversed)
                       || ')' as location
                from apidb.FeatureLocation fl, dots.NaSequence ns
                where fl.feature_type = 'GeneFeature'
                  and fl.na_sequence_id = ns.na_sequence_id
                  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
               )
          group by source_id
        ]]>
    </sql>
    <sql>
        <![CDATA[
            create index gloc_ix&1
            on &prefixGeneLocations&1(source_id, locations)
            tablespace indx
        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatabaseTaxonUrl">
    <comment>
      Stores a mapping between external databases, taxon IDs, and URLs
    </comment>
    <externalDependency name="apidb.ExternalResourceUrl"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
      create table DatabaseTaxonUrl&1 nologging as
      select edd.dataset_presenter_display_name AS dataset, ga.taxon_id, edr.id_url
      from sres.DbRef db, dots.DbRefNaFeature dbna,
           ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
           GeneAttributes ga
      where db.external_database_release_id = edd.external_database_release_id
        and edr.external_database_release_id = edd.external_database_release_id
       and dbna.db_ref_id = db.db_ref_id
       and ga.na_feature_id = dbna.na_feature_id
       and id_url not like 'http://chemlims.com/%'
    union
      select edd.dataset_presenter_display_name AS dataset, ta.taxon_id, edr.id_url
      from sres.dbref db, dots.DbRefNaFeature dbna,
           ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
           TranscriptAttributes ta
      where db.external_database_release_id = edd.external_database_release_id
        and edr.external_database_release_id = edd.external_database_release_id
        and dbna.db_ref_id = db.db_ref_id
        and ta.na_feature_id = dbna.na_feature_id
    union
      select d.name as dataset, ga.taxon_id, eru.id_url
      from sres.DbRef dbr, dots.DbRefNaFeature dbrf, sres.ExternalDatabaseRelease r,
           sres.ExternalDatabase d, GeneAttributes ga,
           apidb.ExternalResourceUrl eru
      where dbr.external_database_release_id = r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and dbr.db_ref_id = dbrf.db_ref_id
        and dbrf.na_feature_id = ga.na_feature_id
        and upper(d.name) = eru.database_name
    union
      select distinct
             d.name as dataset, ta.taxon_id, eru.id_url
      from sres.DbRef dbr, dots.DbRefAaFeature dbrf, dots.AaFeature aaf,
           sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
           TranscriptAttributes ta, apidb.ExternalResourceUrl eru
      where dbr.external_database_release_id = r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and dbr.db_ref_id = dbrf.db_ref_id
        and dbrf.aa_feature_id = aaf.aa_feature_id
        and aaf.aa_sequence_id = ta.aa_sequence_id
        and upper(d.name) = eru.database_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index dtaxu_ix&1
          on DatabaseTaxonUrl&1 (taxon_id, dataset, id_url)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptGenomicSequence">
    <comment>The genomic sequence of each transcript. Used in the transcript record / gene record page.
    </comment>
    <externalDependency name="apidb.TranscriptLocation"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
      create table TranscriptGenomicSequence&1 nologging as
      select gf.source_id as gene_source_id, t.source_id,
             cast (null as varchar2(80)) as project_id,
             nas.sequence as genomic_sequence,
             length(nas.sequence) as genomic_sequence_length
      from dots.NaSequence nas, dots.GeneFeature gf, dots.Transcript t
      where 1 = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
  DECLARE
    rowcount number := 0;
    commit_frequency number := 10000;
    genomic_sequence clob;
    slices number := 100;
  BEGIN
  FOR slice IN 0 .. slices - 1
  LOOP
    FOR sequence_row IN (
      select nas.na_sequence_id, nas.sequence, length(nas.sequence) as sequence_length,
             apidb.project_id(tn.name) as project_id
      from dots.NaSequence nas, sres.TaxonName tn
      where nas.na_sequence_id
            in (select na_sequence_id from apidb.TranscriptLocation)
        and nas.taxon_id = tn.taxon_id
        and tn.name_class = 'scientific name'
        and mod(nas.na_sequence_id, slices) = slice
      order by nas.taxon_id, nas.na_sequence_id
      )
    LOOP
      FOR transcript_row IN (
        select gf.source_id as gene_source_id, t.source_id,
               tl.na_feature_id, tl.start_min, tl.end_max, tl.is_reversed
        from dots.GeneFeature gf, dots.Transcript t, apidb.TranscriptLocation tl
        where gf.na_sequence_id = sequence_row.na_sequence_id
          and gf.na_feature_id = t.parent_id
          and t.na_feature_id = tl.na_feature_id
          and tl.is_top_level = 1
        order by tl.start_min
      )
      LOOP
       insert into TranscriptGenomicSequence&1
              (gene_source_id, source_id, project_id,
                 genomic_sequence, genomic_sequence_length)
              values
               (
                transcript_row.gene_source_id, transcript_row.source_id, sequence_row.project_id,
                 case
                   when transcript_row.is_reversed = 1
                    then apidb.reverse_complement_clob(
                            substr(sequence_row.sequence, transcript_row.start_min,
                                   transcript_row.end_max - transcript_row.start_min + 1)
                           )
                    else substr(sequence_row.sequence, transcript_row.start_min,
                                transcript_row.end_max - transcript_row.start_min + 1)
                 end,
                 transcript_row.end_max - transcript_row.start_min + 1
                );
        rowcount := rowcount + 1;
        IF mod(rowcount, commit_frequency) = 0
          THEN
             commit;
        END IF;  
       END LOOP;
     END LOOP;
   END LOOP;
  END;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index txgseq_idx&1
          on TranscriptGenomicSequence&1(source_id, gene_source_id, project_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GroupPhylogeneticProfile">
    <comment>
      One phylogenetic-profile string per ortholog group
    </comment>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
      create table GroupPhylogeneticProfile&1 nologging as
      select rep.orthomcl_name, pp.profile_string
      from apidb.PhylogeneticProfile pp,
           (select orthomcl_name, max(source_id) as source_id
            from GeneAttributes
            group by orthomcl_name) rep
      where rep.source_id = pp.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index group_pp_ix&1
          on GroupPhylogeneticProfile&1 (orthomcl_name)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ApolloUpdateGene">
    <comment>
      Text from ApolloUpdate that can be used in site search to find genes
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ApolloUpdate"/>
    <sql>
      <![CDATA[
      create table ApolloUpdateGene&1 nologging as
	select ga.source_id
	, ga.project_id
	, au.id_attr
	, ta.gene_source_id
	, 'Y' as matched_result
	, cast(utl_url.unescape(replace( replace(regexp_substr(au.attr, 'Name=[^;]*;'), 'Name=', ''), ';', '')) as varchar2(400)) as apollo_transcript_id
	, au.creationdate as comment_date
	, au.apolloproduct || au.apollosymbol || au.apolloowner || au.apollogoterm || au.apollopmid as attr
	, au.apolloproduct as apollo_description
	, au.apolloowner as apollo_owner
	, au.apollopmid as apollo_dbxref
	, au.apollosymbol as apollo_symbol
	, au.apollogoterm as apollo_go_term
	, au.creationdate as creation_date
        , au.apolloevidencecode as evidence_code
        , au.apolloevidencecodeassignment as evidence_code_parameter
	, (select firstname.value || ' ' ||  lastname.value || ', ' || address.value from
	    (select uap.value
	        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
	        where uaa.user_id = uap.user_id
	        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
	        and uap.key = 'first_name') firstname,
	    (select uap.value
	        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
	        where uaa.user_id = uap.user_id
	        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
	        and uap.key = 'last_name') lastname,
	    (select uap.value
	        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
	        where uaa.user_id = uap.user_id
	        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
	        and uap.key = 'organization') address) as apollo_owner_details
	from ApolloUpdate au, GeneAttributes ga, TranscriptAttributes ta
	    where au.type = 'gene'
	    and (au.attr like '%gene_product=%'
	        or au.attr like '%description=%')
	    and ga.na_sequence_id = au.na_sequence_id     
	    and ga.start_min <= au.mapping_end AND ga.end_max >= au.mapping_start
	    and ta.source_id = au.apolloTranscript
	    and ga.strand_plus_minus = au.strand
	    and ta.gene_source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index aug_ix&1
          on ApolloUpdateGene&1 (source_id, project_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PreferredProductsGene">
    <comment>
      Text for PreferredProduct table on gene record page.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
                -- PreferredProductsGene: check apidb.TranscriptProduct and
                -- apidb.GeneFeatureProduct for records with IS_PREFERRED set. If
                -- (and only if) that turns up nothing, check the PRODUCT column of
                -- dots.GeneFeature and dots.Transcript
          create table PreferredProductsGene&1 nologging as
          with evids
               as (select distinct gaiec.go_evidence_code_id, ot.name
                   from  dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm ot
                   where ot.ontology_term_id = gaiec.go_evidence_code_id)
               -- end of WITH clause
            select ta.gene_source_id as source_id, tp.product, ta.project_id,
                   listagg(source_id, ', ' ON OVERFLOW TRUNCATE) within group(order by source_id)
                     as transcript_ids,
                   listagg(publication, ', ') within group(order by source_id)
                     as reference,
                   e.name as evidence_code,
                   tp.with_from AS evidence_code_parameter,
                   cast (max(tp.assigned_by) as varchar2(20)) as assigned_by,
                   'apidb.TranscriptProduct' as row_source
            from apidb.TranscriptProduct tp, TranscriptAttributes ta, evids e
            where ta.na_feature_id = tp.na_feature_id
              and tp.is_preferred = 1
              and tp.evidence_code = e.go_evidence_code_id(+)
            group by gene_source_id, ta.project_id, tp.product,
                     e.name, tp.with_from
          union
            select ga.source_id, gfp.product, ga.project_id,
                   cast (null as varchar2(1)) as transcript_ids,
                   cast (null as varchar2(1)) as reference,
                   cast (null as varchar2(1)) as evidence_code,
                   cast (null as varchar2(1)) as evidence_code_parameter,
                   cast (null as varchar2(20)) as assigned_by,
                   'apidb.GeneFeatureProduct' as row_source
            from apidb.GeneFeatureProduct gfp, GeneAttributes ga
            where ga.na_feature_id = gfp.na_feature_id
              and gfp.is_preferred = 1
            group by source_id, ga.project_id, gfp.product
          union
            select *
            from (select ta.gene_source_id as source_id, ta.transcript_product, ta.project_id,
                         listagg(source_id, ', ' on overflow truncate) within group(order by source_id)
                           as transcript_ids,
                         cast (null as varchar2(1)) as reference,
                         cast (null as varchar2(1)) as evidence_code,
                         cast (null as varchar2(1)) as evidence_code_parameter,
                   cast (null as varchar2(20)) as assigned_by,
                   'TranscriptAttributes/GeneAttributes' as row_source
                  from TranscriptAttributes ta
                  where ta.transcript_product is not null
                  group by ta.gene_source_id, ta.transcript_product, ta.project_id
                 )
            where source_id
                  in (  select *
                        from (  select source_id
                                from dots.GeneFeature
                                where product is not null
                              union
                                select ga.source_id
                                from dots.Transcript t, GeneAttributes ga
                                where t.product is not null
                                  and t.parent_id = ga.na_feature_id
                             )
                      minus
                        select *
                        from (  select ta.gene_source_id
                                from apidb.TranscriptProduct tp, TranscriptAttributes ta
                                where tp.na_feature_id = ta.na_feature_id
                              union
                                select ga.source_id
                                from apidb.GeneFeatureProduct gfp, GeneAttributes ga
                                where gfp.na_feature_id = ga.na_feature_id
                             )
                     )
     ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ppg_ix&1
          on PreferredProductsGene&1 (source_id, project_id)
          tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="AlphaFoldGenes">
    <comment>
      Links AlphaFold entries to gene ids where Uniprot ids are directly assigned
    </comment>
    
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="apidb.AlphaFold"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TranscriptAttributes"/>

    <ancillaryTable name="uniprotGenes"/>
    <intermediateTable name="minRank"/>
    <intermediateTable name="alphaFoldHits"/>

    <sql>
      <![CDATA[
        CREATE TABLE uniprotGenes&1 nologging AS (
            SELECT DISTINCT ed.name
            , d.*
            , edr.version
            , aa.source_id
            , pa.gene_source_id
            , CASE WHEN (ed.name like '%SWISSPROT%' AND edr.version = 'xrefuniparc') THEN 1
                WHEN (ed.name like '%SPTREMBL%' AND edr.version = 'xrefuniparc') THEN 2
                WHEN (ed.name like '%SWISSPROT%' AND edr.version = 'xref_sprot_blastp') THEN 4
                WHEN (ed.name like '%SPTREMBL%' and edr.version = 'xref_trembl_blastp') THEN 5
                ELSE 6 END as rank
            , (af.last_residue_index - af.first_residue_index + 1) as hit_length
            FROM sres.dbref d
            , sres.externaldatabase ed
            , sres.externaldatabaserelease edr
            , dots.dbrefaafeature db
            , dots.aafeature aa
            , ProteinAttributes pa
            , apidb.AlphaFold af
            WHERE (ed.name = 'Uniprot/SWISSPROT' OR ed.name = 'Uniprot/SPTREMBL')
            AND (edr.version = 'xrefuniparc' OR edr.version = 'xref_sprot_blastp' OR edr.version = 'xref_trembl_blastp') 
            AND edr.external_database_id = ed.external_database_id
            AND d.external_database_release_id = edr.external_database_release_id
            AND db.db_ref_id = d.db_ref_id
            AND aa.aa_feature_id = db.aa_feature_id
            AND pa.source_id = aa.source_id
            AND d.primary_identifier = af.uniprot_id(+)
          UNION
            SELECT DISTINCT ed.name
            , d.*
            , edr.version
            , na.source_id
            , ta.gene_source_id
            , 3 as rank
            , (af.last_residue_index - af.first_residue_index + 1) as hit_length
            FROM sres.dbref d
            , sres.externaldatabase ed
            , sres.externaldatabaserelease edr
            , dots.dbrefnafeature db
            , dots.nafeature na
            , TranscriptAttributes ta
            , apidb.AlphaFold af
            WHERE ed.name like '%_dbxref_%niprot_%RSRC'
            AND edr.external_database_id = ed.external_database_id
            AND d.external_database_release_id = edr.external_database_release_id
            AND db.db_ref_id = d.db_ref_id
            AND na.na_feature_id = db.na_feature_id
            AND (ta.transcript_source_id = na.source_id OR ta.gene_source_id = na.source_id)
            AND d.primary_identifier = af.uniprot_id(+)
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE minRank nologging AS (
            SELECT gene_source_id
            , MIN(rank) as min_rank
            FROM uniprotGenes&1 upg
            WHERE hit_length is not null
            GROUP BY gene_source_id
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE alphaFoldHits nologging AS (
            SELECT gene_source_id
            , MAX(primary_identifier) KEEP (DENSE_RANK LAST ORDER BY hit_length) AS uniprot_id
            FROM (
                SELECT upg.*
                FROM uniprotGenes&1 upg
                , minRank
                WHERE upg.gene_source_id = minRank.gene_source_id
                AND upg.rank = minRank.min_rank
            )
            GROUP BY gene_source_id
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE AlphaFoldGenes&1 nologging AS (
            SELECT afh.gene_source_id
            , af.uniprot_id
            , af.source_id as alphafold_id
            , af.alphafold_version
            , af.first_residue_index
            , af.last_residue_index
            FROM apidb.alphafold af
            , alphaFoldHits afh
            WHERE afh.uniprot_id = af.uniprot_id
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE index AlphaFoldGenes_idx&1 ON AlphaFoldGenes&1 (gene_source_id, uniprot_id)                                                                                                
        tablespace indx
      ]]>
    </sql>

  </tuningTable>

</tuningConfig>
