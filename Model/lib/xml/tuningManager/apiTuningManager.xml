<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <import file="tuningManager.xml"/>

  <tuningTable name="TransmembraneDomains" prefixEnabled="false">
    <comment>Locations and Sequence of Transmembrane Domains (TMHMM)
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <sql>
      <![CDATA[
        CREATE TABLE TransmembraneDomains&1 AS
        SELECT ta.source_id as transcript_source_id
            , ta.gene_source_id AS gene_source_id
            , ta.project_id
            , tmf.topology AS tmf_topology
            , aal.start_min AS tmf_start_min
            , aal.end_max AS tmf_end_max
            , substr(tas.sequence, aal.end_max::INTEGER - aal.start_min::INTEGER + 1, aal.start_min::INTEGER) AS tmf_sequence
            , tmf.aa_feature_id tmf_aa_feature_id
            , tmf.aa_sequence_id tmf_aa_sequence_id
            , tas.source_id as protein_source_id
        FROM dots.aalocation aal
          , transcriptattributes ta
          , dots.translatedaafeature taf
          , dots.translatedaasequence tas
          , dots.transmembraneaafeature tmf
        WHERE ta.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND tas.aa_sequence_id = tmf.aa_sequence_id
        and tmf.aa_feature_id = aal.aa_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TransDom1_ix&1
        on TransmembraneDomains&1 (tmf_aa_sequence_id, tmf_aa_feature_id, tmf_start_min, tmf_end_max, tmf_topology)

      ]]>
    </sql>
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        create index TransDom2_ix&1-->
<!--        on TransmembraneDomains&1 (gene_source_id, project_id, transcript_source_id, tmf_start_min, tmf_end_max, tmf_topology, tmf_sequence)-->
<!--        -->
<!--      ]]>-->
<!--    </sql>-->
  </tuningTable>

  <tuningTable name="SignalPeptideDomains" prefixEnabled="true">
    <comment>Locations and Sequence of Signal Peptide Domains (SignalP)
    </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <sql>
      <![CDATA[
          CREATE TABLE &prefixSignalPeptideDomains&1 AS
          SELECT
              gf.source_id gene_source_id
              , t.source_id transcript_source_id
              , taf.na_feature_id
              , spf.aa_feature_id
              , spf.aa_sequence_id
              , spf.parent_id
              , aal.start_min
              , aal.end_max
              , spf.algorithm_name
              , substr(s.sequence, aal.end_max::INTEGER, 1) peptide_sequence
          FROM
             dots.SignalPeptideFeature spf
            , dots.AaLocation aal
            , dots.TranslatedAaFeature taf
            , dots.TranslatedAaSequence tas
            , dots.GeneFeature gf
            , dots.AaSequence s
            , dots.Transcript t
          WHERE
              spf.aa_sequence_id = s.aa_sequence_id
              AND aal.aa_feature_id = spf.aa_feature_id
              AND t.na_feature_id = taf.na_feature_id
              AND taf.aa_sequence_id = tas.aa_sequence_id
              AND tas.aa_sequence_id = spf.aa_sequence_id
              AND gf.na_feature_id = t.parent_id
              AND (spf.signal_probability >= .5
                  OR spf.signal_probability IS NULL
                  OR ((spf.means_score + spf.maxy_score) / 2) >= .5
                      OR ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3
                  )
          ORDER BY
              spf.aa_sequence_id, spf.aa_feature_id
        ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX SignalP1_ix&1
          ON &prefixSignalPeptideDomains&1 (aa_sequence_id)

        ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX SignalP2_ix&1
          ON &prefixSignalPeptideDomains&1 (gene_source_id, transcript_source_id, end_max)

        ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismSelectTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for organisms
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismSelectTaxonRank&1 AS
        WITH organism_rank AS (
          SELECT tn1.name as organism, o.public_abbrev, tn2.name as parent_organism,
            case when tn2.name = 'Oomycetes' then 'class' else r.rank end as rank
          FROM (
              WITH RECURSIVE cte AS(
                SELECT taxon_id input, taxon_id, rank, parent_id
                FROM sres.taxon
                WHERE taxon_id IN (SELECT taxon_id FROM apidb.organism WHERE is_annotated_genome = 1)
                UNION
                SELECT cte.input, t.taxon_id, t.rank, t.parent_id
                FROM sres.taxon t, cte
                WHERE cte.parent_id = t.taxon_id
              )
              SELECT input, taxon_id, rank
              FROM cte
            ) r
            , sres.taxonname tn1
            , sres.taxonname tn2
            , apidb.organism o
          WHERE r.input = tn1.taxon_id
            AND r.taxon_id = tn2.taxon_id
            AND tn1.name_class = 'scientific name'
            AND tn2.name_class = 'scientific name'
            AND (r.rank in ('phylum', 'genus', 'species', 'kingdom', 'class') or (r.rank = 'no rank' and tn2.name = 'Oomycetes'))
            AND tn1.taxon_id = o.taxon_id
        )
        SELECT
          organisms.organism
          , organisms.public_abbrev
          , coalesce(phylum.parent_organism, 'N/A') as phylum
          , coalesce(genus.parent_organism, 'N/A') as genus
          , coalesce(species.parent_organism, 'N/A') as species
          , coalesce(kingdom.parent_organism, 'N/A') as kingdom
          , coalesce(class.parent_organism, 'N/A') as class
        FROM
          (select distinct organism, public_abbrev from organism_rank) organisms
          LEFT JOIN ( select * from organism_rank where rank= 'phylum') phylum ON organisms.organism = phylum.organism
          LEFT JOIN ( select * from organism_rank where rank= 'genus') genus ON organisms.organism = genus.organism
          LEFT JOIN ( select * from organism_rank where rank= 'species') species ON organisms.organism = species.organism
          LEFT JOIN ( select * from organism_rank where rank= 'kingdom') kingdom ON organisms.organism = kingdom.organism
          LEFT JOIN ( select * from organism_rank where rank= 'class') class ON organisms.organism = class.organism
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayAttributes" prefixEnabled="false">
    <comment>Attributes for Metabolic Pathways
    </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwayAttributes&1 as
        SELECT
            p.source_id
          , p.pathway_id
          , p.name
          , enz.total_enzyme_count
          , cpd.total_compound_count
          , p.url
          , replace(replace(ed.name, 'Pathways_', ''), '_RSRC', '') as pathway_source
          , ed.name as external_db_name
          , edr.version as external_db_version
        FROM
            sres.pathway p
          , sres.externalDatabase ed
          , sres.externalDatabaseRelease edr
          ,(SELECT
              COUNT( *) AS total_compound_count
            , pathway_id
            FROM
              sres.pathwayNode pn
            , SRES.ontologyterm ot
            WHERE
              pn.pathway_node_type_id = ot.ontology_term_id
              AND ot.name = 'molecular entity'
            GROUP BY
              pathway_id
          ) cpd
          ,(SELECT
              COUNT( *) AS total_enzyme_count
            , pathway_id
            FROM
              sres.pathwayNode pn
            , SRES.ontologyterm ot
            WHERE
              pn.pathway_node_type_id = ot.ontology_term_id
              AND ot.name = 'enzyme'
            GROUP BY
              pathway_id
          ) enz
        WHERE
          ed.external_database_id = edr.external_database_id
          AND edr.external_database_release_id = p.external_database_release_id
          AND cpd.pathway_id = p.pathway_id
          AND enz.pathway_id = p.pathway_id
          AND source_id NOT IN('ec01100', 'ec01110', 'ec01120')
          -- temporarily remove MPMP from release 46
          AND ed.name NOT LIKE '%MPMP%'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX PathAttr_sourceId_pwaySrc&1
          ON &prefixPathwayAttributes&1 (source_id, pathway_source)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathAttr_ix&1
          on PathwayAttributes&1 (pathway_id, source_id, name, pathway_source, total_enzyme_count, total_compound_count)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonPairSummary">
    <comment>synteny stats for each reference-taxon / comparison-taxon pair
    </comment>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.SyntenicGene"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
        create table TaxonPairSummary&1 as
        select ref_taxon_id, comp_taxon_id,
               count(*) as syntenic_span_count,
               sum(ref_length) as ref_coverage,
               avg(ref_length) as average_span_length,
               avg(gene_count) as average_gene_count
        from (select ref_seq.taxon_id as ref_taxon_id,
                     comp_seq.taxon_id as comp_taxon_id,
                     synteny.a_end - synteny.a_start + 1 as ref_length,
                     coalesce(sg_summary.gene_count, 0) as gene_count
              from apidb.Synteny, dots.NaSequence ref_seq,
                   dots.NaSequence comp_seq,
                   (select synteny_id, count(*) as gene_count
                    from apidb.SyntenicGene
                    group by synteny_id) sg_summary
              where synteny.a_na_sequence_id = ref_seq.na_sequence_id
                and synteny.b_na_sequence_id = comp_seq.na_sequence_id
                and synteny.synteny_id = sg_summary.synteny_id
             ) t
        group by ref_taxon_id, comp_taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tps_ix&1
          on TaxonPairSummary&1 (ref_taxon_id, comp_taxon_id)

      ]]>
    </sql>
  </tuningTable>


<!-- COMMENT FOR NOW, as no InferredParam table; FIX later 
  <tuningTable name="FallbackOrganism">
    <comment>
      Taxon metadata for reference SNPs
    </comment>
    <internalDependency name="PANResults"/>
    <internalDependency name="InferredParams"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        CREATE TABLE FallbackOrganism&1 AS
        SELECT ed.name as dataset_name, 'SNP' as type, 'HTS_SNP' as subtype, tn.name as organism,
               o.strain_abbrev as pan_name, pan.protocol_app_node_id, 'name' as term_name,
               study_release.study_name
        FROM study.ProtocolAppNode pan, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             (SELECT s.study_id, s.external_database_release_id,
                     s.name as study_name
              FROM study.Study s
              WHERE investigation_id is null) study_release,
              apidb.Organism o LEFT JOIN sres.TaxonName tn ON o.taxon_id = tn.taxon_id
        WHERE pan.protocol_app_node_id in (select pan_id from PANResults)
          - and ed.name not in (select dataset_name from InferredParams)
          - and ed.name not in (select dataset_name from InferredChars)
          AND pan.protocol_app_node_id = sl.protocol_app_node_id
          AND sl.study_id = study_release.study_id
          AND study_release.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name like '%_NGS_SNPsAndVariations'
          AND o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          AND (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="TranscriptPathway">
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <sql>
        <![CDATA[
         CREATE TABLE TranscriptPathway&1 (
            SOURCE_ID	                  VARCHAR(80),
            GENE_SOURCE_ID	              VARCHAR(80),
            PROJECT_ID	                  VARCHAR(20),
            PATHWAY_SOURCE_ID	          VARCHAR(50),
            PATHWAY_NAME	              VARCHAR(150),
            EC_NUMBER_GENE	              VARCHAR(16),
            WILDCARD_COUNT_GENE	          NUMERIC,
            EC_NUMBER_PATHWAY	          VARCHAR(16),
            WILDCARD_COUNT_PATHWAY	      NUMERIC,
            EXACT_MATCH	                  NUMERIC,
            COMPLETE_EC	                  NUMERIC,
            PATHWAY_ID	                  NUMERIC(12,0),
            PATHWAY_SOURCE	              VARCHAR(200),
            EXTERNAL_DATABASE_RELEASE_ID  NUMERIC(10,0)
         )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          idlist RECORD;
        BEGIN
        FOR idlist IN ( SELECT DISTINCT organism FROM GeneAttributes )
        LOOP
          INSERT INTO TranscriptPathway&1
            WITH transcript_ec AS (
              SELECT ec.enzyme_class_id, ec.ec_number, ec.ec_number_1, ec.ec_number_2, ec.ec_number_3, ec.ec_number_4,
                -- CHECK AND FIX
                -- regexp_count( ec.ec_number, '-') as wildcard_count
                count( ec.ec_number) as wildcard_count
              FROM sres.EnzymeClass ec
              WHERE enzyme_class_id IN (SELECT enzyme_class_id FROM dots.AaSequenceEnzymeClass)
              GROUP BY ec.enzyme_class_id
            ),
            pathway_node_ec AS (
              SELECT distinct pn.pathway_id, pn.row_id as enzyme_class_id
              FROM sres.PathwayNode pn, sres.ontologyterm ot
              WHERE pn.pathway_node_type_id = ot.ontology_term_id
                AND ot.name = 'enzyme'
                AND pn.display_label != '-.-.-.-'
            ),
            pathway_ec AS (
              SELECT ec.enzyme_class_id, ec.ec_number, ec.ec_number_1, ec.ec_number_2, ec.ec_number_3, ec.ec_number_4,
                -- CHECK AND FIX
                --   regexp_count( ec.ec_number, '-') as wildcard_count
                     count( ec.ec_number) as wildcard_count
              FROM sres.EnzymeClass ec
              WHERE enzyme_class_id IN (SELECT enzyme_class_id FROM pathway_node_ec)
              GROUP BY ec.enzyme_class_id
            ),
            ec_match AS (
              SELECT tec.enzyme_class_id as transcript_enzyme_class_id,
                     pec.enzyme_class_id as pathway_enzyme_class_id,
                     tec.wildcard_count as wildcard_count_transcript,
                     pec.wildcard_count as wildcard_count_pathway,
                     tec.ec_number as ec_number_transcript,
                     pec.ec_number as ec_number_pathway
              FROM transcript_ec tec, pathway_ec pec
              WHERE (tec.ec_number_1 = pec.ec_number_1 or tec.ec_number_1 is null or pec.ec_number_1 is null)
                AND (tec.ec_number_2 = pec.ec_number_2 or tec.ec_number_2 is null or pec.ec_number_2 is null)
                AND (tec.ec_number_3 = pec.ec_number_3 or tec.ec_number_3 is null or pec.ec_number_3 is null)
                AND (tec.ec_number_4 = pec.ec_number_4 or tec.ec_number_4 is null or pec.ec_number_4 is null)
            )
            SELECT DISTINCT ga.source_id
              , ga.gene_source_id
              , ga.project_id
              , pa.source_id as pathway_source_id
              , pa.name as pathway_name
              , ec_match.ec_number_transcript as ec_number_gene
              , ec_match.wildcard_count_transcript as wildcard_count_gene
              , ec_match.ec_number_pathway
              , ec_match.wildcard_count_pathway
              , CASE WHEN ec_match.ec_number_pathway = ec_match.ec_number_transcript
                  THEN 1
                  ELSE 0 END as exact_match
              , CASE WHEN ec_match.wildcard_count_pathway + ec_match.wildcard_count_transcript = 0
                  THEN 1
                  ELSE 0  END as complete_ec
              , pa.pathway_id
              , pa.pathway_source
              , p.external_database_release_id
            FROM PathwayAttributes pa
              , sres.pathway p
              , pathway_node_ec pec
              , ec_match
              , dots.AaSequenceEnzymeClass asec
              , TranscriptAttributes ga
            WHERE ga.organism = idlist.organism
              AND pa.pathway_id = pec.pathway_id
              AND p.pathway_id = pa.pathway_id
              AND pec.enzyme_class_id = ec_match.pathway_enzyme_class_id
              AND asec.enzyme_class_id = ec_match.transcript_enzyme_class_id
              AND ga.aa_sequence_id  = asec.aa_sequence_id
              AND (
                (ga.orthomcl_name IS NULL AND asec.evidence_code != 'OrthoMCLDerived')
                OR ga.orthomcl_name IS NOT NULL
              )
          ;
          commit;
         END LOOP;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptPath_ix&1
        on TranscriptPathway&1(gene_source_id, source_id, pathway_source_id,
                               pathway_name, pathway_id, ec_number_gene, wildcard_count_pathway,
                               ec_number_pathway, pathway_source)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptPathSource_ix&1
        on TranscriptPathway&1(pathway_source, gene_source_id, source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EcMatch">
    <internalDependency name="TranscriptPathway"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        create table EcMatch&1 as
        with tp_ec
        as (select distinct ec_number_gene
            from TranscriptPathway),
        wildcarded_pathway_ec
        as (select distinct enzyme
            from PathwayReactions
            where enzyme like '%.%.%.%'
              and enzyme like '%-%'
              and enzyme != '-.-.-.-'),
        unwildcarded_pathway_ec
        as (select distinct enzyme
            from PathwayReactions
            where enzyme like '%.%.%.%'
              and enzyme not like '%-%')
        -- end of WITH clause
          select ec_number_gene, wpe.enzyme, 1 as is_wildcarded
          from tp_ec te, wildcarded_pathway_ec wpe
          where te.ec_number_gene like replace(wpe.enzyme, '-', '%')
        union all
          select ec_number_gene, upe.enzyme, 0 as is_wildcarded
          from tp_ec te, unwildcarded_pathway_ec upe
          where te.ec_number_gene = upe.enzyme
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ecmtch_gene_ix&1
        on EcMatch&1(ec_number_gene, enzyme, is_wildcarded)

      ]]>
    </sql>
    <sql>
        <![CDATA[
        create index ecmtch_enzyme_ix&1
        on EcMatch&1(enzyme, ec_number_gene, is_wildcarded)

        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayNodeGene">
    <internalDependency name="TranscriptPathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwayNodeGene&1 as
        SELECT DISTINCT pn.pathway_node_id
          , tp.gene_source_id
        FROM transcriptpathway tp
          , sres.pathwaynode pn
        WHERE tp.pathway_id = pn.pathway_id
          AND tp.ec_number_gene like replace(pn.display_label, '-', '%')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="RnaSeqStats">
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table RnaSeqStats&1 as
        select study_id, study_name, dataset_name, taxon_id, round(avg(num_reads::integer),0) as avg_unique_reads
        from (select sl.node_set_id as study_id
                , s.name || '[' || s.node_type || ']' as study_name
                , ed.name as dataset_name
                , ds.taxon_id
                , c.value as num_reads
            from apidb.Datasource ds
                , sres.ExternalDatabase ed
                , sres.ExternalDatabaseRelease edr
                , study.nodeSet s, study.nodeNodeSet sl
                , study.ProtocolAppNode pan
                , study.Characteristic c
                , sres.OntologyTerm ot
            where ds.external_database_name = ed.name
                and ed.external_database_id = edr.external_database_id
                and edr.external_database_release_id = s.external_database_release_id
                and sl.node_set_id = s.node_set_id
                and sl.protocol_app_node_id = pan.protocol_app_node_id
                and pan.protocol_app_node_id = c.protocol_app_node_id
                and c.qualifier_id = ot.ontology_term_id
                and (ot.source_id = 'EUPATH_0000460' or ot.source_id = 'EuPathUserDefined_00507')
        ) subquery1
        group by study_id, study_name, dataset_name, taxon_id
        union
        select study_id, study_name, dataset_name, taxon_id, round(2*avg(num_reads::integer),0) as avg_unique_reads
        from (select sl.node_set_id as study_id
                , s.name || '[' || s.node_type || ']' as study_name
                , ed.name as dataset_name
                , ds.taxon_id
                , c.value as num_reads
            from apidb.Datasource ds
                , sres.ExternalDatabase ed
                , sres.ExternalDatabaseRelease edr
                , study.nodeSet s, study.nodeNodeSet sl
                , study.ProtocolAppNode pan
                , study.Characteristic c
                , sres.OntologyTerm ot
            where ds.external_database_name = ed.name
                and ed.external_database_id = edr.external_database_id
                and edr.external_database_release_id = s.external_database_release_id
                and sl.node_set_id = s.node_set_id
                and sl.protocol_app_node_id = pan.protocol_app_node_id
                and pan.protocol_app_node_id = c.protocol_app_node_id
                and c.qualifier_id = ot.ontology_term_id
                and (ot.source_id = 'EUPATH_0000468' or ot.source_id = 'EuPathUserDefined_00515' or ot.source_id = 'EUPATH_0000476' or ot.source_id = 'EuPathUserDefined_00523')
        ) subquery2
        group by study_id, study_name, dataset_name, taxon_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyLevels" prefixEnabled="true">
    <comment>the max and min depth of each ontology term in OntologyRelationship. Used by the GoTermSummary tuning table</comment>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="is_a_links"/>
    <intermediateTable name="roots"/>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE &prefixIs_a_links AS
        SELECT subject_term_id, object_term_id
        FROM sres.OntologyRelationship rel, sres.OntologyTerm pred
        WHERE rel.predicate_term_id = pred.ontology_term_id
          AND pred.name = 'is_a'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE &prefixRoots AS
        SELECT object_term_id FROM &prefixis_a_links
        EXCEPT
        SELECT subject_term_id FROM &prefixis_a_links
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixOntologyLevels&1 as
        WITH RECURSIVE levels(ontology_term_id, depth) AS (
          SELECT object_term_id, 1 as depth FROM &prefixRoots
          UNION
          SELECT &prefixis_a_links.subject_term_id, levels.depth + 1 as depth
          FROM &prefixIs_a_links, levels
          WHERE &prefixis_a_links.object_term_id = levels.ontology_term_id
      )
      SELECT ontology_term_id, min(depth) as min_depth, max(depth) as max_depth
      FROM (
          SELECT ontology_term_id, depth
          FROM levels
          WHERE ontology_term_id NOT IN (SELECT object_term_id FROM &prefixRoots)
          UNION
          SELECT object_term_id, 0 FROM &prefixRoots
      ) t
      GROUP BY ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index olev_termix&1 on &prefixOntologyLevels&1 (ontology_term_id, min_depth, max_depth)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGoTerms" prefixEnabled="true">
    <comment>GeneGoTerms: each row represents one GO term assignment to one gene, right from what was loaded.
    </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixGeneGoTerms&1 as
        with root_term
             as (select ontology_term_id,
                        cast(initcap(replace(name, '_', ' ')) as varchar(20)) as ontology
                 from sres.OntologyTerm
                 where source_id in ('GO_0008150','GO_0003674','GO_0005575'))
        select gf.source_id as gene_source_id, t.source_id as transcript_source_id, taf.aa_sequence_id,
               cast (CASE ga.is_not WHEN 0 THEN '' WHEN 1 THEN 'not' ELSE ga.is_not::varchar END as varchar(3)) as is_not, ns.taxon_id,
               cast (gt.source_id as varchar(20)) as go_id,
               gt.ontology_term_id as go_term_id, rt.ontology,
               cast(gt.name as varchar(250)) as go_term_name,
               cast(gail.name as varchar(24)) as source,
               cast(gec.name as varchar(12)) as evidence_code,
               cast(gaiec.reference as varchar(250)) as reference,
               cast(gaiec.evidence_code_parameter as varchar(80))as evidence_code_parameter
        from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf, dots.GoAssociation ga,
             dots.GoAssociationInstance gai, dots.GoAssociationInstanceLoe gail,
             dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm gec, dots.NaSequence ns,
             sres.OntologyTerm gt LEFT JOIN root_term rt ON gt.ancestor_term_id = rt.ontology_term_id
        where t.parent_id = gf.na_feature_id
          and gf.na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id::varchar = '&filterValue' or length('&filterValue') = 0)
          and t.na_feature_id = taf.na_feature_id
          and taf.aa_sequence_id = ga.row_id
          and ga.table_id = (select table_id
                             from core.TableInfo
                             where name = 'TranslatedAASequence')
          and ga.go_term_id = gt.ontology_term_id
          and ga.go_association_id = gai.go_association_id
          and gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
          and gai.go_association_instance_id = gaiec.go_association_instance_id
          and gaiec.go_evidence_code_id = gec.ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ggt_ix&1 ON &prefixGeneGoTerms&1
               (gene_source_id, transcript_source_id, ontology, go_id, go_term_id,
                go_term_name, source, evidence_code, reference,
                evidence_code_parameter, aa_sequence_id, is_not)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGoTable">
    <comment>A tuning table for the gene record GO term table
    </comment>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneGoTable&1 AS
        SELECT source_id, project_id, go_id,
               string_agg(transcript_source_id, ', ' order by transcript_source_id) as transcript_ids,
               is_not,
               max(go_term_name) as go_term_name, ontology, source, evidence_code,
               reference, evidence_code_parameter, sort_key
        FROM (SELECT DISTINCT ggt.gene_source_id as source_id, ga.project_id,
                              replace(ggt.go_id, 'GO_', 'GO:') as go_id,
                              ggt.transcript_source_id,
                              case when ggt.is_not = 'not' then 'Is not' else '' end AS is_not,
                              ggt.go_term_name, ggt.ontology, ggt.source, ggt.evidence_code,
                              ggt.reference, ggt.evidence_code_parameter,
                              substr(ggt.ontology, 1, 1) || replace(ggt.go_id, 'GO_', 'GO:') as sort_key
              FROM GeneGoTerms ggt, GeneAttributes ga
              WHERE ggt.gene_source_id = ga.source_id
        ) t
        GROUP BY source_id, project_id, go_id, is_not, ontology,
                 source, evidence_code, reference, evidence_code_parameter, sort_key
        ORDER BY source_id, ontology, go_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ggtab_ix&1 ON GeneGoTable&1
               (source_id, project_id, go_id, transcript_ids, is_not, go_term_name,
                ontology, source, evidence_code, reference, evidence_code_parameter, sort_key)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoSubsetLeaf">
    <comment>
      Map each GO term that is assigned to at least one gene to a GoSubset term
      that is either itself or an immediate ancestor. By "immediate ancestor"
      we mean an ancestor such that there isn't an intermediate ancestor also
      in the subset. (Note that there can be multiple links as long as none is
      in the subset.) This is currently restricted to 'goslim_generic', solely
      by the condition in the SUBSET_TERM subquery.
    </comment>
    <externalDependency name="apidb.GoSubset"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <internalDependency name="GeneGoTerms"/>
    <sql>
      <![CDATA[
        create table GoSubsetLeaf&1 as
        with leaf_term -- GO terms assigned to at least one gene
             as (select distinct go_term_id
                 from GeneGoTerms),
             subset_term -- (term ID, subset name) pairs
             as (select distinct -- "distinct" is probably unneeded
                        ontology_term_id, go_subset_term
                 from apidb.GoSubset
                 -- where go_subset_term != 'gosubset_prok' -- unrelated and huge
                 where go_subset_term = 'goslim_generic' -- all we currently need
                ),
             subset -- the 17 or so distinct subset names, e.g. "goslim_generic"
             as (select distinct go_subset_term
                 from subset_term),
             leaf_in_subset -- leaf (i.e. assigned) terms that are in a subset
             as (select leaf_term.go_term_id, subset_term.go_subset_term
                 from leaf_term, subset_term
                 where leaf_term.go_term_id = subset_term.ontology_term_id),
             leaf_not_in_subset -- (go_term_id, subset) pairs such that the GO
             as (               -- term is assigned, but not in the given subset
                   select leaf_term.go_term_id, subset.go_subset_term
                   from leaf_term, subset -- cartesian join
                   EXCEPT
                   select go_term_id, go_subset_term
                   from leaf_in_subset),
             leaf_ancestor -- a leaf not in a subset, with an ancestor that is in the subset
             as (select lnis.go_subset_term, lnis.go_term_id, gs.ontology_term_id as ancestor_term_id
                 from leaf_not_in_subset lnis, sres.OntologyRelationship orel, apidb.GoSubset gs
                 where orel.subject_term_id = lnis.go_term_id -- "subject" = "child"
                   and orel.object_term_id = gs.ontology_term_id
                   and orel.subject_term_id != orel.object_term_id
                   and lnis.go_subset_term = gs.go_subset_term),
             leaf_nonimmediate_ancestor
             as (select distinct upper.go_subset_term, upper.go_term_id, upper.ancestor_term_id
                 from leaf_ancestor upper, leaf_ancestor lower, sres.OntologyRelationship orel
                 where upper.go_subset_term = lower.go_subset_term
                   and upper.go_term_id = lower.go_term_id
                   and upper.ancestor_term_id = orel.object_term_id
                   and lower.ancestor_term_id = orel.subject_term_id
                   and orel.subject_term_id != orel.object_term_id),
             leaf_immediate_ancestor
             as (  select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_ancestor
                   EXCEPT
                   select go_subset_term, go_term_id, ancestor_term_id
                   from leaf_nonimmediate_ancestor)
          select -- leaf terms that are in a subset
                 cast (go_subset_term as varchar(50)) as go_subset_term, go_term_id, go_term_id as subset_leaf_term_id
          from leaf_in_subset
        union
          select -- leaf terms not in subset with their subset immediate ancestors
                 cast (go_subset_term as varchar(50)) as go_subset_term, go_term_id, ancestor_term_id as subset_leaf_term_id
          from leaf_immediate_ancestor
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gsl_ix&1 ON GoSubsetLeaf&1 (go_term_id, go_subset_term, subset_leaf_term_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoTermSummary" prefixEnabled="true">
    <comment>GoTermSummary: each row represents one GO term assignment to one gene.
      (Typically, a gene has multiple such assignments.) This is used for
      finding gene-GO mappings, such as for the gene-page GO table.
    </comment>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="OntologyLevels"/>
    <externalDependency name="apidb.GoSubset"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGoTermSummary&1 AS
        SELECT ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id,
               ggt.taxon_id, ggt.is_not, replace(ggt.go_id, '_', ':') as go_id,
               ggt.go_term_id, ggt.ontology,
               replace(ggt.go_term_name, '_',' ') as go_term_name, ggt.source,
               ggt.evidence_code,
               CASE ggt.evidence_code WHEN 'IEA' THEN 'Computed' ELSE 'Curated' END as evidence_category,
               ggt.reference, ggt.evidence_code_parameter,
               ol.min_depth as depth,
               case
                 when gs.ontology_term_id is null then 0
                 else 1
               end as is_go_slim
        FROM &prefixGeneGoTerms ggt
          LEFT JOIN &prefixOntologyLevels ol ON ggt.go_term_id = ol.ontology_term_id
          LEFT JOIN (
            SELECT distinct ontology_term_id
            FROM apidb.GoSubset
            WHERE go_subset_term = 'goslim_generic'
           ) gs ON ggt.go_term_id = gs.ontology_term_id
        UNION
        SELECT ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id,
               ggt.taxon_id, ggt.is_not,
               replace (substr(ot.source_id, 1, 25),'_',':') as go_id,
               ot.ontology_term_id as go_term_id, ggt.ontology,
               replace (substr(ot.name, 1,250),'_',' ') as go_term_name,
               ggt.source, ggt.evidence_code,
               CASE ggt.evidence_code WHEN 'IEA' THEN 'Computed' ELSE 'Curated' END as evidence_category,
               ggt.reference,
               ggt.evidence_code_parameter,
               ol.min_depth as depth,
               case
                 when gs.ontology_term_id is null then 0
                 else 1
               end as is_go_slim
        FROM &prefixGeneGoTerms ggt, sres.OntologyRelationship orel,
             sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
             sres.OntologyTerm ot
             LEFT JOIN &prefixOntologyLevels ol ON ot.ontology_term_id = ol.ontology_term_id
             LEFT JOIN (
              SELECT distinct ontology_term_id
              FROM apidb.GoSubset
              WHERE go_subset_term = 'goslim_generic'
             ) gs ON ot.ontology_term_id = gs.ontology_term_id
        WHERE ggt.go_term_id = orel.subject_term_id
          AND orel.object_term_id = ot.ontology_term_id
          AND edr.external_database_release_id = ot.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name ='GO_RSRC'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_aaSeqId_idx&1 ON &prefixGoTermSummary&1 (aa_sequence_id, go_id, source)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_plugin_ix&1 ON &prefixGoTermSummary&1
               (ontology, gene_source_id, is_not, is_go_slim,
                go_id, go_term_name, evidence_code, evidence_category)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
      each dataset gets one such row.
      Used in dataset record queries.
    </comment>
    <externalDependency name="sres.ExternalDatabase"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE DatasetExampleSourceId&1 AS
        WITH profiles AS (
          SELECT p.source_id,
                 ga.project_id,
                 ga.sequence_id,
                 d.name,
                 row_number() over(partition by d.name
                                   order by ga.chromosome_order_num, p.profile_as_string desc) as rn
          FROM Profile p
            INNER JOIN sres.ExternalDatabase d ON p.dataset_name = d.name
            LEFT JOIN GeneAttributes ga ON p.source_id = ga.source_id
          WHERE p.profile_as_string is not null
        )
        SELECT p.source_id as example_source_id, p.project_id, p.sequence_id, p.name as dataset
        FROM profiles p
        WHERE p.rn = 1
      ]]>
    </sql>
  </tuningTable>


<!-- CHECK AND FIX - regexp_count issue
  <tuningTable name="GeneWord">
     Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneWord&1 AS
        SELECT source_id, taxon_id,
               - for each rn (1 - max_words_in_any_product),
               -    print the rn-th word.
               -    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN
               substr(regexp_replace(regexp_substr (product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
        FROM GeneAttributes
        CROSS JOIN (
          - create a table of integers 1 - n where n is the max number of words in any product
          SELECT generate_series(1,(SELECT max (regexp_count (product, '[ ,]')) + 1 mx FROM GeneAttributes)) as rn
        ) t
        WHERE regexp_substr (product, '[^, ]+', 1, rn) is not null
        ORDER BY source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneWord_idx&1 ON GeneWord&1 (source_id)

      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
      as by project_id(), the function that maps an organism to a project.
    </comment>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="ChIPchipTranscript"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="Profile"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="OrganismCentromere"/>
    <intermediateTable name="SequenceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="PopsetCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE DataSourceCount AS
        SELECT
          taxon_id,
          max(CASE WHEN stype = 'organellar' THEN num ELSE null END) as organellar_has,
          max(CASE WHEN stype = 'Epitope'  THEN num ELSE null END)  as Epitope_has,
          max(CASE WHEN stype = 'Array'  THEN num ELSE null END) as Array_has,
          max(CASE WHEN stype = 'HTSIsolate' THEN num ELSE null END) as HTSIsolate_has,
          max(CASE WHEN stype = 'Popset' THEN num ELSE null END) as Popset_has
        FROM (
          SELECT DISTINCT enas.taxon_id, 'organellar' AS stype, 1 AS num
          FROM dots.externalNAsequence enas, SRES.ontologyterm ot
          WHERE enas.sequence_ontology_id = ot.ontology_term_id
            AND ot.name in( 'mitochondrial_chromosome','apicoplast_chromosome')
          GROUP BY enas.taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'HTSIsolate' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'isolates' AND ds.subtype = 'HTS_SNP'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Popset' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.subtype = 'sequenceing_types'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Epitope' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'epitope'
          GROUP BY taxon_id
          UNION
          SELECT distinct ds.taxon_id, 'Array' AS stype, 1 AS num
          FROM   apidb.DataSource ds
          WHERE ds.type = 'transcript_expression'
            AND ds.subtype = 'array'
          GROUP BY  taxon_id
        ) t
        GROUP BY taxon_id
    ]]>
   </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE OrganismCentromere AS
        SELECT distinct s.taxon_id,
               case when count(*) > 0 then 1 else 0 end as hasCentromere
        FROM  DOTS.MISCELLANEOUS f
            , sres.ontologyTerm ot
            , dots.nasequence s
        WHERE ot.ontology_term_id = f.sequence_ontology_id
         AND ot.name='centromere'
         AND f.na_sequence_id = s.na_sequence_id
        GROUP BY s.taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE SequenceCount AS
        SELECT
          taxon_id,
          max(CASE WHEN sequence_type = 'contig' THEN num ELSE null END) as  contig_num,
          max(CASE WHEN sequence_type = 'supercontig' THEN num ELSE null END) as  supercont_num,
          max(CASE WHEN sequence_type = 'chromosome' THEN num ELSE null END) as  chrom_num
        FROM (
         SELECT count(*) as num, sequence_type, taxon_id
         FROM GenomicSeqAttributes
         WHERE is_top_level =1
         GROUP BY taxon_id, sequence_type
        ) t
        GROUP BY taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE CommunityCount AS
        -- SELECT taxon_id, count(*) as communityCount
        -- TODO:  addd this back
        select taxon_id, 0 as communityCount
        FROM GeneAttributes
        --WHERE
          --(source_id, project_id) IN (
              --SELECT distinct stable_id, project_name
              --userlogins5.mappedComment@prodn.login_comment
              --FROM userlogins5.mappedComment
              --WHERE is_visible = 1
                --AND comment_target_id = 'gene'
          --)
        GROUP BY taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE ProfileCount AS
        SELECT ga.taxon_id,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                 and p.dataset_subtype like '%rt_pcr%'
                 and ga.is_deprecated = 0
                then p.source_id
                else ''
                 end)) as rtPCRCount,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                               and p.dataset_subtype = 'rnaseq'
                               and ga.is_deprecated = 0
                              then p.source_id
                              else ''
                               end)) as rnaSeqCount,
          count(distinct(case when p.dataset_type = 'transcript_expression'
                               and p.dataset_subtype = 'array'
                               and ga.is_deprecated = 0
                              then p.source_id
                              else ''
                               end)) as geneArrayCount
        FROM Profile p
          RIGHT OUTER JOIN GeneAttributes ga ON ga.source_id = p.source_id
        GROUP BY ga.taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE PopsetCount AS
        SELECT count(distinct gene.source_id) as popsetCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, nas.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s, PopsetAttributes i,
                core.tableinfo t, dots.nasequence nas
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND s.pvalue_exp <= -10
           ) sim LEFT JOIN
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, PopsetAttributes i, GeneAttributes g,
                  core.tableinfo t, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  g.end_max
              AND s.max_subject_end >= g.start_min
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           ON gene.source_id = sim.source_id AND gene.sequence_id = sim.sequence_source_id)
        GROUP BY sim.taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE GeneCount AS
        SELECT genomestat.taxon_id,
               genomestat.project_id,
               genomestat.database_version,
               genomestat.ncbi_tax_id,
               genomestat.Megabps,
               coalesce(snpCount.ct,0) as snpCount,
               coalesce(count(distinct ga.source_id),0) as geneCount,
               coalesce(count(distinct case when ga.is_pseudo =1  then ga.source_id else '' end),0) as pseudoGeneCount,
               coalesce(count(distinct case when (ga.gene_type ='protein coding' or ga.gene_type ='protein coding gene') then ga.source_id else '' end),0) as codingGeneCount,
               coalesce(count(distinct case when (ga.gene_type ='protein coding' or ga.gene_type ='protein coding gene') then '' else ga.source_id end),0) as otherGeneCount,
               coalesce(count (distinct (case when ga.is_deprecated = 0
                          then cct.gene_source_id
                          else NULL
                          end)),0) ChipChipGeneCount ,
              coalesce(count (distinct (case when ga.is_deprecated = 0
                          then pp.source_id
                          else NULL
                          end)),0) orthologCount,
              coalesce(count (distinct (case when ga.is_deprecated = 0
                          then gts.gene_source_id
                          else NULL
                          end)),0) goCount,
              coalesce(count (distinct (case when ga.is_deprecated = 0
                          then tfbs.gene_source_id
                          else NULL
                          end)),0) tfbsCount,
              coalesce(count (distinct (case when ga.is_deprecated = 0
                          then mss.aa_sequence_id
                          else NULL
                          end)),0) proteomicsCount,
              coalesce(count (distinct (case when ga.is_deprecated = 0
                          then est.source_id
                          else NULL
                          end)),0) estCount,
              coalesce(count (distinct (case when (ga.is_deprecated = 0 and ta.ec_numbers is not null)
                          then ga.source_id
                          else NULL
                          end)),0) ecNumberCount
        FROM GeneAttributes ga
          LEFT OUTER JOIN apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
          LEFT OUTER JOIN gotermsummary gts on ga.source_id = gts.gene_source_id
          LEFT OUTER JOIN TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
          LEFT OUTER JOIN TranscriptAttributes ta on ta.gene_source_id = ga.source_id
          LEFT OUTER JOIN apidb.MassSpecSummary mss on ta.aa_sequence_id = mss.aa_sequence_id
          LEFT OUTER JOIN chipchipTranscript cct on ga.source_id = cct.gene_source_id
          LEFT OUTER JOIN (
            SELECT distinct s.gene as source_id
            FROM EstAlignmentGeneSummary s, EstAttributes e
            WHERE s.est_gene_overlap_length >= 100
              AND s.is_best_alignment in (1)
              AND s.percent_est_bases_aligned >= 20
              AND s.percent_identity >= 90
              AND e.best_alignment_count <= 1
              AND e.source_id = s.accession
            GROUP by s.gene HAVING count(*) >= 1
          ) est ON ga.source_id = est.source_id
          RIGHT OUTER JOIN (
            SELECT  project_id, taxon_id,
                   max(database_version) as database_version,
                  CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                       ELSE ncbi_tax_id
                  END ncbi_tax_id,
                  to_char(sum(length)/1000000,'9999.99') as megabps
            FROM   GenomicSeqAttributes
            WHERE  is_top_level = 1
            GROUP BY project_ID, taxon_id, ncbi_tax_id
          ) genomestat ON genomestat.taxon_id = ga.taxon_id
          LEFT OUTER JOIN (
             SELECT count(distinct ga.source_id) as ct, ga.taxon_id
             FROM GeneAttributes ga, SnpAttributes sf
             WHERE  sf.gene_source_id = ga.source_id
               AND ga.is_deprecated = 0
             GROUP BY ga.taxon_id
          ) snpCount ON ga.taxon_id = snpCount.taxon_id
        GROUP BY genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 snpCount.ct
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismAttributes&1 AS
        SELECT oa.*, tn2.name as species, t.ncbi_tax_id as species_ncbi_tax_id
               , CASE  WHEN ltrim(replace(oa.organism_name, tn2.name, ''))= oa.organism_name
                       THEN strain_abbrev
                       ELSE ltrim(replace(oa.organism_name, tn2.name, '')) END AS strain
        FROM (
            SELECT o.project_name as project_id,
                   case when t.ncbi_tax_id > 10000000
            --       then 'TMPTX_' || round(t.ncbi_tax_id / 10000000) || '_' ||
            --            mod(t.ncbi_tax_id, 10000000) -- e.g. "TMPTX_930_1"
            --       then 'TMPTX_' || t.ncbi_tax_id -- all the many digits
                     then 'TMPTX_' || o.public_abbrev
                     else 'NCBITAXON_' || t.ncbi_tax_id
                   end as source_id,
                   o.abbrev as internal_abbrev,
                   o.public_abbrev,
                   o.orthomcl_abbrev,
                   o.family_name_for_files,
                   tn.name as organism_name,
                   o.genome_source,
                   o.strain_abbrev,
                   o.is_annotated_genome,
                   o.is_reference_strain,
                   o.is_family_representative,
                   o.name_for_filenames,
                   o.taxon_id as component_taxon_id,
                   gc.database_version,
                   gc.megabps as megabps,
                   gc.ncbi_tax_id as ncbi_tax_id,
                   gc.snpCount as snpCount,
                   gc.geneCount as geneCount,
                   gc.pseudoGeneCount as pseudoGeneCount,
                   gc.codingGeneCount as codingGeneCount,
                   gc.otherGeneCount as otherGeneCount,
                   gc.ChipChipGeneCount as ChipChipGeneCount,
                   gc.orthologCount as orthologCount,
                   gc.goCount as goCount,
                   gc.tfbsCount as tfbsCount,
                   gc.proteomicsCount as proteomicsCount,
                   gc.estCount as estCount,
                   gc.ecNumberCount as ecNumberCount,
                   cast(coalesce(dsc.Organellar_Has, 0) as NUMERIC(1)) as isOrganellar,
                   cast(coalesce(dsc.HTSIsolate_Has, 0) as NUMERIC(1)) as hasHTSIsolate,
                   cast(coalesce(dsc.Popset_Has, 0) as NUMERIC(1)) as hasPopset,
                   cast(coalesce(dsc.Epitope_Has, 0) as NUMERIC(1)) as hasEpitope,
                   cast(coalesce(dsc.Array_Has, 0) as NUMERIC(1)) as hasArray,
                   coalesce(oc.hasCentromere, 0) as hasCentromere,
                   coalesce(sc.contig_num, 0) as contigCount,
                   coalesce(sc.supercont_num, 0) as supercontigCount,
                   coalesce(sc.chrom_num, 0) as chromosomeCount,
                   coalesce(cc.communityCount, 0) as communityCount,
                   coalesce(psc.popsetCount, 0) as popsetCount,
                   coalesce(pc.geneArrayCount, 0) as arrayGeneCount,
                   coalesce(pc.rnaSeqCount, 0) as rnaSeqCount,
                   coalesce(pc.rtPCRCount, 0) as rtPCRCount,
                   coalesce(ta.avg_transcript_length, 0) as avg_transcript_length
            FROM apidb.Organism o
              INNER JOIN sres.TaxonName tn ON tn.taxon_id = o.taxon_id
              INNER JOIN sres.Taxon t ON t.taxon_id = tn.taxon_id
              LEFT JOIN DataSourceCount dsc ON o.taxon_id = dsc.taxon_id
              LEFT JOIN OrganismCentromere oc ON o.taxon_id = oc.taxon_id
              LEFT JOIN SequenceCount sc ON o.taxon_id = sc.taxon_id
              LEFT JOIN CommunityCount cc ON o.taxon_id = cc.taxon_id
              LEFT JOIN GeneCount gc ON o.taxon_id = gc.taxon_id
              LEFT JOIN popsetCount psc ON o.taxon_id = psc.taxon_id
              LEFT JOIN profileCount pc ON o.taxon_id = pc.taxon_id
              LEFT JOIN (
                SELECT taxon_id, round(avg(length),1) as avg_transcript_length
                FROM TranscriptAttributes
                GROUP by taxon_id
              ) ta ON o.taxon_id = ta.taxon_id
            WHERE tn.name_class = 'scientific name'
          ) oa,
          TaxonSpecies ts,
          sres.taxon t,
          sres.taxonname tn2
        WHERE oa.component_taxon_id = ts.taxon_id
          AND ts.species_taxon_id = t.taxon_id
          AND ts.species_taxon_id = tn2.taxon_id
          AND tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PdbSimilarity">
    <comment> Each record maps a gene to a PDB structure. Used by the model to find
      genes that have a PDB structure and to find the PDB structures for a
      given gene.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.PdbSimilarity"/>
    <externalDependency name="apiDB.ProteinDataBank"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE PdbSimilarity&1 AS
        SELECT ta.source_id, eas.source_id AS pdb_chain,
               substr(eas.description, 1, 100) AS pdb_title,
               substr(eas.source_id
                      , 1
                      , length(eas.source_id) - (
                          CASE strpos(reverse(eas.source_id), '_')
                          WHEN 0 THEN length(eas.source_id)
                          ELSE strpos(reverse(eas.source_id), '_') END
                      )
               ) AS pdb_id,
               s.evalue_mant, s.evalue_exp,
               s.pident as percent_identity,
               ROUND((s.length / ta.protein_length) * 100) AS percent_plasmo_coverage,
               SUBSTR(tn.name, 1, 100) AS taxon,
               eas.taxon_id as pdb_taxon_id, ta.taxon_id as gene_taxon_id
        FROM apidb.PdbSimilarity s,
             apiDB.ProteinDataBank eas,
             sres.TaxonName tn,
             TranscriptAttributes ta
        WHERE ta.aa_sequence_id  = s.aa_sequence_id  
          AND s.pident = eas.protein_data_bank_id
          and tn.name_class = 'scientific name'
          AND eas.taxon_id = tn.taxon_id
        ORDER BY ta.source_id, eas.source_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneId" prefixEnabled="true">
    <comment>GeneId maps any valid ID for a gene onto its official ID. These two quantities
      are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
      column is set to 1 for IDs which map to only one gene.

      Most of the CREATE TABLE statement is made up of the union of nine subqueries,
      each of which looks in a different place for gene IDs. Each subquery populates
      the "union_member" field with a different literal string, to make it easier to
      understand which part (or parts) of the SQL is responsible for each ID-to-gene
      mapping.
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <intermediateTable name="OneGeneIds"/>
<!--    <intermediateTable name="CommentAssignment"/>-->
<!--    <intermediateTable name="NewCsi"/>-->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGeneId&1 AS
        SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (0 as NUMERIC(1)) as unique_mapping,
               SUBSTR(string_agg(distinct union_member,'; ' order by union_member), 1, 100) as union_member,
               SUBSTR(string_agg(distinct database_name,'; ' order by database_name), 1, 200) as database_name
        FROM (SELECT substr(t.protein_id, 1, nullif(position('.' IN t.protein_id) - 1, -1)) AS id,
                     gf.source_id AS gene,
                     'Transcript.protein_id before dot' as union_member, ed.name as database_name /* dots.Transcript.protein_id, trimmed at period */
              FROM dots.Transcript t, dots.GeneFeature gf,
                   sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
              WHERE t.parent_id = gf.na_feature_id
                AND substr(t.protein_id, 1, nullif(position('.' IN t.protein_id) - 1, -1)) IS NOT NULL
                AND gf.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
             UNION
              SELECT t.protein_id AS id,
                     gf.source_id AS gene,
                     'Transcript.protein_id' as union_member, ed.name as database_name /* dots.Transcript.protein_id */
              FROM dots.Transcript t, dots.GeneFeature gf,
                   sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
              WHERE t.parent_id = gf.na_feature_id
                AND t.protein_id IS NOT NULL
                AND gf.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
             UNION
              SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
              FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.primary_identifier IS NOT NULL
                AND gf.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id
                      = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                -- CHECK AND FIX
                --AND NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')
                --                          AND NOT REGEXP_LIKE (dr.primary_identifier, '\D') )
                AND NOT ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')
                AND NOT edr.id_type = 'synonym'
             UNION
              SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'DbRef.primary_identifier on Transcript' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
              FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.primary_identifier IS NOT NULL
                AND gf.na_feature_id = t.parent_id
                AND t.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id
                      = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                -- CHECK AND FIX
                --AND NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')
                --                     AND NOT REGEXP_LIKE (dr.primary_identifier, '\D') )
                AND NOT ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')
             UNION
              SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'DbRef.primary_identifier on Gene' as union_member, ed.name as database_name
              FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.primary_identifier IS NOT NULL
                AND gf.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND ed.name ='RefSeq_gene_name'
             UNION
              SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'VectorBase alternate names' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
              FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.primary_identifier IS NOT NULL
                AND gf.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id
                      = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                and ed.name in ('VB_Community_Annotation', 'VB_Community_Symbol') /* vectorbase alt names  */
             UNION
             SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'synonym' as union_member, ed.name as database_name
              FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.primary_identifier IS NOT NULL
                AND gf.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND edr.id_type  = 'synonym'
             UNION
              SELECT dr.secondary_identifier AS id,
                     gf.source_id AS gene,
                     'DbRef.secondary_identifier' as union_member, ed.name as database_name /* sres.DbRef.secondary_identifier */
              FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                   sres.ExternalDatabase ed
              WHERE dr.secondary_identifier IS NOT NULL
                AND gf.na_feature_id = drnf.na_feature_id
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id
                      = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                                'NRDB_pdb_dbXRefBySeqIdentity',
                                'NRDB_ref_dbXRefBySeqIdentity',
                                'NRDB_sp_dbXRefBySeqIdentity',
                                'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                                'GenBank')
             UNION
              SELECT dr.primary_identifier AS id,
                     gf.source_id AS gene,
                     'genbank DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier for Genbank records */
              FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
                   sres.DbRef dr, sres.ExternalDatabaseRelease edr,
                    sres.ExternalDatabase ed
              WHERE gf.na_feature_id = t.parent_id
                AND t.na_sequence_id = drns.na_sequence_id
                AND drns.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND ed.name = 'GenBank'
             UNION
              SELECT pred_loc.feature_source_id AS id,
                     gene_loc.feature_source_id AS gene,
                     'overlapping predicted gene source_id' as union_member, ed.name as database_name /* dots.GeneFeature.source_id for predicted genes that overlap */
              FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc,
                   sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              WHERE pred_loc.feature_type = 'GenePrediction'
                AND gene_loc.feature_type = 'GeneFeature'
                AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
                AND gene_loc.start_min <= pred_loc.end_max
                AND gene_loc.end_max >= pred_loc.start_min
                AND pred_loc.is_reversed = gene_loc.is_reversed
                AND pred_loc.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
             UNION
              SELECT ng.name AS id, gf.source_id AS gene,
                     'NaGene' as union_member, ed.name as database_name /* dots.NaGene.name */
              FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
                   sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              WHERE gf.na_feature_id = nfng.na_feature_id
                AND ng.na_gene_id = nfng.na_gene_id
                AND gf.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
             UNION
              SELECT source_id AS id, source_id AS gene,
                     'same ID' as union_member, ed.name as database_name /* same ID (reflexive mapping) */
              FROM dots.GeneFeature gf,
                   sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              WHERE gf.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
             UNION
              SELECT n.name AS id, gf.source_id AS gene,
                     'gene name' as union_member, d.name as database_name -- apidb.GeneFeatureName.name
              from dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
                   (  select na_feature_id, name
                      from apidb.GeneFeatureName
                      where is_preferred = 1
                    EXCEPT
                      -- suppress gene/name associations from the *DELETED_RSRC databases
                      select gfn.na_feature_id, gfn.name
                      from apidb.GeneFeatureName gfn,
                           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
                      where gfn.external_database_release_id = edr.external_database_release_id
                        and ed.external_database_id = edr.external_database_id
                        and ed.name like '%DELETED_RSRC'
                   ) n
              where n.na_feature_id = gf.na_feature_id
                and gf.external_database_release_id = r.external_database_release_id
                and r.external_database_id = d.external_database_id
             UNION
              select dr.primary_identifier as id,
                     gf.source_id as gene,
                     'AA feature DbRef primary ID' as union_member,
                     ed.name as database_name /* DbRef.primary_identifier mapped through DbRefAaFeature */
              from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
                   dots.DbRefAaFeature draf,  sres.DbRef dr,
                   sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              where gf.na_feature_id = t.parent_id
                and t.na_feature_id = taf.na_feature_id
                and taf.aa_feature_id = draf.aa_feature_id
                and draf.db_ref_id = dr.db_ref_id
                and dr.external_database_release_id = edr.external_database_release_id
                and edr.external_database_id = ed.external_database_id
                and ed.name
                    not in ('INTERPRO', 'PFAM', 'PIRSF', 'PRODOM', 'PROSITEPROFILES',
                            'SMART', 'SUPERFAMILY', 'TIGRFAM', 'CDD','HAMAP','HMMPANTHER',
                            'PRINTS','SCANPROSITE','SFLD')
            ) mapping,
              dots.GeneFeature gf, dots.NaSequence ns
        WHERE mapping.gene = gf.source_id
          AND gf.na_sequence_id = ns.na_sequence_id
          AND (ns.taxon_id::varchar = '&filterValue' or length('&filterValue') = 0)
          AND (gf.is_predicted != 1 OR gf.is_predicted is null)
        GROUP BY mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
        INSERT INTO &prefixGeneId&1
                    (id, gene, unique_mapping, union_member, database_name)
        WITH munge
             AS (SELECT DISTINCT
                        regexp_replace(id, '\.\d\d?$', '') as id,
                        gene, unique_mapping, union_member, database_name
                 FROM &prefixGeneId&1
                -- CHECK AND FIX
                 --WHERE regexp_like(id, '(.*)\.\d\d?$')
                 )
        SELECT id, gene, 0 as unique_mapping, 'base ID' as union_member, database_name
        FROM munge
        WHERE id NOT IN (SELECT id FROM &prefixGeneId&1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE &prefixOneGeneIds (lower_id) AS
        SELECT lower_id
        FROM (SELECT DISTINCT lower(id) as lower_id, gene
              FROM &prefixGeneId&1
        ) t
        GROUP BY lower_id
        HAVING count(*) = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX gix&1_pk ON &prefixOneGeneIds (lower_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixGeneId&1
        SET unique_mapping = 1
        WHERE id = gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixGeneId&1
        SET unique_mapping = 1
        WHERE lower(id) IN (select lower_id from &prefixOneGeneIds)
      ]]>
    </sql>
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        CREATE UNLOGGED TABLE &prefixCommentAssignment AS-->
<!--        WITH projects AS-->
<!--               (SELECT DISTINCT project_id FROM &prefixGenomicSeqAttributes),-->
<!--             project_comments AS-->
<!--               (SELECT stable_id, comment_id-->
<!--                FROM userlogins5.comments@&dblink-->
<!--                WHERE project_name in (select project_id FROM projects)-->
<!--                  AND comment_target_id = 'gene')-->
<!--          SELECT stable_id, comment_id-->
<!--          FROM project_comments-->
<!--        UNION-->
<!--          SELECT csi.stable_id, csi.comment_id-->
<!--          FROM project_comments pc, userlogins5.commentStableId@&dblink csi-->
<!--          WHERE csi.comment_id = pc.comment_id-->
<!--      ]]>-->
<!--    </sql>-->
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        CREATE UNLOGGED TABLE &prefixNewCsi as-->
<!--        SELECT stable_id, comment_id, userlogins5.CommentStableId_pkseq.nextval@&dblink as comment_stable_id-->
<!--        FROM (  SELECT gi.gene AS stable_id, ca.comment_id-->
<!--                FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca-->
<!--                WHERE gi.id = ca.stable_id-->
<!--                  AND gi.id != gi.gene-->
<!--                EXCEPT-->
<!--                SELECT stable_id, comment_id-->
<!--                FROM &prefixCommentAssignment ca)-->
<!--      ]]>-->
<!--    </sql>-->
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        INSERT INTO userlogins5.CommentStableId@&dblink-->
<!--                   (stable_id, comment_id, comment_stable_id)-->
<!--        SELECT stable_id, comment_id, comment_stable_id-->
<!--        FROM &prefixNewCsi-->
<!--      ]]>-->
<!--    </sql>-->
  </tuningTable>


  <tuningTable name="GenomicSequenceId">
  <comment> This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    </comment>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenomicSequenceId&1 AS
        SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
        FROM (
          SELECT ns.source_id as id, ns.source_id as sequence
          FROM dots.NaSequence ns, sres.OntologyTerm oterm
          WHERE ns.sequence_ontology_id = oterm.ontology_term_id
            AND oterm.name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome','maxicircle','kinetoplast')
          UNION
          SELECT dr.primary_identifier AS id, ns.source_id AS sequence
          FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
               sres.DbRef dr, sres.ExternalDatabaseRelease edr,
               sres.ExternalDatabase ed
          WHERE dr.primary_identifier IS NOT NULL
            AND ns.na_sequence_id = drnf.na_sequence_id
            AND drnf.db_ref_id = dr.db_ref_id
            AND dr.external_database_release_id
                  = edr.external_database_release_id
            AND edr.external_database_id = ed.external_database_id
        ) subquery1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GenSeqId_sequence_idx&1 ON GenomicSequenceId&1 (sequence, id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GenSeqId_id_idx&1 ON GenomicSequenceId&1 (id, sequence)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GenSeqId_lowid_idx&1 ON GenomicSequenceId&1 (lower(id), sequence)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <comment> Used by GeneTables.Epitopes to map a gene to its epitopes.
    </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE EpitopeSummary&1 AS
        SELECT t.source_id,
                      al.start_min||'-'||al.end_max AS location,
                      ef.source_id as iedb_id,
               mas.sequence,
               SUBSTR(tn.name, 1, 100) AS name,
               CASE ef.type
                WHEN 'Not Full Set Not on Blast Hit' THEN 'Low'
                WHEN 'Not Full Set On Blast Hit' THEN 'Medium'
                WHEN 'Full Set Not on Blast Hit' THEN 'Medium'
                WHEN 'Full Set On Blast Hit' THEN 'High'
                ELSE 'unknown epitope type'
               END AS confidence
        FROM dots.Transcript t,
             dots.TranslatedAaFeature taf,
             dots.MotifAaSequence mas,
             dots.TranslatedAaSequence tas,
             dots.EpitopeFeature ef,
             dots.AaLocation al,
             sres.TaxonName tn
        WHERE taf.na_feature_id = t.na_feature_id
          AND taf.aa_sequence_id = tas.aa_sequence_id
          AND tas.aa_sequence_id = ef.aa_sequence_id
          AND ef.aa_feature_id = al.aa_feature_id
          AND ef.motif_aa_sequence_id = mas.aa_sequence_id
          AND tas.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptCenDistance">
    <comment> Stores (transcript, sequence, distance from centromere) 3-tuples for transcripts
      that lie on a sequence for which we have a centomere location.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE TranscriptCenDistance&1 AS
        SELECT DISTINCT tl.feature_source_id AS transcript,
               LEAST(ABS(mfl.start_min - tl.end_max),
                     ABS(mfl.end_max - tl.start_min)) AS centromere_distance,
               tl.sequence_source_id AS genomic_sequence
        FROM apidb.TranscriptLocation tl, apidb.FeatureLocation mfl,
             sres.OntologyTerm so
        WHERE tl.na_sequence_id = mfl.na_sequence_id
          AND mfl.feature_type = 'Miscellaneous'
          AND mfl.sequence_ontology_id = so.ontology_term_id
          AND so.name = 'centromere'
          AND tl.is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GCent_loc_ix&1
               on TranscriptCenDistance&1 (genomic_sequence, centromere_distance)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinAttributes" prefixEnabled="true">
    <comment>The BFMV for proteins. Each protein gets a single record, which
      stores all its attributes. Used mainly to create TranscriptAttributes
    </comment>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="SignalPeptideDomains"/>
    <externalDependency name="apidb.CdsLocation"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.EnzymeClass"/>
    <ancillaryTable name="GoTermList"/>
    <ancillaryTable name="ProteinGoAttributes"/>
    <ancillaryTable name="ProteinAttrsEc"/>
    <ancillaryTable name="ProteinAttrsEcDerived"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGoTermList&1 AS
        SELECT aa_sequence_id, ontology, source,
             string_agg(go_term_name, ';' ORDER BY go_term_name) AS go_terms,
             string_agg(go_id, ';' ORDER BY go_term_name) AS go_ids
        FROM (
          SELECT aa_sequence_id, ontology,
                 CASE evidence_code WHEN 'IEA' THEN 'predicted' ELSE 'annotated' END AS source, go_term_name, go_id
          FROM  &prefixGeneGoTerms
        ) t
        GROUP BY aa_sequence_id, ontology, source
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixProteinGoAttributes&1 AS
        SELECT DISTINCT gts.aa_sequence_id,
               substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
               substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
               substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
               substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
               substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
               substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process,
               substr(annotated_go_component.go_ids, 1, 300) AS annotated_go_id_component,
               substr(annotated_go_function.go_ids, 1, 300) AS annotated_go_id_function,
               substr(annotated_go_process.go_ids, 1, 300) AS annotated_go_id_process,
               substr(predicted_go_component.go_ids, 1, 300) AS predicted_go_id_component,
               substr(predicted_go_function.go_ids, 1, 300) AS predicted_go_id_function,
               substr(predicted_go_process.go_ids, 1, 300) AS predicted_go_id_process
        FROM
          (SELECT DISTINCT aa_sequence_id FROM &prefixGoTermSummary) gts
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'annotated' AND ontology = 'Cellular Component'
          ) annotated_go_component ON
            gts.aa_sequence_id = annotated_go_component.aa_sequence_id
            AND 'annotated' = annotated_go_component.source
            AND 'Cellular Component' = annotated_go_component.ontology
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'annotated' AND ontology = 'Molecular Function'
          ) annotated_go_function ON
            gts.aa_sequence_id = annotated_go_function.aa_sequence_id
            AND 'annotated' = annotated_go_function.source
            AND 'Molecular Function' = annotated_go_function.ontology
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'annotated' AND ontology = 'Biological Process'
          ) annotated_go_process ON
            gts.aa_sequence_id = annotated_go_process.aa_sequence_id
            AND 'annotated' = annotated_go_process.source
            AND 'Biological Process' = annotated_go_process.ontology
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'predicted' AND ontology = 'Cellular Component'
          ) predicted_go_component ON
            gts.aa_sequence_id = predicted_go_component.aa_sequence_id
            AND 'predicted' = predicted_go_component.source
            AND 'Cellular Component' = predicted_go_component.ontology
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'predicted' AND ontology = 'Molecular Function'
          ) predicted_go_function ON
            gts.aa_sequence_id = predicted_go_function.aa_sequence_id
            AND 'predicted' = predicted_go_function.source
            AND 'Molecular Function' = predicted_go_function.ontology
          LEFT JOIN (
            SELECT * FROM &prefixGoTermList&1
            WHERE source = 'predicted' AND ontology = 'Biological Process'
          ) predicted_go_process ON
            gts.aa_sequence_id = predicted_go_process.aa_sequence_id
            AND 'predicted' = predicted_go_process.source
            AND 'Biological Process' = predicted_go_process.ontology
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ProteinGoAttr_aaSequenceId&1 ON &prefixProteinGoAttributes&1 (aa_sequence_id)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE &prefixtProteinAttrsEc&1 AS
            SELECT aa_sequence_id, SUBSTR(string_agg(ec_number, ';' order by ec_number),1, 300) AS ec_numbers
            FROM (SELECT DISTINCT asec.aa_sequence_id,
                        ec.ec_number || ' (' || ec.description || ')' AS ec_number
                 FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                 WHERE ec.enzyme_class_id = asec.enzyme_class_id
                  AND NOT asec.evidence_code = 'OrthoMCLDerived'
            ) t
            GROUP BY aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixtProteinAttrsEcDerived&1 AS
            SELECT aa_sequence_id, SUBSTR(string_agg(ec_number, ';' order by ec_number),1, 300) AS ec_numbers_derived
            FROM (SELECT DISTINCT asec.aa_sequence_id,
                        ec.ec_number || ' (' || ec.description || ')' AS ec_number
                 FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                 WHERE ec.enzyme_class_id = asec.enzyme_class_id
                  AND asec.evidence_code = 'OrthoMCLDerived'
            ) t
            GROUP BY aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixProteinAttributes&1 AS
        SELECT pi.name as project_id,
          tas.source_id, tas.aa_sequence_id,
          t.source_id as transcript_source_id,
          gf.source_id as gene_source_id,
          cdsl.na_sequence_id as na_sequence_id,
          cdsl.is_reversed,
          cdsl.start_min as cds_start,
          cdsl.end_max as cds_end,
          (taf.translation_stop - taf.translation_start) + 1 AS cds_length,
             length(tas.sequence) AS protein_length,
             coalesce(transmembrane.tm_domains, 0) AS tm_count,
          tas.molecular_weight,
          asa.min_molecular_weight, asa.max_molecular_weight,
          asa.isoelectric_point, asa.hydropathicity_gravy_score,
          asa.aromaticity_score,
          SUBSTR(sigp.peptide_sequence, 1, 200) as signalp_peptide,
          ec_numbers,
          ec_numbers_derived,
          go.annotated_go_component,
          go.annotated_go_function,
          go.annotated_go_process,
          go.predicted_go_component,
          go.predicted_go_function,
          go.predicted_go_process,
          go.annotated_go_id_component,
          go.annotated_go_id_function,
          go.annotated_go_id_process,
          go.predicted_go_id_component,
          go.predicted_go_id_function,
          go.predicted_go_id_process,
          SUBSTR(coalesce(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
          0 AS has_seqedit,
          row_number() over (partition by t.source_id order by tas.length desc) as rank_in_transcript,
          uniprot.uniprot_ids
        FROM
          core.ProjectInfo pi
          INNER JOIN dots.Transcript t ON t.row_project_id = pi.project_id
          INNER JOIN dots.GeneFeature gf ON gf.na_feature_id = t.parent_id
          INNER JOIN dots.TranslatedAaFeature taf ON t.na_feature_id = taf.na_feature_id
          INNER JOIN dots.TranslatedAaSequence tas ON taf.aa_sequence_id = tas.aa_sequence_id
          LEFT JOIN dots.RnaType rt2 ON gf.na_feature_id = rt2.parent_id
          LEFT JOIN dots.RnaType rt1 ON t.na_feature_id = rt1.parent_id
          LEFT JOIN apidb.AaSequenceAttribute asa ON taf.aa_sequence_id = asa.aa_sequence_id
          LEFT JOIN &prefixProteinGoAttributes&1 go ON tas.aa_sequence_id = go.aa_sequence_id
          LEFT JOIN (
            SELECT aa_sequence_id, string_agg(peptide_sequence, ', ') peptide_sequence
            FROM (SELECT DISTINCT aa_sequence_id, peptide_sequence FROM &prefixSignalPeptideDomains) t
            GROUP BY aa_sequence_id
          ) sigp ON tas.aa_sequence_id = sigp.aa_sequence_id
          LEFT JOIN (
            SELECT protein_source_id, na_sequence_id, is_reversed,
               MIN(start_min) AS start_min, MAX(end_max) AS end_max
            FROM apidb.CdsLocation WHERE is_top_level=1
            GROUP BY protein_source_id, na_sequence_id, is_reversed
          ) cdsl ON tas.source_id = cdsl.protein_source_id
          LEFT JOIN (
            SELECT aa_sequence_id, max(tm_domains) AS tm_domains
            FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                 FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                 WHERE tmaf.aa_feature_id = al.aa_feature_id
                 GROUP BY tmaf.aa_sequence_id) tms
            GROUP BY tms.aa_sequence_id
          ) transmembrane ON tas.aa_sequence_id = transmembrane.aa_sequence_id
          LEFT JOIN &prefixProteinAttrsEc&1 ec ON tas.aa_sequence_id = ec.aa_sequence_id
          LEFT JOIN &prefixProteinAttrsEcDerived&1 ecDerived ON tas.aa_sequence_id = ecDerived.aa_sequence_id
          LEFT JOIN (
            SELECT af.aa_sequence_id,
                   string_agg(dbref.primary_identifier, ',' order by dbref.primary_identifier) as uniprot_ids
            FROM sres.ExternalDatabase d, sres.ExternalDatabaseRelease r,
                sres.DbRef, dots.DbRefAaFeature daf, dots.AaFeature af
            WHERE d.name like 'Uniprot%'
              AND d.external_database_id = r.external_database_id
              AND r.external_database_release_id = dbref.external_database_release_id
              AND dbref.db_ref_id = daf.db_ref_id
              AND daf.aa_feature_id = af.aa_feature_id
            GROUP BY af.aa_sequence_id
          ) uniprot ON tas.aa_sequence_id = uniprot.aa_sequence_id
        ORDER BY tas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixProteinAttributes&1 gaup
       set has_seqedit  = 1
       where source_id in (select source_id from apidb.seqedit)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX PA_sourceId&1 ON &prefixProteinAttributes&1 (source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX PA_aaSequenceId&1 ON &prefixProteinAttributes&1 (aa_sequence_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
      stores all its attributes. Used widely, in the model and elsewhere, for
      queries involving genes, as well as in the creation of more than a
      dozen other tuning tables.
    </comment>
    <internalDependency name="GeneId"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="GeneProduct"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.IntronLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <internalDependency name="SnpAttributes"/>
    <internalDependency name="GeneLocations"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.UtrLocation"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <ancillaryTable name="TranscriptUniprot"/>
    <sql>
      <![CDATA[
        CREATE table &prefixTranscriptUniprot&1 AS
        select na_feature_id,
               substr(string_agg(uniprot_id, ',' order by uniprot_id), 1, 240) as uniprot_id,
               substr(string_agg(uniprot_id, '+or+' order by uniprot_id), 1, 240) as uniprot_id_internal
        FROM (SELECT DISTINCT t.na_feature_id, dr.primary_identifier as uniprot_id
              FROM sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                   sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
              WHERE dr.db_ref_id = x.DB_REF_ID
              AND (x.na_feature_id = t.na_feature_id --
                   or x.na_feature_id = t.parent_id)
              AND dr.external_database_release_id = r.external_database_release_id
              AND r.external_database_id = d.external_database_id
              AND (d.name like '%uniprot_dbxref_RSRC'
                   OR d.name like '%dbxref_gene2Uniprot_RSRC'
                   OR d.name = 'Links to Uniprot Genes'
                   OR d.name like '%_dbxref_uniprot_linkout_RSRC'
                   OR d.name like '%_dbxref_uniprot_from_annotation_RSRC')
             ) t
        GROUP BY na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixTranscriptAttributes&1 AS
        WITH genefeat AS (
          SELECT DISTINCT
            cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar(20)) as project_id,
            -- first the gene attributes:
            gf.source_id AS gene_source_id,
            gf.na_feature_id AS gene_na_feature_id,
            LEAST(nl.start_min, nl.end_max) AS gene_start_min,
            GREATEST(nl.start_min, nl.end_max) AS gene_end_max,
            COALESCE(preferred_name.name, any_name.name) AS gene_name,
            cast(coalesce(preferred_gene_product.product, any_gene_product.product, gf.product)
              as VARCHAR(300)) as old_gene_product,
            COALESCE(gp.product, 'unspecified product') as gene_product,
            REPLACE(so.name, '_', ' ') AS gene_type,
            gf.name as gene_ebi_biotype,
            gi.gene_id,
            transcripts.gene_transcript_count,
            exons.gene_exon_count,
            olds.old_ids AS gene_previous_ids,
            coalesce(deprecated.is_deprecated, 0) as is_deprecated,
            GREATEST(1, least(nl.start_min, nl.end_max) - 15000) AS gene_context_start,
            LEAST(gsa.length, greatest(nl.start_min, nl.end_max) + 15000) AS gene_context_end,
            GREATEST(1, least(nl.start_min, nl.end_max) - 1500) AS gene_zoom_context_start,
            LEAST(gsa.length, greatest(nl.start_min, nl.end_max) + 1500) AS gene_zoom_context_end,
            CAST(orthologs.name AS VARCHAR(60)) AS orthomcl_name,
            coalesce(tothtssnps.total_hts_snps,0) AS gene_total_hts_snps,
            coalesce(tothtssnps.hts_nonsynonymous_snps,0) AS gene_hts_nonsynonymous_snps,
            coalesce(tothtssnps.hts_stop_codon_snps,0) AS gene_hts_stop_codon_snps,
            coalesce(tothtssnps.hts_noncoding_snps,0) AS gene_hts_noncoding_snps,
            coalesce(tothtssnps.hts_synonymous_snps,0) AS gene_hts_synonymous_snps,
            coalesce(tothtssnps.hts_nonsyn_syn_ratio,0) AS gene_hts_nonsyn_syn_ratio,
            CAST(cmnt.comment_string AS VARCHAR(300)) AS comment_string,
            entrez_table.entrez_id AS gene_entrez_id,
            gloc.locations AS gene_locations,
            CAST(gsa.source_id AS VARCHAR(50)) AS sequence_id,
            CAST(SUBSTR(tn.name, 1, 80) AS VARCHAR(80)) AS organism,
            CAST(species_name.name AS VARCHAR(60)) AS species,
            LTRIM(REGEXP_REPLACE(tn.name, replace (replace (species_name.name,'[',''), ']','') ,'')) AS strain,
            taxon.ncbi_tax_id,  tn.taxon_id,
            so.source_id as so_id,
            CAST(so.name AS VARCHAR(150)) AS so_term_name,
            CAST(SUBSTR(so.definition, 1, 150) AS VARCHAR(150)) AS so_term_definition,
            CAST(soRls.version AS VARCHAR(7)) AS so_version,
            rt2.anticodon rt2_anticodon,
            ed.name AS external_db_name,
            edr.version AS external_db_version,
            edr.external_database_release_id AS external_db_rls_id,
            CAST(gsa.chromosome AS VARCHAR(20)) AS chromosome,
            gsa.sequence_type,
            gsa.chromosome_order_num, gsa.na_sequence_id
          FROM dots.GeneFeature gf
            INNER JOIN apidb.FeatureLocation nl ON gf.na_feature_id = nl.na_feature_id
            INNER JOIN sres.OntologyTerm so ON gf.sequence_ontology_id = so.ontology_term_id
            INNER JOIN &prefixGeneLocations gloc ON gf.source_id = gloc.source_id
            LEFT JOIN &prefixGeneProduct gp ON gf.source_id = gp.source_id
            INNER JOIN sres.ExternalDatabaseRelease edr ON gf.external_database_release_id = edr.external_database_release_id
            INNER JOIN sres.ExternalDatabase ed ON edr.external_database_id = ed.external_database_id
            INNER JOIN &prefixGenomicSeqAttributes gsa ON nl.na_sequence_id = gsa.na_sequence_id
            INNER JOIN sres.TaxonName tn ON gsa.taxon_id = tn.taxon_id
            INNER JOIN sres.Taxon ON gsa.taxon_id = taxon.taxon_id
            INNER JOIN sres.externalDatabaseRelease soRls ON so.external_database_release_id = soRls.external_database_release_id
            INNER JOIN (
              SELECT DISTINCT gene AS source_id FROM &prefixGeneId
            ) gene ON gf.source_id = gene.source_id
            LEFT JOIN dots.RnaType rt2 ON gf.na_feature_id = rt2.parent_id
            LEFT JOIN &prefixTaxonSpecies ts ON gsa.taxon_id = ts.taxon_id
            LEFT JOIN dots.geneinstance gi ON gf.na_feature_id = gi.na_feature_id
            INNER JOIN sres.TaxonName species_name ON ts.species_taxon_id = species_name.taxon_id
            LEFT JOIN (
              SELECT parent_id, count(*) AS gene_transcript_count
              FROM dots.Transcript
              GROUP BY parent_id
            ) transcripts ON gf.na_feature_id = transcripts.parent_id
            LEFT JOIN (
              SELECT parent_id, count(*) AS gene_exon_count
              FROM dots.ExonFeature
              GROUP BY parent_id
            ) exons ON gf.na_feature_id = exons.parent_id
            LEFT JOIN (
              SELECT nfc.na_feature_id, MAX(SUBSTR(nfc.comment_string, 300, 1)) AS comment_string
              FROM dots.NaFeatureComment nfc
              GROUP BY nfc.na_feature_id
            ) cmnt ON gf.na_feature_id = cmnt.na_feature_id
            LEFT JOIN (
              SELECT distinct drnf.na_feature_id as gene_na_feature_id, 1 as is_deprecated
              FROM dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              WHERE drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC'
            ) deprecated ON gf.na_feature_id = deprecated.gene_na_feature_id
            LEFT JOIN (
              SELECT gene_source_id, total_hts_snps, hts_nonsynonymous_snps, hts_stop_codon_snps,hts_noncoding_snps,hts_synonymous_snps,
                case when (hts_nonsynonymous_snps is null) then 0
                when (hts_synonymous_snps = 0) then 0
                else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio
              FROM (
                select gene_source_id,
                  count(*) as total_hts_snps,
                  sum(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                  sum(has_stop_codon) as hts_stop_codon_snps,
                  sum(is_noncoding_snp) as hts_noncoding_snps,
                  count(*) - sum(has_nonsynonymous_allele) - sum(has_stop_codon) - sum(is_noncoding_snp)  as hts_synonymous_snps
                FROM &prefixSnpAttributes
                WHERE  gene_source_id is not null
                GROUP by gene_source_id
              ) t
            ) tothtssnps ON gf.source_id = tothtssnps.gene_source_id
            LEFT JOIN (
              SELECT ssg.sequence_id as gene_na_feature_id, sg.name
              FROM dots.SequenceSequenceGroup ssg,
                   dots.sequencegroup sg, core.tableinfo ti
              WHERE ssg.sequence_group_id = sg.sequence_group_id
                AND ssg.source_table_id = ti.table_id
                AND ti.name = 'GeneFeature'
            ) orthologs ON gf.na_feature_id = orthologs.gene_na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(product) as product
              FROM apidb.GeneFeatureProduct
              WHERE is_preferred = 1
              GROUP BY na_feature_id
            ) preferred_gene_product ON gf.na_feature_id = preferred_gene_product.na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(product) as product
              FROM apidb.GeneFeatureProduct
              GROUP BY na_feature_id
            ) any_gene_product ON gf.na_feature_id = any_gene_product.na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(name) as name
              FROM apidb.GeneFeatureName
              WHERE is_preferred = 1
              GROUP BY na_feature_id
              EXCEPT
                  -- suppress gene/name associations from the *DELETED_RSRC databases
              SELECT gfn.na_feature_id, gfn.name
              FROM apidb.GeneFeatureName gfn,
                   sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
              WHERE gfn.external_database_release_id = edr.external_database_release_id
                AND ed.external_database_id = edr.external_database_id
                AND ed.name like '%DELETED_RSRC'
            ) preferred_name ON gf.na_feature_id = preferred_name.na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(name) as name
              FROM apidb.GeneFeatureName
              GROUP by na_feature_id
              EXCEPT
              -- suppress gene/name associations from the *DELETED_RSRC databases
              SELECT gfn.na_feature_id, gfn.name
              FROM apidb.GeneFeatureName gfn,
                   sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
              WHERE gfn.external_database_release_id = edr.external_database_release_id
                AND ed.external_database_id = edr.external_database_id
                AND ed.name like '%DELETED_RSRC'
            ) any_name ON gf.na_feature_id = any_name.na_feature_id
            LEFT JOIN (
              SELECT dbna.na_feature_id,
                     substr(string_agg(db.primary_identifier, ',' order by db.primary_identifier), 1, 300) as entrez_id
              FROM sres.ExternalDatabaseRelease edr, sres.DbRef db,
                   dots.DbRefNaFeature dbna, sres.ExternalDatabase ed
              WHERE edr.external_database_release_id = db.external_database_release_id
                AND ed.external_database_id = edr.external_database_id
                AND dbna.db_ref_id = db.db_ref_id
                AND lower(ed.name) like '%entrez%'
              GROUP BY dbna.na_feature_id
            ) entrez_table ON gf.na_feature_id = entrez_table.na_feature_id
            LEFT JOIN (
              SELECT drnf.na_feature_id,
                     substr(string_agg(dr.primary_identifier, ';' order by dr.primary_identifier), 1, 900) as old_ids
              FROM dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
              WHERE dr.primary_identifier is not null
                AND drnf.db_ref_id = dr.db_ref_id
                AND dr.external_database_release_id = edr.external_database_release_id
                AND edr.external_database_id = ed.external_database_id
                AND edr.id_type = 'previous id'
              GROUP BY drnf.na_feature_id
            ) olds ON gf.na_feature_id = olds.na_feature_id
          WHERE nl.is_top_level = 1
            AND nl.feature_type = 'GeneFeature'
            AND (gsa.taxon_id::varchar = '&filterValue' OR length('&filterValue') = 0)
            AND species_name.name_class = 'scientific name'
            AND (gf.is_predicted != 1 OR gf.is_predicted is null)
            AND tn.name_class = 'scientific name'
            AND tn.taxon_id NOT IN (SELECT o.taxon_id FROM apidb.Organism o WHERE o.is_annotated_genome=0)
            AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
        ), transcript AS (
          SELECT DISTINCT
            t.parent_id as transcript_parent_id,
            -- first the gene attributes:
            cast(null as varchar(80)) as representative_transcript,
            0 as gene_paralog_number, 0 as gene_ortholog_number,
            transcript_uniprot.uniprot_id, transcript_uniprot.uniprot_id_internal,
            -- next the transcript attributes:
            t.source_id AS transcript_source_id,
            tso.name as transcript_type,
            t.na_feature_id,
            CAST(coalesce(preferred_tx_product.product, any_tx_product.product, t.product)
              AS VARCHAR(300))
              AS transcript_product,
            tl.start_min, tl.end_max,
            tl.is_reversed,   --CHECK if needed
            CASE coalesce(tl.is_reversed, 0) WHEN 0 THEN 'forward' WHEN 1 THEN 'reverse' ELSE tl.is_reversed::varchar END AS strand,
            CASE t.is_pseudo WHEN null THEN 0 ELSE t.is_pseudo END as is_pseudo,
            transcript_exons.exon_count,
            sns.length AS length, sns.na_sequence_id as spliced_na_sequence_id,
            rt1.anticodon rt1_anticodon,
            utr_lengths.five_prime_utr_length,
            utr_lengths.three_prime_utr_length
          FROM dots.Transcript t
            LEFT JOIN dots.RnaType rt1 ON t.na_feature_id = rt1.parent_id
            LEFT JOIN dots.SplicedNaSequence sns ON t.na_sequence_id = sns.na_sequence_id
            INNER JOIN sres.OntologyTerm tso ON t.sequence_ontology_id = tso.ontology_term_id
            INNER JOIN apidb.TranscriptLocation tl ON tl.feature_source_id =  t.source_id
            INNER JOIN (
              SELECT rna_feature_id, count(*) as exon_count
              FROM dots.RnaFeatureExon
              GROUP BY rna_feature_id
            ) transcript_exons ON t.na_feature_id = transcript_exons.rna_feature_id
            INNER JOIN (
              SELECT t.na_feature_id as transcript_na_feature_id, five_prime.utr_length as five_prime_utr_length, three_prime.utr_length as three_prime_utr_length
              FROM dots.transcript t
                LEFT JOIN (
                  SELECT parent_id, sum(end_max-start_min + 1) as utr_length FROM apidb.UtrLocation
                  WHERE direction = 5 AND is_top_level = 1
                  GROUP BY parent_id
                 ) five_prime ON t.na_feature_id = five_prime.parent_id
                LEFT JOIN (
                  SELECT parent_id, sum(end_max-start_min + 1) as utr_length FROM apidb.UtrLocation
                  WHERE direction = 3 AND is_top_level = 1
                  GROUP BY parent_id
                ) three_prime ON t.na_feature_id = three_prime.parent_id
            ) utr_lengths ON t.na_feature_id = utr_lengths.transcript_na_feature_id
            LEFT JOIN &prefixTranscriptUniprot&1 transcript_uniprot ON t.na_feature_id = transcript_uniprot.na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(product) as product
              FROM apidb.TranscriptProduct
              WHERE is_preferred = 1
              GROUP BY na_feature_id
            ) preferred_tx_product ON t.na_feature_id = preferred_tx_product.na_feature_id
            LEFT JOIN (
              SELECT na_feature_id, max(product) as product
              FROM apidb.TranscriptProduct
              GROUP BY na_feature_id
            ) any_tx_product ON t.na_feature_id = any_tx_product.na_feature_id
          WHERE
            tl.is_top_level=1
        )
        SELECT DISTINCT
          genefeat.project_id,
          transcript.transcript_source_id AS source_id,
          -- first the gene attributes:
          genefeat.gene_source_id,
          genefeat.gene_na_feature_id,
          genefeat.gene_start_min,
          genefeat.gene_end_max,
          genefeat.gene_name,
          CAST(COALESCE(genefeat.old_gene_product, transcript.transcript_product,
                        case when transcript.is_pseudo = 1
                          then 'pseudogene'
                          else 'unspecified product'
                        end
                ) as VARCHAR(300)
            ) as old_gene_product,
          genefeat.gene_product,
          genefeat.gene_type,
          genefeat.gene_ebi_biotype,
          genefeat.gene_id,
          genefeat.gene_transcript_count,
          genefeat.gene_exon_count,
          cast(null as varchar(80)) as representative_transcript,
          genefeat.gene_previous_ids,
          genefeat.is_deprecated,
          0 as gene_paralog_number, 0 as gene_ortholog_number,
          genefeat.gene_context_start,
          genefeat.gene_context_end,
          genefeat.gene_zoom_context_start,
          genefeat.gene_zoom_context_end,
          genefeat.orthomcl_name,
          genefeat.gene_total_hts_snps,
          genefeat.gene_hts_nonsynonymous_snps,
          genefeat.gene_hts_stop_codon_snps,
          genefeat.gene_hts_noncoding_snps,
          genefeat.gene_hts_synonymous_snps,
          genefeat.gene_hts_nonsyn_syn_ratio,
          genefeat.comment_string,
          transcript.uniprot_id, transcript.uniprot_id_internal,
          genefeat.gene_entrez_id,
          genefeat.gene_locations,
          -- next the transcript attributes:
          transcript.transcript_source_id,
          transcript.transcript_type,
          transcript.na_feature_id,
          CAST(coalesce(transcript.transcript_product, genefeat.old_gene_product,
                          case when transcript.is_pseudo = 1
                          then 'pseudogene'
                          else 'unspecified product'
                        end
                )AS VARCHAR(300)
            ) as transcript_product,
          transcript.start_min, transcript.end_max,
          transcript.is_reversed,   --CHECK if needed
          transcript.strand,
          transcript.is_pseudo,
          transcript.exon_count,
          transcript.length,
          transcript.spliced_na_sequence_id,
          genefeat.sequence_id,
          genefeat.organism,
          genefeat.species,
          genefeat.strain,
          genefeat.ncbi_tax_id,  genefeat.taxon_id,
          genefeat.so_id,
          genefeat.so_term_name,
          genefeat.so_term_definition,
          genefeat.so_version,
          CAST(coalesce(rt1_anticodon, rt2_anticodon)AS VARCHAR(3)) AS anticodon,
          genefeat.external_db_name,
          genefeat.external_db_version,
          genefeat.external_db_rls_id,
          genefeat.chromosome,
          genefeat.sequence_type,
          genefeat.chromosome_order_num, genefeat.na_sequence_id,
          --next the protein attributes:
          pa.source_id AS protein_source_id,
          pa.aa_sequence_id,
          pa.cds_start as coding_start,
          pa.cds_end as coding_end,
          pa.cds_length,
          pa.protein_length,
          pa.has_seqedit,
          pa.tm_count,
          pa.molecular_weight,
          pa.isoelectric_point,
          pa.signalp_peptide,
          pa.ec_numbers, pa.ec_numbers_derived,
          pa.annotated_go_component,
          pa.annotated_go_function,
          pa.annotated_go_process,
          pa.predicted_go_component,
          pa.predicted_go_function,
          pa.predicted_go_process,
          pa.annotated_go_id_component,
          pa.annotated_go_id_function,
          pa.annotated_go_id_process,
          pa.predicted_go_id_component,
          pa.predicted_go_id_function,
          pa.predicted_go_id_process,
          transcript.five_prime_utr_length,
          transcript.three_prime_utr_length
        FROM genefeat
          INNER JOIN transcript ON genefeat. gene_na_feature_id = transcript.transcript_parent_id
          LEFT JOIN &prefixproteinattributes pa ON transcript.transcript_source_id = pa.transcript_source_id AND pa.rank_in_transcript = 1
        ORDER BY taxon_id, source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_sourceId&1
          ON &prefixTranscriptAttributes&1 (source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_srcPrj&1
        ON &prefixTranscriptAttributes&1 (source_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genesrc&1
        ON &prefixTranscriptAttributes&1 (gene_source_id, source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_exon_ix&1
          ON &prefixTranscriptAttributes&1 (gene_exon_count, source_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_loc_ix&1
          ON &prefixTranscriptAttributes&1
               (na_sequence_id, gene_start_min, gene_end_max, is_reversed, na_feature_id,
                is_deprecated, source_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_feat_ix&1
          ON &prefixTranscriptAttributes&1 (na_feature_id, source_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_geneid_ix&1
          ON &prefixTranscriptAttributes&1 (gene_id, source_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_orthoname_ix&1
          ON &prefixTranscriptAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type, organism, gene_source_id, project_id)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_molwt_ix&1
          ON &prefixTranscriptAttributes&1 (taxon_id, molecular_weight, source_id, gene_source_id, project_id)

      ]]>
    </sql>


    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_ortholog_ix&1
          ON &prefixTranscriptAttributes&1
             (source_id, na_sequence_id, gene_start_min, gene_end_max, orthomcl_name, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_orgsrc_ix&1
          ON &prefixTranscriptAttributes&1 (organism, source_id, sequence_id, gene_start_min, gene_end_max)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixTranscriptAttributes&1 ta
        SET exon_count = (SELECT count(*) + 1 FROM apidb.IntronLocation il WHERE il.parent_id = ta.na_feature_id AND il.end_max - il.start_min + 1 > 10 )
        WHERE ta.project_id = 'TriTrypDB'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixTranscriptAttributes&1 gaup
        SET gene_paralog_number = (
          SELECT count(distinct gene_source_id)
          FROM &prefixTranscriptAttributes&1 g1
          WHERE g1.orthomcl_name = gaup.orthomcl_name
          AND g1.organism = gaup.organism
          AND gaup.gene_source_id != g1.gene_source_id
        ),
        gene_ortholog_number = (
          SELECT count(distinct gene_source_id)
          FROM &prefixTranscriptAttributes&1 g1
          WHERE g1.orthomcl_name = gaup.orthomcl_name
          AND g1.organism != gaup.organism
        )
        WHERE (gaup.gene_type = 'protein coding' or gaup.gene_type = 'protein coding gene')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixTranscriptAttributes&1
        SET gene_id = gene_na_feature_id + (select coalesce(max(gene_id), 0) from dots.gene)
        WHERE gene_id is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixTranscriptAttributes&1
        SET representative_transcript = (
          select min(source_id)
          from &prefixTranscriptAttributes&1 ga
          where ga.gene_source_id = &prefixTranscriptAttributes&1.gene_source_id
        )
        WHERE representative_transcript is null
          AND gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixTranscriptAttributes&1
        SET representative_transcript = source_id
        WHERE representative_transcript is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_lwrsrc_ix&1
          ON &prefixTranscriptAttributes&1 (lower(source_id), gene_source_id, project_id, source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_species_ix&1
          ON &prefixTranscriptAttributes&1 (species, source_id, gene_id, gene_source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TrnscrptAttr_geneinfo&1
          ON &prefixTranscriptAttributes&1
           (gene_source_id, project_id, source_id, na_feature_id, spliced_na_sequence_id,
            protein_source_id, na_sequence_id, length, protein_length,
            five_prime_utr_length, three_prime_utr_length)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genenaf&1
          ON &prefixTranscriptAttributes&1 (gene_na_feature_id, gene_source_id, source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_locsIds_ix&1
          ON &prefixTranscriptAttributes&1
             (na_sequence_id, start_min, end_max, is_reversed, gene_source_id, source_id, project_id)

      ]]>
    </sql>
  </tuningTable>

<!-- TODO: add back after LongRead table added to schema
  <tuningTable name="GeneModelCharMD" prefixEnabled="true">
    <comment>
      Stores tuned data for the genemodelchar filter search
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneIntronJunction"/>
    <externalDependency name="apidb.LongReadTranscript"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGeneModelCharMD&1
         (
          ontology_term_name,
          gene_source_id,
          source_id,
          taxon_id,
          string_value,
          number_value
         )
        AS
        SELECT ontology_term_name, gene_source_id, source_id, taxon_id, coalesce(string_value,'NA'), coalesce(number_value,-1)
        FROM (  SELECT gene_source_id, source_id, taxon_id,
                       'transcript_count' as ontology_term_name,
                       null as string_value, gene_transcript_count as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'transcript_exon_count' as ontology_term_name, null as string_value,
                       exon_count as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'gene_exon_count' as ontology_term_name, null as string_value,
                       gene_exon_count as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'is_pseudo' as ontology_term_name, CASE is_pseudo WHEN 1 THEN 'Yes' WHEN 0 THEN 'No' END as string_value,
                       null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'is_deprecated' as ontology_term_name, CASE is_deprecated WHEN 1 THEN 'Yes' WHEN 0 THEN 'No' END as string_value,
                       null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'gene_type' as ontology_term_name, gene_type as string_value, null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'gene_type_ebi' as ontology_term_name, gene_ebi_biotype as string_value, null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'transcript_type' as ontology_term_name, transcript_type as string_value,
                       null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id,
                       'organism' as ontology_term_name, organism as string_value,
                       null as number_value
                FROM TranscriptAttributes
              UNION
                SELECT gene_source_id, source_id, taxon_id, organism, ontology_term_name
                  , string_value, number_value
                FROM (
                    select atr.gene_source_id, atr.source_id, atr.taxon_id, atr.organism,
                        'long_transcript_novelty' as ontology_term_name, ltr.transcript_novelty string_value,
                         null as number_value, sum(counts.reads) as total_reads, ltr.transcript_length
                    from TranscriptAttributes atr
                    , apidb.longreadtranscript ltr
                    , JSON_TABLE(count_data, '$.*' COLUMNS (reads INTEGER PATH '$')) counts
                    where ltr.gene_source_id = atr.gene_source_id
                    AND ltr.transcript_length >= 20
                    GROUP BY atr.gene_source_id, atr.source_id, atr.taxon_id, atr.organism, ltr.transcript_novelty, ltr.transcript_length
                ) t
                WHERE total_reads >= 5
              UNION
                SELECT atr.gene_source_id, atr.source_id, atr.taxon_id,
                'intron_junction' as ontology_term_name, it.string_value string_value,
                    null as number_value
                FROM
                  IntronSupportLevel it
                  , TranscriptAttributes atr
                WHERE it.gene_source_id =  atr.gene_source_id
             UNION
                SELECT atr.gene_source_id, atr.source_id, atr.taxon_id,
                'Unique_reads' as ontology_term_name, null as string_value , gj.total_unique number_value
                FROM
                  GeneIntronJunction gj
                  , TranscriptAttributes atr
                WHERE gj.gene_source_id =  atr.gene_source_id
             ) t
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixGeneModelCharMD_pk&1
          ON &prefixGeneModelCharMD&1  (ontology_term_name, gene_source_id, source_id, taxon_id, string_value, number_value)

      ]]>
   </sql>
  </tuningTable>
-->

<!-- TODO: add back after LongRead table added to schema

  <tuningTable name="GeneModelCharOrgMD" prefixEnabled="true">
    <comment>
      Stores tuned data for the genemodelchar filter search. Portal-specific version including taxon names.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneIntronJunction"/>
    <externalDependency name="apidb.LongReadTranscript"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGeneModelCharOrgMD&1
         (
          ontology_term_name,
          gene_source_id,
          source_id,
          taxon_id,
          taxon_name,
          string_value,
          number_value
         )
        AS
        SELECT ontology_term_name, gene_source_id, source_id, taxon_id, cast(organism as varchar(53)),
               cast(coalesce(string_value,'NA') as varchar(100)), coalesce(number_value,-1)
        FROM (  select gene_source_id, source_id, taxon_id, organism,
                       'transcript_count' as ontology_term_name,
                       null as string_value, gene_transcript_count as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'transcript_exon_count' as ontology_term_name, null as string_value,
                       exon_count as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'gene_exon_count' as ontology_term_name, null as string_value,
                       gene_exon_count as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'is_pseudo' as ontology_term_name, CASE is_pseudo WHEN 1 THEN 'Yes' WHEN 0 THEN 'No' END as string_value,
                       null as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'is_deprecated' as ontology_term_name, CASE is_deprecated WHEN 1 THEN 'Yes' WHEN 0 THEN 'No' END as string_value,
                       null as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'gene_type' as ontology_term_name, gene_type as string_value, null as number_value
                from TranscriptAttributes
              UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'gene_type_ebi' as ontology_term_name, gene_ebi_biotype as string_value, null as number_value
                from TranscriptAttributes
             UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'transcript_type' as ontology_term_name, transcript_type as string_value,
                       null as number_value
                from TranscriptAttributes
             UNION
                select gene_source_id, source_id, taxon_id, organism,
                       'organism' as ontology_term_name, organism as string_value,
                       null as number_value
                from TranscriptAttributes
             UNION
                select atr.gene_source_id, atr.source_id, atr.taxon_id,
                     'long_transcript_novelty' as ontology_term_name, ltr.transcript_novelty string_value,
                     null as number_value
                from TranscriptAttributes atr
                  , apidb.longreadtranscript ltr
                where
                ltr.gene_source_id = atr.gene_source_id
             UNION
                select atr.gene_source_id, atr.source_id, atr.taxon_id,
                'intron_junction' as ontology_term_name, gj.annotated_intron string_value,
                    null as number_value
                from
                  GeneIntronJunction gj
                    ,TranscriptAttributes atr
                where gj.gene_source_id =  atr.gene_source_id

             UNION
                select atr.gene_source_id, atr.source_id, atr.taxon_id,
                'Unique_reads' as ontology_term_name, null as string_value , gj.total_unique number_value
                from
                  GeneIntronJunction gj
                  ,TranscriptAttributes atr
                where gj.gene_source_id =  atr.gene_source_id
             ) t
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixGeneModelCharOrgMD_pk&1
          ON &prefixGeneModelCharOrgMD&1 (ontology_term_name, gene_source_id, source_id, taxon_id, taxon_name, string_value, number_value)

      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="IntronUtrCoords">
    <comment>
      Stores, for each transcript, a string containing the gene-relative coordinates
      of all its introns and UTRs.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <sql>
      <![CDATA[
        CREATE TABLE IntronUtrCoords&1 AS
        SELECT na_feature_id, source_id,
              '[' || regexp_replace(string_agg(text,',' ORDER BY start_min), '.quot;', '"' ) || ']' AS gen_rel_intron_utr_coords
        FROM (
          SELECT na_feature_id, source_id, start_min,
                 '["' || feature_type || '",' || start_min || ',' || end_max || ']' AS text
          FROM (
            SELECT fl.feature_type, tl.na_feature_id, tl.feature_source_id AS source_id,
              CASE
                WHEN tl.is_reversed = 1
                THEN tl.end_max - fl.end_max + 1
                ELSE fl.start_min - tl.start_min + 1
              END AS start_min,
              CASE
                WHEN tl.is_reversed = 1
                THEN tl.end_max - fl.start_min + 1
                ELSE fl.end_max - tl.start_min + 1
              END AS end_max
            FROM
             apidb.TranscriptLocation tl, apidb.FeatureLocation fl
            WHERE
              tl.na_feature_id = fl.parent_id
              AND fl.feature_type in('UTR', 'Intron')
              AND tl.is_top_level = 1
              AND fl.is_top_level = 1
          ) t1
        ) t2
        GROUP BY na_feature_id, source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX iuc_srcid_ix&1
          ON IntronUtrCoords&1 (source_id, na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX iuc_nfid_ix&1
          ON IntronUtrCoords&1 (na_feature_id, source_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneProduct" prefixEnabled="true">
    <comment>A single product string per gene
    </comment>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Transcript"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGeneProduct&1 as
        with gfp_preferred
             as (select source_id,
                   substr(STRING_AGG(product, ', ' order by product), 1, 4000) as product,
                   count(*) as value_count
                 from (select distinct gf.source_id,  gfp.product
                       from dots.GeneFeature gf, apidb.GeneFeatureProduct gfp
                       where gfp.na_feature_id = gf.na_feature_id
                         and gfp.is_preferred = 1) tmp
                 group by source_id),
             gfp_any
             as (select source_id,
                   substr(STRING_AGG(product, ', ' order by product), 1, 4000) as product,
                   count(*) as value_count
                 from (select distinct gf.source_id,  gfp.product
                       from dots.GeneFeature gf, apidb.GeneFeatureProduct gfp
                       where gfp.na_feature_id = gf.na_feature_id) tmp
                       group by source_id),
             tp_preferred
             as (select source_id,
                   substr(STRING_AGG(product, ', ' order by product), 1, 4000) as product,
                   count(*) as value_count
                 from (select distinct gf.source_id, tp.product
                       from dots.GeneFeature gf, dots.Transcript t, apidb.TranscriptProduct tp
                       where t.parent_id = gf.na_feature_id
                         and tp.na_feature_id = t.na_feature_id
                         and tp.is_preferred = 1)  tmp
                       group by source_id),
             gf_product
             as (select source_id, product
                 from dots.GeneFeature gf
                 where product is not null),
             tp_any
             as (select source_id,
                   substr(STRING_AGG(product, ', ' order by product), 1, 4000) as product,
                   count(*) as value_count
                 from (select distinct gf.source_id, tp.product
                       from dots.GeneFeature gf, dots.Transcript t, apidb.TranscriptProduct tp
                       where t.parent_id = gf.na_feature_id
                         and tp.na_feature_id = t.na_feature_id) tmp
                       group by source_id),
             t_product
             as (select source_id,
                        substr(STRING_AGG(product, ', ' order by product), 1, 4000) as product,
                        count(*) as value_count
                 from (select gf.source_id, t.product
                       from dots.GeneFeature gf, dots.Transcript t
                       where t.parent_id = gf.na_feature_id
                         and t.product is not null) tmp
                       group by source_id)
        select gf.source_id,
               coalesce(gfp_preferred.product, gfp_any.product, tp_preferred.product,
                        gf.product, tp_any.product, t_product.product)
                 as product,
                case
                 when gfp_preferred.product is not null
                   then gfp_preferred.value_count
                 when gfp_any.product is not null
                   then gfp_any.value_count
                 when tp_preferred.product is not null
                   then tp_preferred.value_count
                 when gf.product is not null
                   then 1
                 when tp_any.product is not null
                   then tp_any.value_count
                 when t_product.product is not null
                   then t_product.value_count
                 else 0 -- 'unspecified product'
               end
                 as value_count,
               case
                 when gfp_preferred.product is not null
                   then 1
                 when gfp_any.product is not null
                   then 2
                 when tp_preferred.product is not null
                   then 3
                 when gf.product is not null
                   then 4
                 when tp_any.product is not null
                   then 5
                 when t_product.product is not null
                   then 6
                 else 7
               end
                 as source_rule
        from dots.GeneFeature gf
          LEFT JOIN gfp_preferred ON gf.source_id = gfp_preferred.source_id
          LEFT JOIN gfp_any ON gf.source_id = gfp_any.source_id
          LEFT JOIN tp_preferred ON gf.source_id = tp_preferred.source_id
          LEFT JOIN gf_product ON gf.source_id = gf_product.source_id
          LEFT JOIN tp_any ON gf.source_id = tp_any.source_id
          LEFT JOIN t_product ON gf.source_id = t_product.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
delete from &prefixGeneProduct&1 where product is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneProduct_gene_idx&1 ON &prefixGeneProduct&1 (source_id, product)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
      stores all its attributes.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <ancillaryTable name="SpeciesInfo"/>
    <sql>
      <![CDATA[
	    CREATE TABLE &prefixGeneAttributes&1 AS
	    SELECT DISTINCT project_id
        , ta.gene_source_id AS source_id
		, gene_na_feature_id AS na_feature_id
		, na_sequence_id
		, is_reversed
		, gene_start_min AS start_min
		, gene_end_max AS end_max
        , CASE strand WHEN 'forward' THEN '+' WHEN 'reverse' THEN '-' ELSE null END as strand_plus_minus
		, sequence_id
		, gene_name AS name
		, COALESCE(aggregates.product, aggregates.transcript_product) as  old_product
		, COALESCE(gp.product, 'unspecified product') as product
		, gene_type
        , gene_ebi_biotype
		, gene_id
		, aggregates.is_pseudo
		, organism
		, species
		, taxon_id
		, species as genus_species
        , strain
		, ncbi_tax_id
		, so_id
		, so_term_name
		, so_term_definition
		, so_version
		, anticodon
		, external_db_name
		, external_db_version
		, external_db_rls_id
		, chromosome
		, chromosome_order_num
		, sequence_type
		, gene_transcript_count AS transcript_count
		, gene_exon_count as exon_count
		, gene_previous_ids as previous_ids
		, is_deprecated
		, gene_paralog_number as paralog_number
		, gene_ortholog_number as ortholog_number
		, gene_context_start as context_start
		, gene_context_end as context_end
		, orthomcl_name
		, gene_total_hts_snps as total_hts_snps
		, gene_hts_nonsynonymous_snps as hts_nonsynonymous_snps
		, gene_hts_stop_codon_snps as hts_stop_codon_snps
		, gene_hts_noncoding_snps as hts_noncoding_snps
		, gene_hts_synonymous_snps as hts_synonymous_snps
		, gene_hts_nonsyn_syn_ratio as hts_nonsyn_syn_ratio
		, comment_string
		, uniprot.uniprot_id
		, uniprot.uniprot_id_internal
		, gene_entrez_id as entrez_id
		, representative_transcript
        , gene_zoom_context_start as zoom_context_start
        , gene_zoom_context_end as zoom_context_end
        , cast (null as numeric) as strain_count
        , ta.gene_locations as locations
        FROM &prefixTranscriptAttributes ta
          INNER JOIN (
            SELECT gene_source_id, MIN(is_pseudo) AS is_pseudo, MIN(gene_product) AS product,
              substr(STRING_AGG(transcript_product, ',' order by transcript_product), 1, 240) as transcript_product
            FROM &prefixTranscriptAttributes
            GROUP BY gene_source_id
          ) aggregates ON ta.gene_source_id = aggregates.gene_source_id
          LEFT JOIN (
            SELECT na_feature_id,
              substr(string_agg(uniprot_id, ',' order by uniprot_id), 1, 240) as uniprot_id,
              substr(string_agg(uniprot_id, '+or+' order by uniprot_id), 1, 240) as uniprot_id_internal
            FROM (
              SELECT distinct t.parent_id as na_feature_id, dr.primary_identifier as uniprot_id
              FROM sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                   sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
              WHERE dr.db_ref_id = x.DB_REF_ID
                AND (x.na_feature_id = t.na_feature_id OR x.na_feature_id = t.parent_id)
                AND dr.external_database_release_id = r.external_database_release_id
                AND r.external_database_id = d.external_database_id
                AND (d.name like '%uniprot_dbxref_RSRC'
                     OR d.name like '%dbxref_gene2Uniprot_RSRC'
                     OR d.name = 'Links to Uniprot Genes'
                     OR d.name like '%_dbxref_uniprot_from_annotation_RSRC')
               ) t
            GROUP BY na_feature_id
          ) uniprot ON ta.gene_na_feature_id = uniprot.na_feature_id
          LEFT JOIN &prefixGeneProduct gp ON ta.gene_source_id = gp.source_id
        ORDER BY ta.gene_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixSpeciesInfo&1 as
        SELECT genus_species, count(distinct organism) as strain_count
        FROM &prefixGeneAttributes&1
        GROUP BY genus_species
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixGeneAttributes&1 ga
        SET strain_count = (
          SELECT strain_count
          FROM &prefixSpeciesInfo&1 si
          WHERE si.genus_species = ga.genus_species
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX GeneAttr_srcPrj&1
        ON &prefixGeneAttributes&1 (source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_exon_ix&1
        ON &prefixGeneAttributes&1 (exon_count, source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_loc_ix&1
          ON &prefixGeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed, na_feature_id, is_deprecated)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_feat_ix&1
           ON &prefixGeneAttributes&1 (na_feature_id, na_sequence_id, start_min, end_max, is_reversed)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_orthoname_ix&1 ON &prefixGeneAttributes&1 (
          orthomcl_name, source_id, taxon_id, gene_type, na_feature_id,
          na_sequence_id, start_min, end_max, organism, species,
          product, project_id
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_ortholog_ix&1
          ON &prefixGeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name, na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_orgsrc_ix&1
          ON &prefixGeneAttributes&1 (organism, source_id, na_sequence_id, start_min, end_max)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_prjsrc_ix&1
          ON &prefixGeneAttributes&1 (project_id, organism, source_id, coalesce(IS_DEPRECATED,0))

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_txid_ix&1
          ON &prefixGeneAttributes&1 (taxon_id, source_id, gene_type, na_feature_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_ids_ix&1
          ON &prefixGeneAttributes&1 (na_feature_id, source_id, project_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GeneAttr_loc_intjunc_ix&1
          ON &prefixGeneAttributes&1 (NA_SEQUENCE_ID, START_MIN, IS_REVERSED, END_MAX)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributes" prefixEnabled="true">
    <comment>Each record represents one SNP. Widely used in the model, as well as in
      the creation of several other tuning tables, Includes only NGS SNPs.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="apidb.Snp" noTrigger="true"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixSnpAttributes&1 AS
        WITH allele_total
             AS (SELECT ref_na_sequence_id, location, COUNT(*) AS allele_total
                 FROM apidb.SequenceVariation
                 GROUP BY ref_na_sequence_id, location),
             stop_codon_snps
             AS (SELECT DISTINCT ref_na_sequence_id, location, 1 as has_stop_codon
                 FROM apidb.SequenceVariation
                 WHERE product = '*'),
             fl
             AS (SELECT feature_source_id, is_reversed, na_feature_id
                 FROM apidb.FeatureLocation
                 WHERE is_top_level = 1 and feature_type = 'GeneFeature')
        SELECT chromosome_info.project_id,
               ed.name as dataset,
               sequence.na_sequence_id,
               sequence.source_id as seq_source_id,
               snp.location,
               snp.source_id,
               snp.reference_strain,
               snp.reference_na,
               snp.reference_aa,
               CASE snp.reference_aa WHEN null THEN 0 ELSE 1 END as is_coding,
               snp.position_in_CDS,
               snp.position_in_protein,
               -- has_nonsynonymous should be false if any products are stops
               case when stop_codon_snps.has_stop_codon is null
                      then snp.has_nonsynonymous_allele
                    else 0
               end as has_nonsynonymous_allele,
               snp.major_allele,
               snp.minor_allele,
               snp.major_allele_count,
               snp.minor_allele_count,
               round(snp.major_allele_count / allele_total.allele_total, 2) as major_allele_frequency,
               round(snp.minor_allele_count / allele_total.allele_total, 2) as minor_allele_frequency,
               snp.major_product,
               snp.minor_product,
               snp.distinct_strain_count,
               snp.distinct_allele_count,
               coalesce(stop_codon_snps.has_stop_codon, 0) AS has_stop_codon,
               case when snp.reference_aa is null then 1 else 0 end as is_noncoding_snp,
               fl.feature_source_id as gene_source_id,
               fl.na_feature_id as gene_na_feature_id,
               CASE fl.is_reversed WHEN 0 THEN 'forward' WHEN 1 THEN 'reverse' ELSE null END as gene_strand,
               CAST(SUBSTR(sequence.sequence, snp.location::integer - 30, 30) AS VARCHAR(30)) AS lflank,
               CAST(SUBSTR(sequence.sequence, snp.location::integer + 1, 30) AS VARCHAR(30)) AS rflank,
               chromosome_info.organism as organism,
               chromosome_info.ncbi_tax_id,
               chromosome_info.chromosome,
               chromosome_info.chromosome_order_num
        FROM dots.NaSequence sequence, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
             &prefixGenomicSeqAttributes chromosome_info,
             apidb.snp LEFT JOIN stop_codon_snps ON
              snp.na_sequence_id = stop_codon_snps.ref_na_sequence_id
              AND snp.location = stop_codon_snps.location
             LEFT JOIN allele_total ON
              snp.location = allele_total.location
              AND snp.na_sequence_id = allele_total.ref_na_sequence_id
             LEFT JOIN fl ON snp.gene_na_feature_id = fl.na_feature_id
        WHERE edr.external_database_release_id = snp.external_database_release_id
          AND ed.external_database_id = edr.external_database_id
          AND sequence.na_sequence_id = snp.na_sequence_id
          AND chromosome_info.na_sequence_id = snp.na_sequence_id
        ORDER BY edr.external_database_release_id, sequence.na_sequence_id, snp.location
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create unique index SnpAttr_source_id&1 ON &prefixSnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Snp_nafeat_dataset_ix&1
               ON &prefixSnpAttributes&1 (dataset)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Snp_Seq_ix&1
               ON &prefixSnpAttributes&1 (na_sequence_id, dataset, location)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Snp_Freq_ix&1
               ON &prefixSnpAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpAttr_ds_org_ix&1 on &prefixSnpAttributes&1 (dataset,organism)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpVariantIx&1
               ON &prefixSnpAttributes&1 (dataset, source_id, gene_source_id, location, position_in_protein)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <comment> Each row represents one EST. Used widely in the model, and to make the
      tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE EstAttributes&1 AS
        SELECT
               cast(apidb.project_id(tn.name) as varchar(20)) as project_id,
               ens.source_id,
               e.seq_primer AS primer,
               ens.a_count,
               ens.c_count,
               ens.g_count,
               ens.t_count,
               (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
                 AS other_count,
               ens.length,
               replace(l.dbest_name, '''', '-') as dbest_name,
               coalesce(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
               coalesce(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
               SUBSTR(CASE
                        WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB'
                        ELSE tn.name
                      END, 1, 100) AS organism,
               taxon.ncbi_tax_id,
               ed.name AS external_db_name,
               coalesce(best.best_alignment_count, 0) AS best_alignment_count,
               l.library_id, replace(l.dbest_name, '''', '-') as library_dbest_name
        FROM dots.Est e, dots.Library l, sres.Taxon, sres.OntologyTerm oterm,
             sres.TaxonName tn, sres.ExternalDatabase ed,
             sres.ExternalDatabaseRelease edr, dots.ExternalNaSequence ens
             LEFT JOIN
             (select query_na_sequence_id,max(ct) as best_alignment_count
              from (
                    SELECT query_na_sequence_id, COUNT(*) AS ct
                     FROM dots.BlatAlignment ba
                     WHERE is_best_alignment = 1
                     GROUP BY target_external_db_release_id,query_na_sequence_id) t
              group by query_na_sequence_id
              ) best ON ens.na_sequence_id = best.query_na_sequence_id
        WHERE e.na_sequence_id = ens.na_sequence_id
          AND e.library_id = l.library_id
          AND ens.taxon_id = tn.taxon_id
          AND ens.taxon_id = taxon.taxon_id
          AND tn.name_class='scientific name'
          AND ens.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ens.sequence_ontology_id = oterm.ontology_term_id
          AND oterm.name = 'EST'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <comment> Each row represents a colocated EST alignment - gene pair. Used by the
      model, by generateGeneMetrics, and in the creation of the
      OrganismAttributes tuning table
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE EstAlignmentGene AS
        SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
                 e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
                 ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
                 ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
                 ga.sequence_id AS target_sequence_source_id,
                 least(ba.target_end, ga.gene_end_max)
                 - greatest(ba.target_start, ga.gene_start_min) + 1
                   AS est_gene_overlap_length,
                 ba.query_bases_aligned / (query_sequence.length)
                 * 100 AS percent_est_bases_aligned,
                 ga.gene_source_id AS gene
        FROM dots.BlatAlignment ba, dots.Est e,
             apidbtuning.TranscriptAttributes ga, 
             dots.NaSequence query_sequence 
        WHERE e.na_sequence_id = ba.query_na_sequence_id
          AND ga.na_sequence_id = ba.target_na_sequence_id
          AND least(ba.target_end, ga.gene_end_max) - greatest(ba.target_start, ga.gene_start_min) >= 0
          AND query_sequence.na_sequence_id = ba.query_na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE EstAlignmentNoGene AS
        SELECT * from EstAlignmentGene WHERE 1=0 UNION /* define datatype for null column */
        SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
               e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
               ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
               ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
               sequence.source_id AS target_sequence_source_id,
               NULL AS est_gene_overlap_length,
               ba.query_bases_aligned / (query_sequence.length)
               * 100 AS percent_est_bases_aligned,
               NULL AS gene
        FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
             dots.NaSequence sequence, dots.NaSequence query_sequence
        WHERE e.na_sequence_id = ba.query_na_sequence_id
          AND e.na_sequence_id = query_sequence.na_sequence_id
          AND aseq.na_sequence_id = ba.query_na_sequence_id
          AND ba.target_na_sequence_id = sequence.na_sequence_id
          AND ba.blat_alignment_id IN
           ( /* set of blat_alignment_ids not in in first leg of UNION */
            /* (because they overlap no genes) */
            SELECT ba.blat_alignment_id
            FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
                 sres.OntologyTerm so
            WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
              AND query_sequence.sequence_ontology_id = so.ontology_term_id
              AND so.name = 'EST'
            EXCEPT
            SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE EstAlignmentGeneSummary&1 AS
        SELECT * FROM EstAlignmentNoGene
        UNION
        SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index EstSumm_libOverlap_ix&1
                     ON EstAlignmentGeneSummary&1
                        (library_id, percent_identity, is_consistent,
                         est_gene_overlap_length, percent_est_bases_aligned)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index EstSumm_estSite_ix&1
                     ON EstAlignmentGeneSummary&1
                        (target_sequence_source_id, target_start, target_end,
                         library_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenericEndFeature">
    <comment>Each row represents one cosmid or bac end feature; for use in JBrowse.
     </comment>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE GenericEndFeature&1 AS
SELECT ed.name, etn.source_id, etn.secondary_identifier,
       blat.blat_alignment_id,
       blat.query_na_sequence_id,
       blat.target_na_sequence_id,
       blat.target_start, blat.target_end, blat.score,
       blat.percent_identity, blat.number_of_spans
FROM dots.BlatAlignment blat,
     dots.ExternalNASequence etn,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
WHERE blat.query_na_sequence_id = etn.na_sequence_id
  AND blat.is_best_alignment = 1
  AND ed.external_database_id=edr.external_database_id
  AND edr.external_database_release_id = etn.external_database_release_id
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="SnpStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
      gene and SNP queries, as well as the gene record.
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
        CREATE TABLE SnpStrains&1 AS
        with seq_var_pan AS
          (select pan.name as protocol_app_node_name
              , pan.protocol_app_node_id
              , d.name
              , pan.external_database_release_id
              , replace(pan.name, ' (Sequence Variation)', '') as strain
              , tn.name as organism
          from study.protocolappnode pan
             , sres.externaldatabaserelease r
             , sres.externaldatabase d
             , apidb.organism o
             , sres.taxonname tn
          where pan.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and d.name like o.abbrev || '%'
          and o.taxon_id = tn.taxon_id
          and tn.name_class = 'scientific name'
          and pan.name like '% (Sequence Variation)'),
        ref_pan as
          (select svp.*
           from seq_var_pan svp
              , apidb.organism o
           where svp.strain = o.public_abbrev),
        o_pan as
         (select distinct svp.*
          from seq_var_pan svp
             , dots.nasequence s
          where svp.external_database_release_id = s.external_database_release_id)
        SELECT * FROM o_pan
        UNION
        SELECT * FROM ref_pan
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(strain,organism)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpChipStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
      gene and SNP queries, as well as the gene record.
    </comment>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE SnpChipStrains&1 AS
        select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism, ds.subtype as platform
        from study.study s
           , study.studylink sl
           , study.protocolappnode pan
           , apidb.datasource ds
           , SRES.EXTERNALDATABASE d
           , SRES.EXTERNALDATABASERELEASE r
           , sres.taxonname tn
           , results.seqvariation sv
        where ds.type = 'isolates'
        and ds.subtype != 'HTS_SNP'
        and ds.name = d.name
        and ds.version = r.version
        and d.EXTERNAL_DATABASE_ID = r.EXTERNAL_DATABASE_ID
        and r.EXTERNAL_DATABASE_RELEASE_ID = s.EXTERNAL_DATABASE_RELEASE_ID
        and s.study_id = sl.study_id
        and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
        and ds.taxon_id = tn.taxon_id
        and tn.name_class = 'scientific name'
        and pan.PROTOCOL_APP_NODE_ID = sv.PROTOCOL_APP_NODE_ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpChipStrains_ix&1 ON SnpChipStrains&1(strain,organism,platform)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PopsetAttributes">
    <comment> The BFMV for the WDK popset record. Widely used in the model for
      queries related to popsets.
    </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.ProtocolAppNode"/>

    <sql>
      <![CDATA[
        CREATE TABLE PopsetAttributes&1 AS
        WITH
            isolation_source as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'isolation_source'),
            note as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'note'),
            gene_name as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'gene'),
            product as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'product'),
            pcr_primers as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'PCR_primers') ,
            host as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'host') ,
            host_tax_id as (select c.protocol_app_node_id, min(t.ncbi_tax_id) as ncbi_tax_id
             from study.Characteristic c, sres.OntologyTerm ot,
                 sres.TaxonName tn, sres.Taxon t
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'host'
                     and c.value = tn.name
                     and tn.taxon_id = t.taxon_id
             group by c.protocol_app_node_id) ,
            popset as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'isolate') ,
            strain as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'strain'),
            geographic_location as (select c.protocol_app_node_id, c.value
             from study.Characteristic c, sres.OntologyTerm ot
             where c.qualifier_id =ot.ontology_term_id
                     and ot.name = 'country'),
            lat_lon as (-- for decimal latitude and longitude with one-letter compass points
                --  (e.g. '12.96 S 38.46 W') parse out the latitude and longitude
                SELECT protocol_app_node_id,
                    to_number(coordinates[1], '999.99') * CASE coordinates[2] WHEN 'S' THEN -1 ELSE 1 END latitude,
                    to_number(coordinates[3], '999.99') * CASE coordinates[4] WHEN 'W' THEN -1 ELSE 1 END longitude,
                    value
                FROM (SELECT c.protocol_app_node_id,
                        regexp_matches(c.value, '([0-9.]*) ([NS]) ([0-9.]*) ([EW])') coordinates,
                        c.value
                      FROM study.Characteristic c, sres.OntologyTerm ot
                      WHERE c.qualifier_id =ot.ontology_term_id and ot.name = 'lat_lon'
                        and regexp_replace(c.value, '[0-9.]* [NS] [0-9.]* [EW]', 'latitude direction longitude direction')
                          = 'latitude direction longitude direction') t)
        SELECT ens.source_id, lower(ens.source_id) as lower_source_id,
            pi.name AS project_id, ens.na_sequence_id, pan.protocol_app_node_id,
            sr.segment_result_id, ens.taxon_id, tn.name as organism,
            pan.description, ens.external_database_release_id,
            ed.name as external_db_name, edr.version as external_db_version,
            isolation_source.value as isolation_source,
            cast (null as varchar(40)) as curated_isolation_source,
            note.value as note,
            gene_name.value as gene_name,
            product.value as product,
            geographic_location.value as geographic_location,
            cast (null as varchar(40)) as curated_geographic_location,
            lat_lon.latitude, lat_lon.longitude,
            lat_lon.value as lat_lon,
            pcr_primers.value as pcr_primers,
            host.value as host,
            host_tax_id.ncbi_tax_id as host_ncbi_tax_id,
            popset.value as popset,
            strain.value as strain,
            ens.length
        FROM core.Projectinfo pi, results.SegmentResult sr,
            sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
            dots.ExternalNaSequence ens LEFT JOIN sres.TaxonName tn ON ens.taxon_id = tn.taxon_id,
            study.ProtocolAppNode pan
                LEFT JOIN isolation_source ON pan.protocol_app_node_id = isolation_source.protocol_app_node_id
                LEFT JOIN note ON pan.protocol_app_node_id = note.protocol_app_node_id
                LEFT JOIN gene_name ON pan.protocol_app_node_id = gene_name.protocol_app_node_id
                LEFT JOIN product ON pan.protocol_app_node_id = product.protocol_app_node_id
                LEFT JOIN pcr_primers ON pan.protocol_app_node_id = pcr_primers.protocol_app_node_id
                LEFT JOIN host ON pan.protocol_app_node_id = host.protocol_app_node_id
                LEFT JOIN host_tax_id ON pan.protocol_app_node_id = host_tax_id.protocol_app_node_id
                LEFT JOIN popset ON pan.protocol_app_node_id = popset.protocol_app_node_id
                LEFT JOIN strain ON pan.protocol_app_node_id = strain.protocol_app_node_id
                LEFT JOIN geographic_location ON pan.protocol_app_node_id = geographic_location.protocol_app_node_id
                LEFT JOIN lat_lon ON pan.protocol_app_node_id = lat_lon.protocol_app_node_id
        WHERE pi.project_id = ens.row_project_id
            AND ens.na_sequence_id = sr.na_sequence_id
            AND sr.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.name = ens.source_id
            AND ens.external_database_release_id = edr.external_database_release_id
            AND edr.external_database_id = ed.external_database_id
            AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = geographic_location
            where geographic_location in (select name from sres.OntologyTerm ot)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.geographic_location
                                 and os.ontology_term_id = ot.ontology_term_id)
        where curated_geographic_location is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source = (select max(ot.name) from SRES.ONTOLOGYterm ot
                where ot.name = PopsetAttributes&1.isolation_source
                and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source =  (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.isolation_source
                                 and os.ontology_term_id = ot.ontology_term_id
                               and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
        where curated_isolation_source is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1 a
        set (latitude, longitude) = (select g.lat, g.lng
                                from apidb.IsolateGPS g, sres.OntologyTerm ot
                               where a.curated_geographic_location = ot.name
                                 and ot.source_id = g.gazetteer_id )
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index PopsetAttr_sourceId_idx&1
        on PopsetAttributes&1 (source_id,PROJECT_ID)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PopsetAttr_org_idx&1
          on PopsetAttributes&1(organism, source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PopsetAttr_lwrsrc_idx&1
          on PopsetAttributes&1(lower_source_id, source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChIPchipTranscript">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
      generateGeneMetrics. Also an input to OrganismAttributes.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
      CREATE TABLE ChIPchipTranscript&1 AS
      SELECT DISTINCT ta.source_id, ta.gene_source_id, ta.project_id, sr.protocol_app_node_id,
          CASE
            WHEN ta.is_reversed = 0
            THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
            ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
          END as distance,
          CASE
            WHEN /* distance > 0 */
              CASE WHEN ta.is_reversed = 0
                THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
                ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
              END > 0
            THEN
              CASE
                WHEN ta.is_reversed = 0
                THEN '-'
                ELSE '+'
              END
            ELSE
              CASE
                WHEN ta.is_reversed = 1
                THEN '-'
                ELSE '+'
              END
            END as direction,
          sr.score1 as score
      FROM  TranscriptAttributes ta,
            Results.segmentresult sr,
            Study.StudyLink sl,
            Study.Study s
      WHERE   sr.na_sequence_id = ta.na_sequence_id
        AND   s.study_id = sl.study_id
        AND   sl.protocol_app_node_id = sr.protocol_app_node_id
        AND   lower(s.name) like '%chip%peaks'
        AND   ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                        or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipTranscript&1 (protocol_app_node_id, source_id, gene_source_id)

      ]]>
    </sql>
  </tuningTable>


<!-- COMMENT FOR NOW, as no InferredParam table; FIX later
  <tuningTable name="ChipSeqTranscript">
    <comment> Used by the GenesByChipSeq query
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="InferredParams"/>
    <internalDependency name="DefaultChars"/>
    <externalDependency name="results.SegmentResult"/>
    <sql>
      <![CDATA[
      CREATE TABLE ChipSeqTranscript&1 AS
      SELECT DISTINCT ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
        CASE
          WHEN ta.is_reversed = 0
          THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
          ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        END as distance,
        CASE
          WHEN /* distance > 0 */
            CASE WHEN ta.is_reversed = 0
              THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
              ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            END > 0
          THEN
            CASE
              WHEN ta.is_reversed = 0
              THEN '-'
              ELSE '+'
            END
          ELSE
            CASE
              WHEN ta.is_reversed = 1
              THEN '-'
              ELSE '+'
            END
          END as direction,
        sr.score1 as score
      FROM  TranscriptAttributes ta,
            results.SegmentResult sr
      WHERE sr.na_sequence_id = ta.na_sequence_id
        AND sr.protocol_app_node_id
                IN (      select protocol_app_node_id from DefaultChars where dataset_subtype = 'chipseq'
                    union select protocol_app_node_id from InferredParams where dataset_subtype = 'chipseq'
                    union select protocol_app_node_id from InferredChars where dataset_subtype = 'chipseq')
        AND ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                        or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index chpsq_id_idx&1 ON ChipSeqTranscript&1 (protocol_app_node_id, source_id, gene_source_id)

      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="TFBSGene">
    <comment> Used by gene queries, as well as by generateGeneMetrics. Also an input
      to OrganismAttributes.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.BindingSiteFeature"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE TFBSGene&1 AS
        SELECT DISTINCT
          ga.source_id as gene_source_id,
          ga.organism as organism,
          ga.genus_species as species,
          aef.source_id as probe_id,
          aef.na_feature_id as tfbs_na_feature_id,
          CASE
            WHEN ga.is_reversed = 0
            THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
            ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
          END as distance,
          CASE
            WHEN /* distance > 0 */
              CASE WHEN ga.is_reversed = 0
                THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
                ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
              END > 0
            THEN
              CASE
                WHEN ga.is_reversed = 0
                THEN '-'
                ELSE '+'
              END
            ELSE
              CASE
                WHEN ga.is_reversed = 1
                THEN '-'
                ELSE '+'
              END
            END as direction,
            aef.*
        FROM  dots.BindingSiteFeature aef,
              apidb.FeatureLocation arrloc,
              GeneAttributes ga
        WHERE aef.na_feature_id = arrloc.na_feature_id
        AND   arrloc.na_sequence_id = ga.na_sequence_id
        AND   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                          or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index geneid_tfbs_idx&1 ON TFBSGene&1 (tfbs_na_feature_id,gene_source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Subcellular">
    <comment> Each record maps a gene onto a subcellular location. Used by
      GenesBySubcellularLocalization.
    </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
        CREATE TABLE Subcellular&1 AS
        SELECT distinct gi.gene as source_id, targetting_domain
        FROM (
        SELECT paf.source_id, 'ht' as targetting_domain
        FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
        WHERE ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
          AND ed.external_database_id = edr.external_database_id
          AND edr.external_database_release_id = paf.external_database_release_id
        UNION
        SELECT paf.source_id, 'pexel' as targetting_domain
        FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
        WHERE ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
          AND ed.external_database_id = edr.external_database_id
          AND edr.external_database_release_id = paf.external_database_release_id
        UNION
        SELECT paf.source_id, 'apicoplast' as targetting_domain
        FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
        WHERE ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
          AND ed.external_database_id = edr.external_database_id
          AND edr.external_database_release_id = paf.external_database_release_id
        ) sc, GeneId gi
        WHERE gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index subc_ix&1 ON Subcellular&1(source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SimilaritySpanLocation">
    <comment> Like dots.SimilaritySpan, except that for sequences that are mapped by
      SequencePiece into parts of other sequences, both locations are stored.
      Used by GBrowse, and also in the creation of the Blastx tuning table.
    </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
        CREATE TABLE SimilaritySpanLocation&1 AS
        SELECT sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
               sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
               sim.max_query_end, sim.is_reversed as similarity_is_reversed,
               sim.pvalue_mant, sim.pvalue_exp,
               round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
               round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
               sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
               simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
               simp.subject_start, simp.subject_end,
               simp.is_reversed as span_is_reversed,
               'direct' as location_mapping
        FROM dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
        WHERE sim.similarity_id = simp.similarity_id
          AND sim.query_table_id = ti.table_id
          AND ti.name = 'ExternalNASequence'
        UNION
        SELECT sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
               sim.query_table_id,
               sim.subject_table_id, sim.score as similarity_score,
               case
                 when sp.strand_orientation in ('-', '-1')
                   then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
                   else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
               end as min_query_start,
               case
                 when sp.strand_orientation in ('-', '-1')
                   then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
                   else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
               end as max_query_end,
               sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
               round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
               round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
               sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
               simp.similarity_span_id, simp.score as span_score,
               case
                 when sp.strand_orientation in ('-', '-1')
                   then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
                   else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
               end as query_start,
               case
                 when sp.strand_orientation in ('-', '-1')
                   then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
                   else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
               end as query_end,
               simp.subject_start, simp.subject_end,
               simp.is_reversed as span_is_reversed,
               'virtual' as location_mapping
        FROM dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
             dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
        WHERE sim.similarity_id = simp.similarity_id
          AND sim.query_table_id = ti.table_id
          AND ti.name = 'ExternalNASequence'
          AND sim.query_id = sp.piece_na_sequence_id
          AND sp.start_position <= sim.min_query_start
          AND sp.end_position >= sim.max_query_end
          AND sim.query_id = contig.na_sequence_id
          AND sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update SimilaritySpanLocation&1
        set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
        where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
          on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTS">
    <comment>
      SNP Chip only, such as Plasmo barcode, 3k_chp and hd_array

         Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE SnpAttributesDoTS&1 AS
        SELECT cast(apidb.project_id(tn.name) as varchar(20)) as project_id,
               snp.source_id,
               snp.na_feature_id,
               ed.name AS dataset,
               snp.name as type,
               ds.subtype as platform,
               sequence.na_sequence_id,
               sequence.source_id AS seq_source_id,
               snp_loc.start_min,
               SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
               SUBSTR(snp.reference_na, 1, 200) AS reference_na,
               snp.is_coding,
               snp.position_in_CDS,
               snp.position_in_protein,
               SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
               CASE snp.has_nonsynonymous_allele
                  WHEN 0 THEN 'no'
                  WHEN 1 THEN 'yes'
               END AS has_nonsynonymous_allele,
               SUBSTR(snp.major_allele, 1, 40) AS major_allele,
               SUBSTR(snp.major_product, 1, 40) AS major_product,
               snp.major_allele_count,
               round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
               SUBSTR(snp.minor_allele, 1, 40) AS minor_allele,
               SUBSTR(snp.minor_product, 1, 40) AS minor_product,
               snp.minor_allele_count,
               round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
               gene_info.source_id AS gene_source_id,
               CASE gene_info.is_reversed
                  WHEN 0 THEN 'forward'
                  WHEN 1 THEN 'reverse'
               END AS gene_strand,
               SUBSTR(sequence.sequence, snp_loc.start_min::integer - 30, 30) AS lflank,
               SUBSTR(sequence.sequence, snp_loc.start_min::integer + 1, 30) AS rflank,
               SUBSTR(tn.name, 1, 100) AS organism,
               taxon.ncbi_tax_id,
               SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
               chromosome_info.chromosome_order_num
        FROM sres.ontologyterm so, apidb.FeatureLocation snp_loc, apidb.datasource ds,
             sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
             sres.TaxonName tn, dots.NaSequence sequence,
             dots.SnpFeature snp LEFT JOIN
             (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
                     gene_loc.na_sequence_id
              FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
              WHERE gene.na_feature_id = gene_loc.na_feature_id
                    and gene_loc.is_top_level = 1
             ) gene_info ON snp.parent_id = gene_info.na_feature_id,
             (SELECT na_sequence_id, chromosome, chromosome_order_num
              FROM dots.ExternalNaSequence
             UNION
              SELECT na_sequence_id, chromosome, chromosome_order_num
              FROM dots.VirtualSequence
             UNION
              SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
              FROM dots.NaSequence
              WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
             ) chromosome_info
        WHERE edr.external_database_release_id = snp.external_database_release_id
          AND ed.external_database_id = edr.external_database_id
          AND ed.name = ds.name
          AND sequence.taxon_id = taxon.taxon_id
          AND sequence.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
          AND snp_loc.na_feature_id = snp.na_feature_id
          AND snp_loc.is_top_level = 1
          AND sequence.na_sequence_id = snp_loc.na_sequence_id
          AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
          AND snp.sequence_ontology_id = so.ontology_term_id
          AND so.name != 'indel'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index SnpAttrDots_source_id&1 ON SnpAttributesDoTS&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpDots_nafeat_dataset_ix&1
               ON SnpAttributesDoTS&1 (na_feature_id, dataset)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpDoTS_Seq_ix&1
               ON SnpAttributesDoTS&1 (na_sequence_id, dataset, start_min, na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpDoTS_Freq_ix&1
               ON SnpAttributesDoTS&1 (dataset,major_allele_frequency,minor_allele_frequency)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpAttrdots_ds_org_ix&1 on snpattributesdots&1 (dataset,organism,na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SnpDotsVariantIx&1 on SnpAttributesDoTS&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTSPostprocess">
    <comment>
      this otherwise-unneeded tuning table, which depends on SnpAttributesDoTS,
      exists so that the view SnpChipAttributes can be created as a side-effect
    </comment>
    <internalDependency name="SnpAttributesDoTS"/>
    <sql>
      <![CDATA[
        CREATE TABLE SnpAttributesDoTSPostprocess&1 as SELECT 'X'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE OR REPLACE VIEW SnpChipAttributes AS
        SELECT * FROM SnpAttributesDots
        WHERE platform IN ('Broad_3k_array', 'Broad_75K_array',
                           'NIH_10k', 'Broad_barcode')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        GRANT SELECT ON SnpChipAttributes to gus_r
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastp">
    <comment> Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <sql>
      <![CDATA[
        CREATE TABLE Blastp&1 AS
        SELECT row_number() over () as blastp_id, ga.source_id, ga.gene_source_id, ga.project_id, sim.similarity_id,
               subject.source_id as subject_source_id, sim.score score, sim.query_id,
               sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
               sim.number_identical, sim.total_match_length,
               substr(replace(subject.description, chr(1), ''), 1, 300) as description,
               sim.number_positive, ed.name as external_database_name,
               substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
        FROM dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
             dots.Transcript t, dots.TranslatedAaFeature taf,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             dots.NaSequence ns, /* TaxonSpecies st, */
             sres.TaxonName tn, TranscriptAttributes ga
        WHERE qti.table_id = sim.query_table_id
          AND qti.name = 'TranslatedAASequence'
          AND sti.table_id = sim.subject_table_id
          AND sti.name = 'ExternalAASequence'
          AND subject.aa_sequence_id = sim.subject_id
          AND ga.na_feature_id = t.na_feature_id
          AND t.na_feature_id = taf.na_feature_id
          AND taf.aa_sequence_id = sim.query_id
          AND subject.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ga.na_sequence_id = ns.na_sequence_id
          AND ns.taxon_id = tn.taxon_id
          /*  st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out */
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE Blastp&1
        SET pvalue_exp = (SELECT min(pvalue_exp) FROM Blastp&1)
        WHERE pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Blastp_src_ix&1 on Blastp&1 (source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index Blastp_query_ix&1 on Blastp&1 (query_id)

      ]]>
    </sql>
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        create index Blastp_text_ix&1 on Blastp&1(description) indextype is ctxsys.context-->
<!--             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')-->
<!--      ]]>-->
<!--    </sql>-->
    <sql>
      <![CDATA[
        create index Blastp_pvalfunc_ix&1
             on Blastp&1
                (pvalue_exp, gene_source_id,
                 replace (external_database_name,'_RSRC',''))

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GenePopsetOverlap">
    <comment> Each record stores a colocated (gene, popset) 2-tuple. Used by the
      gene page as well as the PopsetByOverlap query.
    </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenePopsetOverlap&1 AS
        SELECT substr(ia.source_id, 1, 30) as popset_source_id,
               fl.feature_source_id as gene_source_id,
               min(pvalue_exp) as min_pvalue_exp
        FROM PopsetAttributes ia, dots.Similarity sim, apidb.FeatureLocation fl
        WHERE fl.feature_type = 'GeneFeature'
          AND fl.na_sequence_id = sim.subject_id
          AND fl.start_min < sim.max_subject_end
          AND fl.end_max > sim.min_subject_start
          AND sim.query_id = ia.na_sequence_id
        GROUP BY ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gi_i_ix&1 on GenePopsetOverlap&1 (popset_source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gi_g_ix&1 on GenePopsetOverlap&1 (gene_source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <comment>Each record maps a taxon_id of interest onto the taxon_id of that taxon's
      taxon-tree ancestor whose rank is "species". Used by
      gene queries, and as an input in the
      creation of several tuning tables, including GeneAttributes
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="TaxonOfInterest"/>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE &prefixTaxonOfInterest AS
          SELECT taxon_id
          FROM &prefixGenomicSeqAttributes
        UNION
          SELECT ns.taxon_id
          FROM dots.NaSequence ns, dots.Est
          WHERE est.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixTaxonSpecies&1 as
        -- recursively walk taxon tree to find ancestor with rank "species"
        -- Update this to select max/min level with rank species if there are multiple
        WITH RECURSIVE cte AS (
            SELECT TAXON_ID, taxon_id as parent_id, 1 as lvl
            FROM sres.taxon
            WHERE taxon_id IN (SELECT taxon_id FROM &prefixTaxonofinterest)
            UNION ALL
            SELECT cte.taxon_id, sub.parent_id, lvl + 1
            FROM cte, sres.taxon sub
            WHERE cte.parent_id = sub.taxon_id
        )
        SELECT c.taxon_id, c.parent_id as species_taxon_id
        FROM cte c, sres.taxon t
        WHERE t.taxon_id = c.parent_id
          AND t.rank='species'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastx">
    <comment> Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     </comment>
    <internalDependency name="SimilaritySpanLocation"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
        CREATE TABLE Blastx&1
              (similarity_id, name, score, pvalue, na_sequence_id, startm, "end", strand, atts)
        AS
        SELECT DISTINCT sim.similarity_id,
               extt.source_id name,
               substr(sim.similarity_score || '', 1, 6) score,
               sim.pvalue_mant * (power(10::double precision,sim.pvalue_exp)) pvalue,
               extq.na_sequence_id,
               sim.min_query_start startm,
               sim.max_query_end "end",
               CASE sim.similarity_is_reversed
                  WHEN 0 THEN '+1'
                  WHEN 1 THEN '-1'
                  ELSE '.'
               END strand,
               substr('Score=' || sim.similarity_score || ';;' ||
                      'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'||
                      'Defline=' || extt.description || ';;' ||
                      'PercentIdentity=' || sim.percent_identical || ';;' ||
                      'PercentPositive=' || sim.percent_positive || ';;' ||
                      'TStart=' || sim.min_query_start || ';;' ||
                      'TStop=' || sim.max_query_end, 1, 400) atts
        FROM SimilaritySpanLocation sim, dots.ExternalAaSequence extt,
             dots.NaSequence extq
        WHERE sim.query_id = extq.na_sequence_id
          AND sim.subject_id = extt.aa_sequence_id
          AND (sim.max_query_end - sim.min_query_start) < 5000
          AND sim.pvalue_exp < -10
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE index blastx_pk&1 on Blastx&1 (na_sequence_id, startm, pvalue, "end", similarity_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptSequence" prefixEnabled="true">
    <comment> Each record stores the transcript sequence of one gene. Used by the
      gene record and the sequence retrieval tool. Propagated to the portal.
    </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixTranscriptSequence&1 AS
        SELECT ta.source_id, ta.project_id, sns.sequence
        FROM &prefixTranscriptAttributes ta, dots.SplicedNaSequence sns
        WHERE ta.source_id = sns.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index XScriptSeq_ix&1 on &prefixTranscriptSequence&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
      gene record and the sequence retrieval tool. Propagated to the portal.
    </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE CodingSequence&1 AS
        SELECT ta.source_id, ta.project_id,
               SUBSTR(sns.sequence, tf.translation_start::INTEGER,
                      tf.translation_stop::INTEGER - tf.translation_start::INTEGER + 1) as sequence
        FROM TranscriptAttributes ta, dots.SplicedNaSequence sns, dots.TranslatedAaFeature tf
        WHERE ta.source_id = sns.source_id
         AND ta.na_feature_id = tf.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
      gene record and the sequence retrieval tool, as well as by
      buildTrackOldAnnotationTT. Propagated to the portal.
    </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <internalDependency name="ProteinAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProteinSequence&1 AS
        WITH pAttr AS (
           SELECT distinct source_id, aa_sequence_id
           FROM ProteinAttributes)
        SELECT pa.source_id, pi.name AS project_id, tas.sequence
        FROM pAttr pa, dots.TranslatedAaSequence tas, core.Projectinfo pi
        WHERE pa.aa_sequence_id = tas.aa_sequence_id
          AND pi.project_id = tas.row_project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceSequence">
    <comment> Each record stores the nucleotide sequence for one genomic sequence
      that is "official" (in the sense that it can be instantiated as a WDK
      sequence record. Used by generatePathoLogicFile and the sequence
      retrieval tool Propagated to portal instances.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenomicSequenceSequence&1 AS
        SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar(20)) as project_id,
               ns.sequence
        FROM GenomicSeqAttributes sa, dots.NaSequence ns, sres.TaxonName tn
        WHERE sa.na_sequence_id = ns.na_sequence_id
          AND ns.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GenomicSeq_ix&1 on GenomicSequenceSequence&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <comment> Each record stores the nucleotide sequence of an EST, for use by the
      relevant attribute query in the WDK EST record. Propagated to portal
      instances.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE EstSequence&1 AS
        SELECT ens.source_id,
               cast(apidb.project_id(tn.name) as varchar(20)) as project_id,
               ens.sequence
        FROM dots.ExternalNaSequence ens, sres.OntologyTerm oterm, sres.TaxonName tn
        WHERE oterm.name = 'EST'
          AND oterm.ontology_term_id = ens.sequence_ontology_id
          AND ens.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="NameMappingGIJ">
    <comment>
      Mapping table of experiment and sample names to junction protocol_app_node_id
    </comment>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="DatasetPresenter"/> <!-- uncomment on master after release -->
    <internalDependency name="PANIO"/>
    <intermediateTable name="JunExpGIJtmp"/>
    <intermediateTable name="MappingStatsGIJtmp"/>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE JunExpGIJtmp AS
        WITH ij AS (
          SELECT pj.output_pan_id as junctions_pan_id, p.output_pan_id as expression_pan_id, avg(nafe.value) as avg_value,pan.name as exp_name,
              regexp_replace(pan.name, ' \[htseq-union.*', '') as sample_name
          FROM panio p, panio pj, results.nafeatureexpression nafe, study.protocolappnode pan
          WHERE pj.output_pan_id in (select distinct protocol_app_node_id from apidb.intronjunction)
                  AND pj.input_pan_id = p.input_pan_id
                  AND p.output_pan_id = pan.protocol_app_node_id
                  AND pan.name like '%tpm - unique%'
                  AND p.output_pan_id = nafe.protocol_app_node_id
          GROUP BY pj.output_pan_id, p.output_pan_id, pan.name
          ORDER BY pj.output_pan_id
        ) , stats AS (
          SELECT protocol_app_node_id, 'total' as type, count(*) as total_junctions,
          sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
          FROM apidb.IntronJunction
          WHERE unique_reads >= 1
          GROUP BY protocol_app_node_id
        ), part AS (
          SELECT
              ij.junctions_pan_id, ij.avg_value, stats.multiplier
              , max(ij.expression_pan_id) OVER w as max_exp_pan_id
              , max(ij.sample_name) OVER w as max_sample_Name
              , max(ij.exp_name) OVER w as max_exp_name
          FROM ij, stats
          WHERE ij.junctions_pan_id = stats.protocol_app_node_id
          WINDOW w AS (partition by ij.junctions_pan_id, stats.multiplier, ij.avg_value)
        )
        SELECT DISTINCT * FROM (
        SELECT junctions_pan_id
               , first_value(max_exp_pan_id) OVER w1 as exp_pan_id
               , first_value(max_sample_name) OVER w1 as sample_name
               , CASE WHEN first_value(max_exp_name) OVER w1 LIKE  '%secondstrand%' THEN 'true' ELSE 'false' END as switch_strands
               , multiplier
        FROM part
        WINDOW w1 AS (PARTITION BY junctions_pan_id, multiplier ORDER BY avg_value DESC)
        ) t
        ORDER BY junctions_pan_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index junexpgijtmp_ix on JunExpGIJtmp(junctions_pan_id,exp_pan_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE MappingStatsGIJtmp (
            junctions_pan_id,
            read_length,
            mapped_reads,
            avg_mapping_coverage,
            num_replicates
        ) AS
           SELECT junctions_pan_id, round(avg(average_read_length - 2),1) as read_length,
                  round(avg(number_mapped_reads),1) as mapped_reads,
                  round(avg(avg_mapping_coverage) * ((avg(average_read_length) - 2) / avg(average_read_length)),2)
                    as avg_mapping_coverage,
                  count(*) as num_replicates
           FROM (SELECT je.junctions_pan_id, ca.value::NUMERIC as average_read_length,
                        cb.value::NUMERIC as number_mapped_reads,
                        cc.value::NUMERIC as avg_mapping_coverage
                 FROM junexpgijtmp je, STUDY.CHARACTERISTIC ca, sres.ontologyterm ota,
                      PANIO ioa, STUDY.CHARACTERISTIC cb, sres.ontologyterm otb,
                      STUDY.CHARACTERISTIC cc, sres.ontologyterm otc
                 WHERE je.junctions_pan_id = ioa.output_pan_id
                   AND ioa.input_pan_id = ca.protocol_app_node_id
                   AND ca.value is not null
                   AND ca.QUALIFIER_ID = ota.ONTOLOGY_TERM_ID
                   AND ota.source_id IN ('EuPathUserDefined_00504','EUPATH_0000457') --  '%average read length'
                   AND ca.protocol_app_node_id = cb.protocol_app_node_id
                   AND cb.value is not null
                   AND cb.QUALIFIER_ID = otb.ONTOLOGY_TERM_ID
                   AND otb.source_id IN ('EuPathUserDefined_00503','EUPATH_0000456') -- '%number mapped reads'
                   AND ca.protocol_app_node_id = cc.protocol_app_node_id
                   AND cc.value is not null
                   AND cc.QUALIFIER_ID = otc.ONTOLOGY_TERM_ID
                   AND otc.source_id IN ('EuPathUserDefined_00501','GENEPIO_0000092') -- '%average mapping coverage'
                 ) t
           GROUP by Junctions_Pan_Id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX mpstats_pk_ix on MappingStatsGIJtmp
          (junctions_pan_id,read_length,mapped_reads,avg_mapping_coverage,num_replicates)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE NameMappingGIJ&1 AS
        SELECT DISTINCT edp.dataset_presenter_display_name as exp_name,
              edp.external_database_name, je.sample_name,
              je.junctions_pan_id, je.exp_pan_id,
              substr(dp.value, 1, 4000) as presenter_switch_strands,
              substr(sj.value, 1, 4000) as show_intron_junctions,
              substr(uj.value, 1, 4000) as include_unified_junctions,
              ms.read_length, ms.mapped_reads, ms.avg_mapping_coverage, ms.num_replicates,
              je.switch_strands, je.multiplier
        FROM junexpgijtmp je, study.nodeNodeSet sl, study.NodeSet s, ExternalDbDatasetPresenter edp,
             DatasetProperty dp, DatasetProperty sj, DatasetProperty uj, mappingstatsgijtmp ms
        WHERE sl.protocol_app_node_id = je.junctions_pan_id
          AND je.junctions_pan_id = ms.junctions_pan_id
          AND s.node_set_id = sl.node_set_id
          AND s.node_type like 'junctions'
          AND s.external_database_release_id = edp.external_database_release_id
          AND dp.dataset_presenter_id = edp.dataset_presenter_id
          AND dp.property = 'switchStrandsProfiles'
          AND sj.dataset_presenter_id = edp.dataset_presenter_id
          AND sj.property = 'showIntronJunctions'
          AND uj.dataset_presenter_id = edp.dataset_presenter_id
          AND uj.property = 'includeInUnifiedJunctions'
          AND (substr(sj.value, 1, 10) = 'true' or substr(uj.value, 1, 10) = 'true')
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create index namemappinggij_ix&1 on NameMappingGIJ&1(junctions_pan_id,exp_pan_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneIntronJunction">
    <comment>
      Table collects up single row / intronjunction (identified as all junctions with same start, end and strand).  Statistics are generated including percentages of max intron score and ratios vs expression on an overall level.
    </comment>
    <internalDependency name="NameMappingGIJ"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <ancillaryTable name="GeneIdLocGIJ"/>
    <intermediateTable name="PanIOgij"/>
    <intermediateTable name="annotgij"/>
    <intermediateTable name="GIJtmp"/>

    <!-- some remedial tables -->
    <!-- PanIO:  can just generate minimal one with: -->
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE PanIOgij AS
        SELECT i.protocol_app_id, i.protocol_app_node_id as input_pan_id, o.protocol_app_node_id as output_pan_id
        FROM study.output o, study.input i
        WHERE
          o.protocol_app_node_id in (
            SELECT DISTINCT protocol_app_node_id
            FROM study.protocolappnode where name like '%junctions%' or name like '%htseq%'
          )
          AND o.protocol_app_id = i.protocol_app_id
      ]]>
    </sql>

    <!-- table with single row per annotated intron -->
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE annotgij (
            na_sequence_id,
            start_min,
            end_max,
            is_reversed,
            feature_type
        ) AS
           SELECT il.na_sequence_id, il.start_min,il.end_max, il.is_reversed, 'Intron' as feature_type
           FROM  apidb.IntronLocation il
           GROUP by il.na_sequence_id, il.start_min,il.end_max,il.is_reversed
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX annottmpnew_pk_ix ON annotgij (na_sequence_id,start_min,end_max,is_reversed,feature_type)

      ]]>
    </sql>
    <!-- table mapping gene source ids to their location including strand information -->
    <sql>
      <![CDATA[
        create table GeneIdLocGIJ&1 (
            na_sequence_id      NUMERIC(10),
            start_min           NUMERIC,
            is_reversed         NUMERIC,
            end_max             NUMERIC,
            na_feature_id       NUMERIC(10),
            source_id           varchar(100),
            total_expression    NUMERIC
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX gnattidloc_pk_ix&1 ON GeneIdLocGIJ&1 (na_sequence_id,start_min,is_reversed,end_max,na_feature_id,source_id,total_expression)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          idlist RECORD;
        BEGIN
        FOR idlist IN ( SELECT DISTINCT na_sequence_id FROM apidb.intronjunction)
        LOOP
          INSERT INTO GeneIdLocGIJ&1  (
          SELECT gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id,
            round(sum(nafe.value)::NUMERIC,2) as total_expression
          FROM  dots.genefeature gf, dots.nalocation l, namemappinggij je, results.nafeatureexpression nafe
          WHERE gf.na_sequence_id = idlist.na_sequence_id
           AND l.na_feature_id = gf.na_feature_id
           AND gf.na_feature_id = nafe.na_feature_id
           AND nafe.protocol_app_node_id = je.exp_pan_id
          GROUP BY gf.na_sequence_id,l.start_min,l.is_reversed,l.end_max,gf.na_feature_id,gf.source_id
        );
        commit;
        END LOOP;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gnidloc_nafid_ix&1 on GeneIdLocGIJ&1 (na_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create UNLOGGED table GIJtmp (
          NA_SEQUENCE_ID               NUMERIC(10),
          SEQUENCE_SOURCE_ID           VARCHAR(100),
          SEGMENT_START                NUMERIC,
          SEGMENT_END                  NUMERIC,
          TOTAL_UNIQUE                 NUMERIC,
          TOTAL_ISRPM                  NUMERIC,
          IS_REVERSED                  NUMERIC(1),
          INTRON_FEATURE_ID            VARCHAR(200),
          MATCHES_GENE_STRAND          NUMERIC,
          GENE_SOURCE_ID               VARCHAR(100),
          GENE_NA_FEATURE_ID           NUMERIC,
          ANNOTATED_INTRON             VARCHAR(10)
        )
      ]]>
    </sql>
    <!-- should add is_contained to this table ... although if gene_source_id is not null then is_contained = 1 -->
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          iter_length numeric := 4999;
          i_first_pos numeric := 1;
          i_last_pos numeric := i_first_pos + iter_length;
          idlist RECORD;
        BEGIN
          FOR idlist IN (
            SELECT na_sequence_id, length, taxon_id, CASE WHEN step_mult > 500000 THEN 500000 ELSE step_mult END as seq_step_mult
            FROM (
              SELECT gs.na_sequence_id, gs.length, gs.taxon_id, 25000 * (1 + floor(gs.length/count(*))) as step_mult
              FROM apidb.intronjunction ij,  dots.nasequence gs
              WHERE gs.na_sequence_id = ij.na_sequence_id
              GROUP BY gs.na_sequence_id, gs.length, gs.taxon_id
            ) t
            ORDER BY taxon_id
            )
          LOOP
            iter_length := idlist.seq_step_mult;
            i_first_pos := 1;
            i_last_pos := i_first_pos + iter_length;
            WHILE i_first_pos < idlist.length
            LOOP
              INSERT INTO GIJtmp
              SELECT DISTINCT
                junc.*,
                CASE
                    WHEN last_value(ga.is_reversed) over w1 = junc.is_reversed
                        THEN 1
                    ELSE 0
                    END as matches_gene_strand,
                last_value(ga.source_id) over w1 as gene_source_id,
                last_value(ga.na_feature_id) over w1 as gene_na_feature_id,
                CASE ag.feature_type WHEN 'Intron' THEN 'Yes' ELSE 'No' END as annotated_intron
              FROM (
                  SELECT ij.na_sequence_id,seq.source_id as sequence_source_id,ij.segment_start,ij.segment_end,
                    sum(ij.unique_reads) as total_unique, round(sum(ij.unique_reads * je.multiplier),2) as total_isrpm,
                    ij.is_reversed,seq.source_id || '_' || ij.segment_start || '_' || ij.segment_end || '_' || ij.is_reversed as intron_feature_id
                  FROM apidb.intronjunction ij, namemappinggij je, dots.nasequence seq
                  WHERE ij.na_sequence_id = idlist.na_sequence_id
                    AND ij.segment_start between i_first_pos and i_last_pos
                    AND ij.na_sequence_id = seq.na_sequence_id
                    AND ij.unique_reads >= 1
                    AND je.junctions_pan_id = ij.protocol_app_node_id
                    AND je.multiplier < 20
                  GROUP BY ij.na_sequence_id,ij.segment_start,ij.segment_end, ij.is_reversed,seq.source_id
                ) junc
                LEFT JOIN GeneIdLocGIJ&1 ga ON
                  junc.na_sequence_id = ga.na_sequence_id
                  AND junc.segment_start >= ga.start_min
                  AND junc.segment_end <= ga.end_max
                  AND junc.is_reversed = ga.is_reversed
                LEFT JOIN annotgij ag ON
                  junc.na_sequence_id = ag.na_sequence_id
                  AND junc.segment_start = ag.start_min
                  AND junc.segment_end = ag.end_max
                  AND junc.is_reversed = ag.is_reversed
              WHERE (junc.total_unique >= 1 or ag.feature_type = 'Intron')
              WINDOW w1 AS (
                PARTITION BY junc.na_sequence_id,junc.sequence_source_id,junc.segment_start,junc.segment_end, junc.is_reversed, junc.intron_feature_id,junc.total_unique, junc.total_isrpm,ag.feature_type
                ORDER BY ga.total_expression ASC
                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
              )
              ;
              commit;
              i_first_pos := i_last_pos + 1;
              i_last_pos := i_first_pos + iter_length;
            END LOOP;
          END LOOP;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gijtmp_gnscid_ix on gijtmp (gene_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE GeneIntronJunction&1 AS
        SELECT
          junc.*, CASE WHEN maxv.gene_source_id is not null and maxv.max_isrpm > 0 THEN round((junc.total_isrpm / maxv.max_isrpm) * 100,2) ELSE null END as percent_max,
          CASE WHEN maxv.gene_source_id is not null THEN 1 ELSE 0 END as contained,
          CAST (null as numeric(10)) as taxon_id,
          cast (null as numeric(10)) as upstream_gene_id,
          cast (null as numeric) as upstream_distance,
          cast (null as numeric(10)) as downstream_gene_id,
          cast (null as numeric) as downstream_distance
        FROM
          gijtmp junc LEFT JOIN
          (
            SELECT gene_source_id,max(total_unique) as max_unique, max(total_isrpm) as max_isrpm
            FROM gijtmp
            WHERE gene_source_id is not null
            GROUP BY gene_source_id
          ) maxv ON junc.gene_source_id = maxv.gene_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE GeneIntronJunction&1 gij
        SET taxon_id
            = (SELECT taxon_id
               FROM dots.NaSequence
               WHERE na_sequence_id = gij.na_sequence_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gijnew_loc_ix&1 on GeneIntronJunction&1 (na_sequence_id,segment_start,segment_end,is_reversed)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gijnew_gnscid_ix&1 on GeneIntronJunction&1 (intron_feature_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gijnew_txnloc_ix&1
         on GeneIntronJunction&1
            (taxon_id, na_sequence_id, segment_start, segment_end, is_reversed,
             total_unique, total_isrpm, annotated_intron)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneIntJuncStats">
    <comment> Stores statistics for annotated introns used for configuring JBrowse tracks based on organism.
    </comment>
    <internalDependency name="GeneIntronJunction"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneIntJuncStats&1 AS
        WITH org_tot AS (
          SELECT
            gs.organism,
            min(gij.total_unique) as min_annot_score, PERCENTILE_cont(0.005) within group (order by gij.total_unique asc) as perc005_annot_score,
            PERCENTILE_cont(0.01) within group (order by gij.total_unique asc) as perc01_annot_score,
            min(gij.percent_max) as min_annot_percent_max, PERCENTILE_cont(0.0001) within group (order by gij.percent_max asc) as perc0001_annot_percent_max,
            PERCENTILE_cont(0.0005) within group (order by gij.percent_max asc) as perc0005_annot_percent_max,
            floor(max(gij.segment_end - gij.segment_start) * 1.25) as max_intron_length
          FROM geneintronjunction gij, genomicseqattributes gs
          WHERE gs.na_sequence_id = gij.na_sequence_id
            AND gij.annotated_intron = 'Yes'
          GROUP BY gs.organism
        )
        SELECT gs.na_sequence_id, gs.source_id, ot.*
        FROM genomicseqattributes gs, org_tot ot
        WHERE gs.organism = ot.organism
          AND gs.na_sequence_id in (SELECT DISTINCT na_sequence_id FROM apidb.intronjunction)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneIntJuncStat_ix&1 on GeneIntJuncStats&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneMaxIntronGIJ">
    <comment> Stores maximum values per gene for each sample so percent max intron can be computed for sample table.
    </comment>
    <internalDependency name="GeneIntronJunction"/>
    <internalDependency name="NameMappingGIJ"/>
    <externalDependency name="apidb.intronjunction"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneMaxIntronGIJ&1 (
            protocol_app_node_id    NUMERIC(10),
            gene_source_id          VARCHAR(200),
            max_unique              NUMERIC,
            max_isrpm               NUMERIC,
            sum_unique              NUMERIC,
            sum_isrpm               NUMERIC,
            avg_unique              NUMERIC,
            avg_isrpm               NUMERIC
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
          DECLARE
            idlist RECORD;
          BEGIN
            FOR idlist IN (
              SELECT DISTINCT na_sequence_id
              FROM GeneIdLocGIJ
            )
            LOOP
            INSERT INTO GeneMaxIntronGIJ&1 (
              SELECT j.protocol_app_node_id, ga.source_id, max(unique_reads) as max_unique, max(round(j.unique_reads * mult.multiplier,2)) as max_isrpm,
                sum(unique_reads) as sum_unique, sum(round(j.unique_reads * mult.multiplier,2)) as sum_isrpm, avg(unique_reads) as avg_unique, avg(round(j.unique_reads * mult.multiplier,2)) as avg_isrpm
              FROM apidb.intronjunction j, GeneIdLocGIJ ga, namemappinggij mult
              WHERE ga.na_sequence_id = idlist.na_sequence_id
                AND ga.na_sequence_id = j.na_sequence_id
                AND ga.start_min <= j.segment_start
                AND ga.end_max >= j.segment_end
                AND ga.is_reversed = j.is_reversed
                AND j.protocol_app_node_id = mult.junctions_pan_id
              GROUP BY j.protocol_app_node_id, ga.source_id
            );
            commit;
            END LOOP;
          END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX GnMxIntGIJ_ix&1 on GeneMaxIntronGIJ&1 (gene_source_id,protocol_app_node_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PopsetSequence">
    <comment> Each record stores the nucleotide sequence of one popset. Used in the
      relevant attribute query of the WDK popset record, as well as by
      PopsetClustalOmega. Propagated to portal instances.
    </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
        CREATE TABLE PopsetSequence&1 AS
        SELECT ia.source_id, ia.project_id,
               ns.sequence
        FROM PopsetAttributes ia, dots.NaSequence ns
        WHERE ia.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PopsetSeq_ix&1 on PopsetSequence&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviation">
    <comment> Each record maps an organism name onto an abbreviation, getting the
      pair either from apidb.Organism or (in the case of Tvag), hardwired
      into the below SQL. This table will eventually be replaced by workflow.
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 AS
       SELECT organism, abbreviation
       FROM (
        select tn.name as organism, o.name_for_filenames as abbreviation
        from apidb.Organism o, sres.TaxonName tn
        where o.taxon_id = tn.taxon_id
        and tn.name_class = 'scientific name'
       ) subquery1
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
      names. Each record maps an organism name onto this abbreviation, as
      well as the species name and project ID. Used by the model and as an
      input in the creation of the OrganismAbbreviationBlast tuning table.
      Propagated to portal instances.
    </comment>
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviationWS&1 as
       SELECT oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       FROM OrganismAbbreviation oa, OrganismTree ot
       WHERE ot.term = oa.organism
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProjectIdTaxonLevel">
    <comment> Groups projects by higher level taxonomy. Used in the creation of the
      OldOrganismTree tuning table.
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 AS
       SELECT p.project_id, taxon_node, organism
       FROM (
        SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node
		UNION
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		UNION
		SELECT 'HostDB' AS project_id,
		           'Chordata' AS taxon_node
       ) p,
        (select distinct project_id, organism from GenomicSeqAttributes) s
        where p.project_id = s.project_id
        union
        SELECT distinct s.project_id as project_id,
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Allomyces%')
            then 'Blastocladiomycetes'
            when (s.organism like 'Batrachochytrium%' or
                  s.organism like 'Spizellomyces%')
            then 'Chytridiomycetes'
            when (s.organism like 'zymoseptoria%' or
                  s.organism like 'Zymoseptoria%' or
                  s.organism like 'Cenococcum%')
            then 'Dothideomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Amauroascus%' or
                  s.organism like 'Byssoonygena%' or
                  s.organism like 'Chrysosporium%' or
                  s.organism like 'Cladophialophora%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Cyphellophora%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Exophiala%' or
                  s.organism like 'Fonsecaea%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Paracoccidioides%' or
                  s.organism like 'Uncinocarpus%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Rhizophagus%')
            then 'Glomeromycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or
                  s.organism like 'Botryotinia%')
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Saprolegnia%' or
                  s.organism like 'Albugo%' or
                  s.organism like 'Aphanomyces%' or
                  s.organism like 'Pythium%')
            then 'Oomycetes'
            when (s.organism like 'Pneumocystis%')
            then 'Pneumocystidomycetes'
            when (s.organism like 'Puccinia%' or
                  s.organism like 'Melampsora%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Yarrowia%' or
                  s.organism like 'Clavispora%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes'
            when (s.organism like 'Neurospora%' or
                  s.organism like 'Magnaporthe%' or
                  s.organism like 'Fusarium%' or
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Lomentospora%' or
                  s.organism like 'Scedosporium%' or
                  s.organism like 'Sordaria%' or
                  s.organism like 'Sporothrix%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Kwoniella%' or
                  s.organism like 'Naganishia%' or
                  s.organism like 'Cryptococcus%')
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or
                  s.organism like 'Sporisorium%')
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%' or
                  s.organism like 'Phycomyces%')
            then 'Zygomycetes'
            when (s.organism like 'Ixodes%')
            then 'Ixodida'
            when (s.organism like 'Pediculus%')
            then 'Phthiraptera'
            when (s.organism like 'Leptotrombidium%')
            then 'Trombidiformes'
            when s.organism like 'Sarcoptes%'
            then 'Sarcoptiformes'
            when (s.organism like 'Cimex%' or
                  s.organism like 'Rhodnius%')
            then 'Hemiptera'
            when (s.organism like 'Aedes%' or
                  s.organism like 'Anopheles%' or
                  s.organism like 'Glossina%' or
                  s.organism like 'Culex%' or
                  s.organism like 'Lutzomyia%' or
                  s.organism like 'Musca%' or
                  s.organism like 'Phlebotomus%' or
                  s.organism like 'Stomoxys%')
            then 'Diptera'
            when (s.organism like 'Biomphalaria%')
            then 'Gastropoda'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from GenomicSeqAttributes s
        where s.project_id in ('FungiDB', 'VectorBase')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OldOrganismTree">
    <comment> Group species by higher level taxonomy. Each row associates a taxon of
      interest with one of its ancestors in the taxon tree. Used in parameter
      queries that have to know about the taxon tree, as well as
      apidb.project_id(), the function that maps an organism name to a
      project. Propagated to portal instances.
    </comment>
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
        CREATE TABLE StrainTree AS
        SELECT *
        FROM (
          SELECT organism,term,parentTerm, internal,project_id
          FROM (
            /* all organisms from GenomicSeqAttributes as organism, organism as term, parentterm is species */
            SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
            WHERE tn.name = sa.organism
              AND ts.taxon_id = tn.taxon_id
              AND sn.taxon_id = ts.species_taxon_id
              AND t.taxon_id = ts.taxon_id
              AND sn.name_class = 'scientific name'
              AND t.rank != 'species'
            UNION
            /* all organisms from GenomicSeqAttributes as organism, species as term, parentterm is genus */
            /* we are getting a row for species level AND for children here */
            SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,1,nullif(position (' ' in sa.organism) - 1,-1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, sres.Taxon t,
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
            WHERE tn.name = sa.organism
              AND  ts.taxon_id = tn.taxon_id
              AND  sn.taxon_id = ts.species_taxon_id
              AND t.taxon_id = ts.taxon_id
              AND sn.name_class = 'scientific name'
            UNION
            SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,1,nullif(position (' ' in sa.organism) - 1,-1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, sres.Taxon t,
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
            WHERE tn.name = sa.organism
              AND  ts.taxon_id = tn.taxon_id
              AND  sn.taxon_id = ts.species_taxon_id
              AND t.taxon_id = ts.taxon_id
              AND sn.name_class = 'scientific name'
            UNION
            /* all organisms from GenomicSeqAttributes as organism, genus as term, parentterm from taxonlevel */
            SELECT DISTINCT sa.organism,
                           SUBSTR(sa.organism,1,nullif(position (' ' in sa.organism) - 1,-1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.organism not like 'Chromera%'
              AND ptl.organism not like 'Vitrella%'
            UNION
            /* all organisms from GenomicSeqAttributes as organism, taxon_node as term, parentterm is null */
            SELECT DISTINCT sa.organism,
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.project_id not in ('FungiDB','MicrosporidiaDB')
              AND ptl.organism not like 'Chromera%'
              AND ptl.organism not like 'Vitrella%'
            UNION
            -- add the kingdom for Fungi organism (this includes MicrosporidiaDB organisms)
            SELECT DISTINCT sa.organism,
                           ptl.taxon_node AS term,
                           'Fungi' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.project_id in ('FungiDB','MicrosporidiaDB')
              AND ptl.taxon_node != 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,
                           'Fungi' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.project_id in ('FungiDB','MicrosporidiaDB')
              AND ptl.taxon_node != 'Oomycetes'
            UNION
            -- add the kingdom for Oomycetes in FungiDB
            SELECT DISTINCT sa.organism,
                           ptl.taxon_node AS term,
                           'Oomycetes' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.taxon_node = 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,
                           'Oomycetes' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
            WHERE ptl.project_id = sa.project_id
              AND ptl.organism = sa.organism
              AND ptl.taxon_node = 'Oomycetes'
            UNION
            -- add the phylum for chomera and vitrella
            SELECT DISTINCT sa.organism,
                            SUBSTR(sa.organism,1,nullif(position (' ' in sa.organism) - 1,-1)) AS term,
                           'Chromerida' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa
            WHERE sa.organism like 'Chromera%'
              OR sa.organism like 'Vitrella%'
            UNION
            SELECT DISTINCT sa.organism,
                           'Chromerida' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
            FROM GenomicSeqAttributes sa
            WHERE sa.organism like 'Chromera%'
              OR sa.organism like 'Vitrella%'
          ) t
        ) t2
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OldOrganismTree&1 AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           SELECT * from StrainTree
           UNION
           SELECT stn.name as organism,
                  st.term as term,
                  st.parentTerm as parentTerm,
                  st.internal as internal,
                  st.project_id as project_id
           FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
           WHERE tn.taxon_id = ts.taxon_id
             AND stn.taxon_id = ts.species_taxon_id
             AND st.organism = tn.name
             AND tn.name_class = 'scientific name'
             AND stn.name_class = 'scientific name'
             AND st.organism != st.term
          ) t
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismTree">
    <comment>
      Group species by higher level taxonomy. Each row associates a taxon of
      interest with one of its ancestors in the taxon tree. Used in parameter
      queries that have to know about the taxon tree. Propagated to portal
      instances.
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <ancillaryTable name="DistinctTaxonLink"/>
    <sql>
      <![CDATA[
        CREATE TABLE DistinctTaxonLink&1 as
        SELECT taxon_id, max(rank) as rank, max(parent_id) AS parent_id,
               max(tree_level) as tree_level,
               max(display_reason) as display_reason
        FROM (
          WITH RECURSIVE cte AS (
            SELECT taxon_id, rank, parent_id, 1 as tree_level
            FROM sres.taxon
            WHERE taxon_id IN (select taxon_id from GenomicSeqAttributes)
            UNION ALL
            SELECT t.taxon_id, t.rank, t.parent_id, cte.tree_level + 1 as tree_level
            FROM sres.taxon t, cte
            WHERE cte.parent_id = t.taxon_id
          )
          SELECT taxon_id, rank, parent_id, tree_level,
            CASE
              WHEN taxon_id in (select taxon_id from GenomicSeqAttributes) THEN 'has data'
              WHEN rank in ('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species') THEN 'major rank'
              WHEN taxon_id in (
                SELECT taxon_id
                FROM sres.taxon
                WHERE ncbi_tax_id in (44542 -- gambiae species complex
                     , 554915 -- Amoebozoa
                     , 5796 -- Coccidia
                     , 1280412 -- Conoidasida
              )) THEN 'hardwired'
              ELSE 'none'
            END as display_reason
          FROM cte
        ) t
        GROUP BY taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index dtl_ix&1
          ON DistinctTaxonLink&1 (taxon_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          skiplist RECORD;
        BEGIN
          FOR skiplist
              IN (SELECT taxon_id, max(parent_id) as parent_id, max(tree_level)
                  FROM DistinctTaxonLink&1
                  WHERE display_reason in ('none', 'has data')
                  GROUP by taxon_id
                  ORDER by max(tree_level) desc
                 )
          LOOP
            UPDATE DistinctTaxonLink&1
            SET parent_id
                = (SELECT max(parent_id)
                   FROM DistinctTaxonLink&1
                   WHERE taxon_id = skiplist.taxon_id)
            WHERE parent_id = skiplist.taxon_id;
          END LOOP;
          commit;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DELETE FROM DistinctTaxonLink&1 WHERE display_reason = 'none'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 AS
        WITH dtl AS (
          WITH RECURSIVE cte AS (
            SELECT taxon_id as leaf_taxon_id, taxon_id,
                parent_id, rank, tree_level
            FROM DistinctTaxonLink&1
            WHERE display_reason = 'has data' OR rank = 'species'
            UNION
            SELECT cte.leaf_taxon_id, dtl.taxon_id, dtl.parent_id, dtl.rank, dtl.tree_level
            FROM  DistinctTaxonLink&1 dtl, cte
            WHERE cte.parent_id = dtl.taxon_id
          )
          SELECT *
          FROM cte
        ) , parent_name AS (
          SELECT taxon_id, name
          FROM sres.TaxonName
          WHERE name_class = 'scientific name'
        )
        SELECT leaf_name.name as organism,
               tn.name as term, parent_name.name parentterm,
               dtl.taxon_id as internal,
               apidb.project_id(leaf_name.name) as project_id,
               dtl.tree_level, dtl.rank
        FROM
           sres.TaxonName leaf_name, sres.TaxonName tn,
           dtl LEFT JOIN parent_name ON dtl.parent_id = parent_name.taxon_id
        WHERE dtl.leaf_taxon_id = leaf_name.taxon_id
          AND leaf_name.name_class = 'scientific name'
          AND dtl.taxon_id = tn.taxon_id
          AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index OrgTree_term_pterm_ix&1 on OrganismTree&1(TERM, PARENTTERM)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
      BLAST-query parameters. Propagated to portal instances.
    </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviationBlast&1 as
       SELECT organism, parent, abbreviation, substr(project_id, 1, 20) as project_id
       FROM OrganismAbbreviationWS
       UNION
         -- all familes for popsets
       SELECT DISTINCT family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent,
                       family_name_for_files as abbreviation, substr(project_name, 1, 20) as project_id
       FROM apidb.Organism
       WHERE family_name_for_files is not null
         AND abbrev || '_isolates_genbank_RSRC' IN (SELECT external_db_name as db_name FROM PopsetAttributes)
         AND family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Ordosporidae')
       UNION
       SELECT special.organism, special.parent, special.abbreviation,
              substr(ot.project_id, 1, 20) as project_id
       FROM OrganismTree ot,
            ( -- all species and speciesAbbreviations from apidb.Organism where we have ests
               SELECT DISTINCT
                sp.name as organism, ot.parentTerm as parent,
                regexp_replace(org.name_for_filenames, replace(org.strain_abbrev, '/','_'),'') as abbreviation
               FROM sres.TaxonName sp, TaxonSpecies ts, apidb.Organism org, OrganismTree ot
               WHERE org.taxon_id = ts.taxon_id
                 AND ts.species_taxon_id = sp.taxon_id
                 AND sp.name_class = 'scientific name'
                 AND ot.term = sp.name
                 AND org.strain_abbrev is not null
                 AND org.name_for_filenames is not null
                 AND sp.taxon_id
                     in (SELECT etn.taxon_id
                         FROM sres.TaxonName etn
                         WHERE etn.name in (SELECT organism FROM EstAttributes))
             UNION
               SELECT 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism,
                      'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation
            ) special
       WHERE special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
      species. Used in BLAST param queries. Propagated to portal instances.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE BlastTypes&1 as
        /* Standard GENES */
        SELECT distinct organism, project_id, type
        FROM TranscriptAttributes,
             (SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE organism not in ('Toxoplasma gondii RH') and (gene_type = 'protein coding' or gene_type = 'protein coding gene')
        UNION
        /* GiardiaDB Deprecated Genes */
        SELECT 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type
        FROM (SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        UNION
        /* GiardiaDB Scaffolds */
        SELECT 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, 'Genome' as type
        UNION
        /* Standard GENOME */
        SELECT distinct organism, project_id, 'Genome' as type
        FROM GenomicSeqAttributes
        UNION
        /* Mitochondrial GENES and GENOME */
        SELECT DISTINCT organism || ' mitochondrial', project_id, type
        FROM GenomicSeqAttributes,
          (SELECT 'Genome' as type UNION SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE so_id = 'SO:0000819'
          AND NOT project_id='PlasmoDB'
        UNION
        /* Plastid GENES and GENOME */
        SELECT DISTINCT organism || ' plastid' as organism, project_id, type
        FROM GenomicSeqAttributes,
          (SELECT 'Genome' as type UNION SELECT 'AnnotatedTranscripts' as type UNION SELECT 'AnnotatedProteins' as type) t
        WHERE so_id = 'SO:0001259'
          AND NOT project_id='PlasmoDB'
        UNION
        /* Regular ESTs (all species from estattributes) */
        SELECT DISTINCT sp.name as organism, ea.project_id, 'ESTs' as type
        FROM EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
        WHERE ea.organism = tn.name
          AND (tn.taxon_id = ts.taxon_id or tn.taxon_id = ts.species_taxon_id)
          AND ts.species_taxon_id = sp.taxon_id
          AND sp.name_class = 'scientific name'
        UNION
        /* regular Isolates */
        SELECT DISTINCT family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'PopSet'
        FROM apidb.Organism
        WHERE family_name_for_files is not null
          AND abbrev || '_isolates_genbank_RSRC' in (SELECT DISTINCT external_db_name  AS db_name FROM PopsetAttributes)
        UNION
        /* isolates are hard coded */
        SELECT 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'PopSet' as type
        UNION
        SELECT 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'PopSet' as type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundProperties"  prefixEnabled="true">
    <comment> Properties table for ChEBI Compounds.
    </comment>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <!-- externalDependency name="chebi.Names"/ -->
    <!-- externalDependency name="chebi.Chemical_Data"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE CompoundProperties&1 AS
        SELECT c.ID, c.chebi_accession AS source_id, c.parent_id,
            c.name AS compound_name,
            substr(string_agg(cn.name, ';'), 1, 1000) AS other_names,
            substr(string_agg(ciup.iupac_name, ';'), 1, 1000) AS iupac_name,
            substr(string_agg(csyn.syn, ';'), 1, 1000) AS syn,
            c.definition, m.mass,
            string_agg(formu.formula, ';' order by formu.formula) AS formula,
            string_agg(sec.chebi_accession, ';' order by sec.chebi_accession) AS secondary_ids
        FROM  chebi.compounds c
          LEFT JOIN ( SELECT compound_id,  NAME FROM chebi.names WHERE TYPE='NAME')
            cn ON  c.ID = cn.compound_id
          LEFT JOIN ( SELECT compound_id,  MIN(NAME) AS iupac_name FROM chebi.names WHERE TYPE='IUPAC NAME' GROUP BY compound_id)
            ciup ON c.ID = ciup.compound_id
          LEFT JOIN ( SELECT compound_id,  MIN(NAME) AS syn FROM chebi.names WHERE type='SYNONYM' GROUP BY compound_id)
            csyn ON c.ID = csyn.compound_id
          LEFT JOIN ( SELECT compound_id, chemical_data AS formula FROM chebi.chemical_data WHERE TYPE='FORMULA')
            formu ON  c.ID = formu.compound_id
          LEFT JOIN ( SELECT compound_id, chemical_data AS mass FROM chebi.chemical_data WHERE TYPE='MASS' and chemical_data != 'NaN')
            m ON c.ID = m.compound_id
          LEFT JOIN ( SELECT parent_id, chebi_accession FROM chebi.compounds)
            sec ON c.ID = sec.parent_id
        WHERE NOT c.status in ('D', 'F')
        GROUP BY c.ID, c.chebi_accession, c.parent_id, c.name, c.definition, m.mass
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes"  prefixEnabled="true">
    <comment> The BFMV for the compound WDK record type. Used by the model for the
      compound record and queries, as well as in the creation of the
      PathwayCompounds tuning table. Propagated to portal instances.
      Note: children of ChEBI compounds are excluded, but data of these is gathered in the (parent) entries.
    </comment>
    <internalDependency name="CompoundProperties"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCompoundAttributes&1 AS
        SELECT p.ID
        , p.source_id
        , p.compound_name
        , string_agg(childc.other_names, ';' ORDER BY childc.other_names) AS other_names
        , string_agg(childc.iupac_name, ';' ORDER BY childc.iupac_name) AS iupac_name
        , string_agg(childc.syn, ';' ORDER BY childc.syn) AS syn
        , p.definition
        , p.secondary_ids
        , string_agg(childc.formula, ';' ORDER BY childc.formula) AS formula
        , avg(childc.mass::numeric) AS mass
        FROM CompoundProperties p
        , (SELECT id, parent_id, other_names, iupac_name, syn, mass, formula FROM CompoundProperties ) childc
        WHERE p.parent_id IS NULL
          AND  ( p.ID = childc.parent_id OR p.ID = childc.ID )
        GROUP BY p.ID, p.source_id, p.compound_name, p.definition, p.secondary_ids
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixCompoundAttributes_idx&1 ON &prefixCompoundAttributes&1 (source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundId" prefixEnabled="true">
    <comment> Alias table for Compounds.
      Compound column is the source_id from CompoundAttributes (chEBI_ID).
      ID can have this same ID, or mapping KEGG ID, or Name, or Synonym.
    </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="CompoundProperties"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCompoundId&1 AS
        SELECT source_id AS id, source_id AS compound, 'same ID' AS type, '' as source
        FROM &prefixCompoundAttributes
        UNION
        SELECT p.source_id AS id, ca.source_id AS compound, 'child ID' AS type, '' as source
        FROM &prefixCompoundAttributes ca, CompoundProperties p
        WHERE ca.id = p.parent_id
        UNION
        SELECT da.accession_number AS id,  p.source_id AS compound, 'KEGG'  AS type, '' as source
        FROM chebi.database_accession da, &prefixCompoundAttributes p
        WHERE da.type='KEGG COMPOUND accession'
        AND  da.compound_id = p.id
        UNION
        SELECT  distinct da.accession_number AS id,  p.chebi_accession AS compound, 'KEGG'  as type, '' as source
        FROM chebi.database_accession da, chebi.compounds c, chebi.compounds p
        WHERE NOT p.status in ('D', 'F') AND da.type='KEGG COMPOUND accession'
        AND da.compound_id = c.id AND c.parent_id=p.id
        UNION
        SELECT n.name as id, ca.source_id as compound, 'name' as type, n.source
        FROM &prefixCompoundAttributes ca, chebi.names n
        WHERE ca.id = n.compound_id
        AND n.type = 'NAME'
        UNION
        SELECT n.name as id, ca.source_id as compound, 'synonym' as type, n.source
        FROM &prefixCompoundAttributes ca, chebi.names n
        WHERE ca.id = n.compound_id
        AND n.type = 'SYNONYM'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixCompoundId_idx&1 ON &prefixCompoundId&1 (id, compound)

      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="PathwayCompounds">
    <comment> Each record represents a 5-tuple of (reaction, compound, pathway,
      enzyme, type). Used extensively in the model for pathway-related
      queries, as well as by getImageMap.pl.
    </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE PathwayCompounds&1 AS
        SELECT
          pathway_id
          , reaction_id
          , ext_db_name
          , ext_db_version
          , compound_node_id
          , compound_source_id
          , c.chebi_accession
          , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
          , type
        FROM (
          SELECT
            p.PATHWAY_ID
            , prx.PATHWAY_REACTION_ID as reaction_id
            , ed.NAME as ext_db_name
            , edr.version as ext_db_version
            , pn.pathway_node_id as compound_node_id
            , pn.DISPLAY_LABEL as compound_source_id
            , 'substrate' as type
            , pn.row_id
          FROM
            APIDB.PATHWAYREACTION prx
            , SRES.PATHWAY p
            , APIDB.PATHWAYREACTIONREL prr
            , SRES.PATHWAYNODE pn
            , SRES.PATHWAYRELATIONSHIP prel
            , SRES.ONTOLOGYTERM ot
            , SRES.EXTERNALDATABASE ed
            , SRES.EXTERNALDATABASERELEASE edr
          WHERE p.PATHWAY_ID = prr.PATHWAY_ID
            AND prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
            AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
            AND prel.NODE_ID = pn.PATHWAY_NODE_ID
            AND ot.NAME = 'molecular entity'
            AND ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
            AND p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
            AND edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID
        ) t LEFT OUTER JOIN CHEBI.COMPOUNDS c on t.row_id = c.ID
        UNION
        SELECT
          pathway_id
          , reaction_id
          , ext_db_name
          , ext_db_version
          , compound_node_id
          , compound_source_id
          , c.chebi_accession
          , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
          , type
        FROM (
          SELECT
            p.PATHWAY_ID
            , prx.PATHWAY_REACTION_ID as reaction_id
            , ed.NAME as ext_db_name
            , edr.version as ext_db_version
            , pn.pathway_node_id as compound_node_id
            , pn.DISPLAY_LABEL as compound_source_id
            , 'product' as type
            , pn.row_id
          FROM
            APIDB.PATHWAYREACTION prx
            , SRES.PATHWAY p
            , APIDB.PATHWAYREACTIONREL prr
            , SRES.PATHWAYNODE pn
            , SRES.PATHWAYRELATIONSHIP prel
            , SRES.ONTOLOGYTERM ot
            , SRES.EXTERNALDATABASE ed
            , SRES.EXTERNALDATABASERELEASE edr
          WHERE p.PATHWAY_ID = prr.PATHWAY_ID
            AND prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
            AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
            AND prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID
            AND ot.NAME = 'molecular entity'
            AND ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
            AND p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
            AND edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID
        ) t2 LEFT OUTER JOIN CHEBI.COMPOUNDS c on t2.row_id = c.ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PthCmpd_id_ix&1
        on PathwayCompounds&1(pathway_id, reaction_id, ext_db_name)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayReactions">
    <comment>Aggregates reactions irrespective of pathway.  Required to determine if BioCyc reactions are reversible.  Used extensively in the model in conjunction with pathwaycompounds for pathway related queries</comment>
    <internalDependency name="PathwayCompounds"/>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwayReactions&1 AS
        SELECT o.*
        , CASE WHEN o.expasy_url IS NOT NULL THEN '<a href="' || o.expasy_url || '">' || o.enzyme || '</a>' ELSE o.enzyme END as expasy_html
        FROM (
          SELECT i.*
          , CASE WHEN i.enzyme like '%.%.%.%' and i.enzyme != '-.-.-.-'
            THEN
              'http://enzyme.expasy.org/cgi-bin/enzyme/enzyme-search-ec?field1='
              || ec.ec_number_1
              || CASE ec.ec_number_2 WHEN null THEN null ELSE chr(38) || 'field2=' || ec.ec_number_2 END
              || CASE ec.ec_number_3 WHEN null THEN null ELSE chr(38) || 'field3=' || ec.ec_number_3 END
              || CASE ec.ec_number_4 WHEN null THEN null ELSE chr(38) || 'field4=' || ec.ec_number_4 END
            ELSE reaction_url END as expasy_url
          , ec.description as enzyme_description
          FROM (
            SELECT
              reaction_id
              , reaction_source_id
              , reaction_url
              , ext_db_name
              , ext_db_version
              , enzyme
              , substrates_html || ' ' || sign || ' ' || products_html as equation_html
              , substrates_text || ' ' || sign || ' ' || products_text as equation_text
              , case when sign = '<=>' then 1 else 0 end as is_reversible
              , substrates_text
              , products_text
            FROM (
              SELECT
                reaction_id
                , reaction_source_id
                , reaction_url
                , ext_db_name
                , ext_db_version
                , enzyme
                , (case when (string_agg (case when type_list like '%substrate%' then compound end, ',' order by compound)) = (string_agg (case when type_list like '%product%' then compound end, ',' order by compound)) or is_reversible = 1 then '<=>' else '=>' end) as sign
                , string_agg(case when type like '%substrate%' then compound_url end, ' + ' order by compound_url) as substrates_html
                , string_agg(case when type like '%substrate%' then compound end, ' + ' order by compound) as substrates_text
                , string_agg(case when type like '%product%' then compound_url end, ' + ' order by compound_url) as products_html
                , string_agg(case when type like '%product%' then compound end, ' + ' order by compound) as products_text
              FROM (
                WITH rep AS (
                  SELECT DISTINCT
                    pr.PATHWAY_REACTION_ID as reaction_id
                    , pr.SOURCE_ID as reaction_source_id
                    , pn.DISPLAY_LABEL as enzyme
                    , coalesce(ca.compound_name, pc.compound_source_id) as compound
                    , prel.is_reversible as is_reversible_og
                    , last_value(prel.is_reversible) OVER (partition by pr.pathway_reaction_id ORDER BY prel.is_reversible ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) as is_reversible
                    , first_value(pc.type) over (partition by pr.pathway_reaction_id, pr.SOURCE_ID, pn.DISPLAY_LABEL, prel.IS_REVERSIBLE, coalesce(pc.chebi_accession, pc.compound_source_id), coalesce(ca.compound_name, pc.compound_source_id) ORDER BY pc.pathway_id ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as type
                  FROM
                    sres.pathway p
                    , apidb.pathwayreaction pr
                    , APIDB.PATHWAYREACTIONREL prr
                    , SRES.PATHWAYNODE pn
                    , SRES.PATHWAYRELATIONSHIP prel
                    , SRES.ONTOLOGYTERM ot
                    , PathwayCompounds pc
                    LEFT JOIN CompoundAttributes ca ON pc.chebi_accession = ca.source_id
                  WHERE p.PATHWAY_ID = prr.PATHWAY_ID
                    AND pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
                    AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
                    AND prel.NODE_ID = pn.PATHWAY_NODE_ID
                    AND ot.name = 'enzyme'
                    AND ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
                    AND pc.PATHWAY_ID = p.PATHWAY_ID
                    AND pc.REACTION_id = pr.PATHWAY_REACTION_ID
                )
                SELECT DISTINCT
                  pr.PATHWAY_REACTION_ID as reaction_id
                  , pr.SOURCE_ID as reaction_source_id
                  , ed.NAME as ext_db_name
                  , edr.VERSION as ext_db_version
                  , cast(pn.DISPLAY_LABEL as varchar(20)) as enzyme
                  , min(rep.is_reversible) as is_reversible
                  , min(rep.type) as type
                  , string_agg (pc.type, ',' order by p.pathway_id) as type_list
                  , coalesce(ca.compound_name, pc.compound_source_id) as compound
                  , CASE
                    WHEN coalesce(pc.CHEBI_ACCESSION, pc.compound_source_id) LIKE 'CHEBI%'
                    THEN '<a href="/a/app/record/compound/' || coalesce(pc.chebi_accession, pc.compound_source_id)
                         || '" title="' || coalesce(pc.chebi_accession, pc.compound_source_id) || '">' || coalesce(ca.compound_name, pc.compound_source_id) || '</a>'
                    ELSE coalesce(pc.chebi_accession, pc.compound_source_id)
                    END as compound_url
                  , CASE (replace (replace (ed.name, 'Pathways_', ''), '_RSRC', ''))
                    WHEN 'KEGG' THEN 'https://www.genome.jp/dbget-bin/www_bget?rn:' || pr.source_id
                    WHEN 'MetaCyc' THEN 'https://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                    WHEN 'TrypanoCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                    WHEN 'LeishCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/LEISH/new-image?tyrp=REACTION' || chr(38) || 'object=' || pr.source_id
                    WHEN 'FungiCyc' THEN NULL
                    END as reaction_url
                FROM
                  sres.pathway p
                  , apidb.pathwayreaction pr
                  , APIDB.PATHWAYREACTIONREL prr
                  , SRES.PATHWAYNODE pn
                  , SRES.PATHWAYRELATIONSHIP prel
                  , SRES.EXTERNALDATABASE ed
                  , SRES.EXTERNALDATABASERELEASE edr
                  , SRES.ONTOLOGYTERM ot
                  , rep
                  , PathwayCompounds pc
                  LEFT JOIN CompoundAttributes ca ON pc.chebi_accession = ca.source_id
                WHERE p.PATHWAY_ID = prr.PATHWAY_ID
                  AND pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
                  AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
                  AND prel.NODE_ID = pn.PATHWAY_NODE_ID
                  AND ot.name = 'enzyme'
                  AND ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
                  AND pc.EXT_DB_NAME = ed.NAME
                  AND pc.EXT_DB_VERSION = edr.VERSION
                  AND ed.EXTERNAL_DATABASE_ID = edr.EXTERNAL_DATABASE_ID
                  AND pc.PATHWAY_ID = p.PATHWAY_ID
                  AND pc.REACTION_id = pr.PATHWAY_REACTION_ID
                  AND rep.reaction_id = pr.pathway_reaction_id
                  AND rep.reaction_source_id = pr.source_id
                  AND rep.compound = coalesce(ca.compound_name, pc.compound_source_id)
                  AND rep.enzyme = pn.DISPLAY_LABEL
                  AND rep.is_reversible_og = prel.is_reversible
                GROUP BY pr.pathway_reaction_id, pr.SOURCE_ID, ed.NAME, edr.VERSION, pn.DISPLAY_LABEL, prel.IS_REVERSIBLE
                  , coalesce(pc.chebi_accession, pc.compound_source_id)
                  , coalesce(ca.compound_name, pc.compound_source_id)
              ) t1
              GROUP BY reaction_id, reaction_source_id, reaction_url, ext_db_name, ext_db_version, enzyme, is_reversible
            ) t2
          ) i
          LEFT OUTER JOIN sres.enzymeclass ec ON i.enzyme = ec.ec_number
        ) o
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathRcts_id_ix&1
        on PathwayReactions&1 (reaction_id, reaction_source_id, enzyme, expasy_url, ext_db_name)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayNodes">
    <comment>Nodes and edges for pathway maps</comment>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayNodeGene"/>
    <internalDependency name="CompoundId"/>
    <internalDependency name="PathwayReactions"/>
    <ancillaryTable name="PathwayEdges"/>
    <intermediateTable name="NodesWithTypes"/>
    <intermediateTable name="ReactionsWithReversibility"/>
    <intermediateTable name="EnzymeEdges"/>
    <intermediateTable name="ParentNodes"/>
    <intermediateTable name="NodesWithParents"/>
    <intermediateTable name="EnzymeReactions"/>
    <intermediateTable name="ParentsForEdges"/>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE NodesWithTypes AS
        SELECT pn.pathway_id
          , CASE WHEN pa.name IS NOT NULL THEN pa.name ELSE pn.display_label END AS display_label
          , pa.url
          , CASE WHEN pa.name IS NOT NULL THEN pa.name ELSE pn.display_label END AS name
          , pa.source_id AS node_identifier
          , pn.pathway_node_id AS pathway_node_id
          , pn.x
          , pn.y
          , pn.width
          , pn.height
          , pn.cellular_location
          , ot.name AS type
          , NULL AS gene_count
          , NULL AS default_structure
        FROM sres.pathwaynode pn
          INNER JOIN sres.ontologyterm ot ON pn.pathway_node_type_id = ot.ontology_term_id
          LEFT JOIN PathwayAttributes pa ON pn.display_label = pa.source_id
        WHERE ot.name = 'metabolic process'
        UNION ALL
        SELECT pn.pathway_id
          , pn.display_label
          , NULL AS url
          , coalesce(ec.description, pn.display_label) AS name
          , ec.ec_number AS node_identifier
          , pn.pathway_node_id AS pathway_node_id
          , pn.x
          , pn.y
          , pn.width
          , pn.height
          , pn.cellular_location
          , ot.name AS type
          , count (tp.gene_source_id) as gene_count
          , NULL AS default_structure
        FROM sres.pathwaynode pn
          INNER JOIN sres.ontologyterm ot ON pn.pathway_node_type_id = ot.ontology_term_id
          LEFT JOIN sres.enzymeclass ec ON pn.row_id = ec.enzyme_class_id
          LEFT JOIN PathwayNodeGene tp ON pn.pathway_node_id = tp.pathway_node_id
        WHERE ot.name = 'enzyme'
        GROUP BY pn.pathway_id
          , pn.display_label
          , ec.description
          , ec.ec_number
          , pn.pathway_node_id
          , pn.x
          , pn.y
          , pn.width
          , pn.height
          , pn.cellular_location
          , ot.name
        UNION ALL
        SELECT pn.pathway_id
          , pn.display_label
          , NULL AS url
          , coalesce(c.name, pn.display_label) AS name
          , c.chebi_accession AS node_identifier
          , pn.pathway_node_id AS pathway_node_id
          , pn.x
          , pn.y
          , pn.width
          , pn.height
          , pn.cellular_location
          , ot.name AS type
          , NULL AS gene_count
          , st.default_structure
        FROM sres.pathwaynode pn
          INNER JOIN sres.ontologyterm ot ON pn.pathway_node_type_id = ot.ontology_term_id
          LEFT JOIN chebi.compounds c ON pn.row_id = c.id
          LEFT JOIN (
            SELECT n.compound
              , s.structure AS default_structure
            FROM chebi.structures s
              , (SELECT id
                  , compound
                  FROM CompoundId
                  WHERE type IN ('same ID', 'child ID')
                  ) n
            WHERE n.id = 'CHEBI:' || s.compound_id
            AND s.type = 'mol'
            AND s.dimension = '2D'
            AND s.default_structure = 'Y'
          ) st ON c.chebi_accession = st.compound
        WHERE ot.name = 'molecular entity'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE ReactionsWithReversibility AS
        SELECT DISTINCT spr.pathway_relationship_id
        , tpr.is_reversible
        , tpr.reaction_source_id
        FROM sres.pathwayrelationship spr
        , apidb.pathwayreactionrel prr
        , PathwayReactions tpr
        WHERE prr.pathway_relationship_id = spr.pathway_relationship_id
        AND tpr.reaction_id = prr.pathway_reaction_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE EnzymeEdges AS
        SELECT DISTINCT nwt.pathway_id AS pathway_id
          , nwt.pathway_node_id AS e_id
          , nwt.type
          , i.associated_node_id AS m1_id
          , rri.is_reversible AS ir1
          , o.node_id AS m2_id
          , rro.is_reversible AS ir2
          , i.associated_node_id || '_' || o.node_id || '_' || rri.is_reversible || '_' || rro.is_reversible as io
        FROM sres.pathwayrelationship i
          , sres.pathwayrelationship o
          , NodesWithTypes nwt
          , ReactionsWithReversibility rri
          , ReactionsWithReversibility rro
        WHERE i.node_id = nwt.pathway_node_id
          AND o.associated_node_id = nwt.pathway_node_id
          AND i.pathway_relationship_id = rri.pathway_relationship_id
          AND o.pathway_relationship_id = rro.pathway_relationship_id
          AND nwt.type = 'enzyme'
          AND rri.is_reversible = rro.is_reversible
          AND rri.reaction_source_id = rro.reaction_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE ParentNodes AS
        WITH AllEnzymeEdges AS (
            SELECT string_agg(io, ',' ORDER BY io) AS all_edges
            , e_id
            , pathway_id
            FROM EnzymeEdges
            GROUP BY pathway_id
            , e_id
        )
        , pn as (
            SELECT pathway_id
            , all_edges
            , string_agg(e_id::varchar, '_' ORDER BY e_id) AS parent
            FROM AllEnzymeEdges
            GROUP BY pathway_id
            , all_edges
            HAVING COUNT (*) > 1
        )
        SELECT aee.e_id, pn.*
        FROM pn
        , AllEnzymeEdges aee
        WHERE aee.all_edges = pn.all_edges
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE NodesWithParents AS
        SELECT DISTINCT ee.e_id AS pathway_node_id
          , pn.parent
          , ee.type AS node_type
          , ee.pathway_id
        FROM EnzymeEdges ee
          , ParentNodes pn
        WHERE pn.pathway_id = ee.pathway_id
          AND ee.e_id = pn.e_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE EnzymeReactions AS
        SELECT DISTINCT pn.PATHWAY_NODE_ID node_id
          , pr.SOURCE_ID AS reaction_source_id
        FROM sres.pathwaynode pn
          , apidb.pathwayreaction pr
          , APIDB.PATHWAYREACTIONREL prr
          , SRES.PATHWAYRELATIONSHIP prel
          , sres.ontologyterm ot
        WHERE (prel.NODE_ID = pn.PATHWAY_NODE_ID OR prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID)
          AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
          AND pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
          AND ot.name = 'enzyme'
          AND pn.PATHWAY_NODE_TYPE_ID = ot.ONTOLOGY_TERM_ID
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE ParentsForEdges AS
        SELECT ee.e_id
            , ee.m1_id
            , ee.ir1
            , ee.m2_id
            , ee.ir2
            , np.parent
        FROM EnzymeEdges ee
            , NodesWithParents np
        WHERE ee.e_id = np.pathway_node_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE PathwayEdges&1 AS
        SELECT pa.source_id
          , pa.pathway_source
          , rel.*
        FROM (
          SELECT DISTINCT ee.pathway_id
            , coalesce(pe.parent, ee.e_id::varchar) AS source
            , ee.m1_id::varchar AS target
            , max(ee.ir1) AS is_reversible
          FROM EnzymeEdges ee
            LEFT JOIN ParentsForEdges pe ON ee.e_id = pe.e_id
          GROUP BY ee.pathway_id, ee.m1_id, coalesce(pe.parent, ee.e_id::varchar)
          UNION
          SELECT DISTINCT ee.pathway_id
            , ee.m2_id::varchar AS source
            , coalesce(pe.parent, ee.e_id::varchar) AS target
            , max(ee.ir2) AS is_reversible
          FROM EnzymeEdges ee
            LEFT JOIN ParentsForEdges pe ON ee.e_id = pe.e_id
          GROUP BY ee.pathway_id, ee.m2_id, coalesce(pe.parent, ee.e_id::varchar)
          UNION
          SELECT pn1.pathway_id
            , pr.node_id::varchar AS source
            , pr.associated_node_id::varchar AS target
            , pr.is_reversible
          FROM sres.pathwayrelationship pr
            , sres.pathwaynode pn1
            , sres.pathwaynode pn2
            , sres.ontologyterm ot1
            , sres.ontologyterm ot2
          WHERE pr.node_id = pn1.pathway_node_id
            AND pr.associated_node_id = pn2.pathway_node_id
            AND pn1.pathway_node_type_id = ot1.ontology_term_id
            AND pn2.pathway_node_type_id = ot2.ontology_term_id
            AND ot1.name != 'enzyme'
            AND ot2.name != 'enzyme'
        ) rel
        , PathwayAttributes pa
        WHERE pa.pathway_id = rel.pathway_id
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE TABLE PathwayNodes&1 AS
        SELECT pa.source_id
          , pa.pathway_source
          , pn.display_label
          , pn.x
          , pn.y
          , pn.width
          , pn.height
          , pn.cellular_location
          , coalesce(pn.url,
              CASE WHEN coalesce(type, nodes_with_parents.node_type) = 'enzyme' THEN
                  CASE 
                -- CHECK AND FIX
                --WHEN REGEXP_LIKE (display_label, '^\d+\.(\d|-)+\.(\d|-)+\.(\d|-)+$') THEN 'https://enzyme.expasy.org/EC/' || display_label
                  WHEN pa.pathway_source = 'KEGG' THEN 'https://www.genome.jp/dbget-bin/www_bget?rn:' || reaction_source_id
                  WHEN pa.pathway_source = 'MetaCyc' THEN 'https://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || reaction_source_id
                  WHEN pa.pathway_source = 'TrypanoCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || reaction_source_id
                  WHEN pa.pathway_source = 'LeishCyc' THEN 'http://vm-trypanocyc.toulouse.inra.fr/LEISH/new-image?tyrp=REACTION' || chr(38) || 'object=' || reaction_source_id
                  ELSE NULL END
              ELSE NULL END) AS url
          , pn.name
          , pn.node_identifier
          , nodes_with_parents.pathway_node_id AS id
          , nodes_with_parents.parent
          , reaction_source_id
          , coalesce(type, nodes_with_parents.node_type) AS node_type
          , pn.gene_count
          , pn.default_structure
        FROM
          ( SELECT e_id::varchar AS pathway_node_id
              , nwp.parent
              , type AS node_type
              , ee.pathway_id
              , er.reaction_source_id
            FROM EnzymeEdges ee
              INNER JOIN EnzymeReactions er ON er.node_id = ee.e_id
              LEFT JOIN NodesWithParents nwp ON ee.e_id = nwp.pathway_node_id
            UNION
            SELECT nwp.parent
              , NULL
              , 'nodeOfNodes'
              , pathway_id
              , NULL
            FROM NodesWithParents nwp
            UNION
            SELECT nwt.pathway_node_id::varchar AS pathway_node_id
              , NULL AS parent
              , nwt.type
              , nwt.pathway_id
              , NULL
            FROM NodesWithTypes nwt
            WHERE nwt.type != 'enzyme'
          ) nodes_with_parents
          INNER JOIN PathwayAttributes pa ON nodes_with_parents.pathway_id = pa.pathway_id
          LEFT JOIN NodesWithTypes pn ON nodes_with_parents.pathway_node_id = pn.pathway_node_id::varchar
      ]]>
    </sql>
    <!--TODO index -->
  </tuningTable>

  <!--MetabolicPathwaySres table - simplify model query to improve download performance -->
  <tuningTable name="PathwaysGeneTable">
    <comment>Used by pathway table on gene pages</comment>
    <internalDependency name="TranscriptPathway"/>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwaysGeneTable&1 AS
        SELECT * FROM (
          SELECT DISTINCT gene_source_id
            , project_id
            , pathway_source_id
            , pathway_name
            , count(reaction_source_id) as reactions
            , enzyme
            , expasy_url
            , pathway_source
            , exact_match
          FROM (
              SELECT DISTINCT tp.gene_source_id
                , tp.project_id
                , tp.pathway_source_id
                , tp.pathway_name
                , pr.reaction_source_id
                , pr.enzyme
                , pr.expasy_url
                , tp.pathway_source
                , CASE max(tp.exact_match) WHEN 1 THEN 'Yes' WHEN 0 THEN 'No' END AS exact_match
              FROM TranscriptPathway tp
                , PathwayAttributes pa
                , PathwayCompounds pc
                , PathwayReactions pr
              WHERE tp.pathway_id = pa.pathway_id
                AND pc.pathway_id = pa.pathway_id
                AND pr.reaction_id = pc.reaction_id
                AND pr.ext_db_name = pc.ext_db_name
                AND tp.ec_number_pathway = pr.enzyme
                AND tp.wildcard_count_gene <= tp.wildcard_count_pathway
                AND pr.enzyme != '-.-.-.-'
              GROUP BY tp.gene_source_id, tp.project_id, tp.pathway_name, tp.pathway_source_id, pr.reaction_source_id, pr.enzyme, pr.expasy_url, tp.pathway_source
            ) t
          GROUP BY gene_source_id, project_id, pathway_source_id, pathway_name, enzyme, expasy_url, pathway_source, exact_match
        ) t2
        ORDER BY pathway_source, lower(pathway_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index pgt_ix&1 on PathwaysGeneTable&1
               (gene_source_id, project_id, pathway_source_id, pathway_name,
                reactions, enzyme, expasy_url, pathway_source, exact_match)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundTypeAheads">
    <comment> for use in GenesByReactionCompounds question </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <sql>
      <![CDATA[
        CREATE TABLE CompoundTypeAheads&1 AS
        SELECT ca.source_id AS compound_id,
              ca.source_id  || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
        UNION
        SELECT ca.source_id AS compound_id,
              pc.compound_source_id || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
      one experiment for one gene. Used for mass spec queries in the model,
      GBrowse, and PBrowse, and also in the creation of the MSTranscriptSummary
      tuning table.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.MassSpecPeptide"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE MSPeptideSummary&1 as
        SELECT pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER
        FROM (
                SELECT msp.peptide_sequence,
                       ga.source_id,
                       ga.gene_source_id,
                       ga.project_id,
                       dsp.display_name as experiment,
                       d.name as external_database_name,
                       sum(msp.spectrum_count) as spectrum_count,
                       ga.aa_sequence_id,
                       msp.peptide_start as aa_start_min,
                       msp.peptide_end  as aa_end_max,
                       msp.sample
                FROM apidb.massspecpeptide msp
                  INNER JOIN sres.externaldatabaserelease r ON msp.external_database_release_id = r.external_database_release_id
                  INNER JOIN sres.externaldatabase d ON r.external_database_id = d.external_database_id
                  LEFT JOIN transcriptattributes ga ON msp.protein_source_id = ga.protein_source_id
                  LEFT JOIN datasetnametaxon dsnt ON d.name = dsnt.name
                  LEFT JOIN datasetpresenter dsp ON dsnt.dataset_presenter_id = dsp.dataset_presenter_id
                GROUP BY d.name, ga.source_id, ga.gene_source_id, ga.project_id, dsp.display_name,
                         msp.protein_source_id, ga.aa_sequence_id, msp.peptide_sequence,
                         msp.spectrum_count, msp.peptide_start, msp.peptide_end, msp.external_database_release_id, msp.sample
          ) pep
          ,sampledisplayinfo sdi
        WHERE sdi.dataset_name = pep.external_database_name 
         AND pep.sample = replace (sdi.sample ,'.tab', '')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index sample_ix&1 on MSPeptideSummary&1 (sample)

      ]]>
    </sql>
<!--    <sql>-->
<!--      <![CDATA[-->
<!--        create index mspep_ix&1-->
<!--          on MSPeptideSummary&1-->
<!--               (aa_sequence_id, external_database_name, peptide_aa_feature_id,-->
<!--                aa_start_min, aa_end_max, sample, source_id, spectrum_count, experiment,-->
<!--                sample_display_name, html_color, peptide_sequence)-->
<!--        -->
<!--      ]]>-->
<!--    </sql>-->
  </tuningTable>


  <tuningTable name="AnnotatedGenomeSummary">
    <comment> Stores summary information from annotated genomes to facilitate overview section of gene page
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE AnnotatedGenomeSummary&1 AS
        SELECT ga.external_db_name as external_db_name, ga.organism, ga.taxon_id,
               o.is_reference_strain,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'isCurated') as is_curated_genome,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'updatedAnnotationText') as updated_link_text,
               (SELECT value
                FROM DatasetProperty
                WHERE dataset_presenter_id = dsp.dataset_presenter_id
                  AND property = 'specialLinkDisplayText') as special_link_text,
               (SELECT rel.id_url
                FROM DatasetProperty p,  sres.ExternalDatabase db, sres.ExternalDatabaseRelease rel
                WHERE p.dataset_presenter_id = dsp.dataset_presenter_id
                  AND db.name = cast(substr(p.value, 1, 4000) as varchar(4000))
                  AND db.external_database_id = rel.external_database_id
                  AND p.property = 'specialLinkExternalDbName') as link_url,
               dsp.release_policy
        FROM apidb.Organism o,
             (SELECT distinct external_db_name, taxon_id, organism FROM GeneAttributes) ga
             LEFT JOIN DatasetPresenter dsp ON dsp.name = ga.external_db_name
        WHERE ga.external_db_name like '%_primary_genome_RSRC'
          AND o.taxon_id = ga.taxon_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSTranscriptSummary">
    <comment> Mass-spec experiment results for a transcript. Used in the model for queries
      related to transcripts.
    </comment>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
        CREATE TABLE MSTranscriptSummary&1 AS
        SELECT msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample,
               msps.sample_display_name, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
        FROM mspeptidesummary msps
        WHERE source_id is not null
        GROUP BY msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msgs_ix&1 on MSTranscriptSummary&1 (source_id, gene_source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSModifiedPeptideSummary">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
      and PBrowse.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="apidb.ModifiedMassSpecPeptide"/>
    <sql>
      <![CDATA[
        CREATE TABLE MSModifiedPeptideSummary&1 as
        SELECT pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER
        FROM (
                SELECT ga.source_id,
                       ga.gene_source_id,
                       ga.project_id,
                       ga.aa_sequence_id,
                       dsp.display_name as experiment,
                       d.name as external_database_name,
                       msp.sample,
                       sum(msp.spectrum_count) as spectrum_count,
                       msp.residue,
                       msp.residue_protein_loc  AS residue_location,
                       msp.modification_type,
                       msp.peptide_sequence,
                       msp.peptide_start as aa_start_min,
                       msp.peptide_end  as aa_end_max
                FROM apidb.ModifiedMassSpecPeptide msp
                  INNER JOIN sres.externaldatabaserelease r ON msp.external_database_release_id = r.external_database_release_id
                  INNER JOIN sres.externaldatabase d ON r.external_database_id = d.external_database_id
                  LEFT JOIN transcriptattributes ga ON msp.protein_source_id = ga.protein_source_id
                  LEFT JOIN datasetnametaxon dsnt ON d.name = dsnt.name
                  LEFT JOIN datasetpresenter dsp ON dsnt.dataset_presenter_id = dsp.dataset_presenter_id
                GROUP BY d.name, ga.source_id, ga.gene_source_id, ga.project_id, dsp.display_name,
                         msp.protein_source_id, ga.aa_sequence_id, msp.peptide_sequence,
                         msp.spectrum_count, msp.peptide_start, msp.peptide_end, msp.external_database_release_id, 
                         msp.sample, msp.modification_type, msp.residue, msp.residue_protein_loc
          ) pep
          ,sampledisplayinfo sdi
        WHERE sdi.dataset_name = pep.external_database_name 
         AND pep.sample = replace (sdi.sample ,'.tab', '')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        ALTER TABLE MSModifiedPeptideSummary&1 ALTER COLUMN modification_type DROP NOT null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msmodps_tx_ix&1 on MSModifiedPeptideSummary&1 (source_id, gene_source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msmodps_gn_ix&1 on MSModifiedPeptideSummary&1 (gene_source_id, source_id)

      ]]>
    </sql>
  </tuningTable>


<!--  <tuningTable name="Ssgcid" alwaysUpdate="true">-->
  <tuningTable name="Ssgcid">
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
      populated from their web service. Used in the gene record.
    </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


<!--  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true">-->
  <tuningTable name="SampleDisplayInfo" >
    <comment> Used by the model and GBrowse, as well as an input in the creation of
      the tuning tables like MSModifiedPeptideSummary and MSPeptideSummary.
    </comment>
    <program commandLine="buildSampleDisplayInfoTT"/>
  </tuningTable>


<!--  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true">-->
  <tuningTable name="ProfileSetDisplayInfo">
    <comment> Used by the model when writing profile data
    </comment>
    <program commandLine="buildProfileSetDisplayInfoTT"/>
  </tuningTable>


<!--  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">-->
  <tuningTable name="GbrowseTracksOrganism">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
      for it. Used by the gene record.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Organism"/>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>


  <tuningTable name="SpliceSiteTranscripts">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
      for it. Used by the gene record.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.SpliceSiteGenes"/>
    <externalDependency name="apidb.PolyAGenes"/>
    <program commandLine="buildSpliceSitesTT"/>
  </tuningTable>

  <tuningTable name="GenomicsInternalHyperlink" alwaysUpdate="true">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
      each dataset gets one such row.
      Used in dataset record queries.
    </comment>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="OrganismAttributes"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenomicsInternalHyperlink&1 AS
        WITH rnaseqgenes AS (
          SELECT p.DATASET_NAME
                , p.source_id as gene_source_id
                , ga.sequence_id as sequence_id
                , row_number() over (partition by p.dataset_name
                                    order by p.max_value, p.source_id, ga.sequence_id) as rn
          FROM profile p, geneattributes ga
          WHERE dataset_type = 'transcript_expression' and dataset_subtype =  'rnaseq'
            AND p.source_id = ga.source_id
        ), proteomicsgenes as (
          SELECT ga.gene_source_id,
                 ga.SEQUENCE_ID,
                 ga.protein_source_id,
                 d.name,
                 row_number() over(partition by d.name
                                   order by mss.aa_seq_percent_covered desc, ga.gene_source_id) as rn
          FROM apidb.MassSpecSummary mss, TranscriptAttributes ga,
               sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
          WHERE mss.external_database_release_id = r.external_database_release_id
          AND r.external_database_id = d.external_database_id
          AND mss.aa_sequence_id = ga.aa_sequence_id
        ), sequences as (
          select sa.source_id
               , sa.taxon_id
               , row_number() over(partition by sa.taxon_id
                                   order by sa.chromosome_order_num, sa.length desc) as rn
          from GenomicSeqAttributes sa
          where sa.is_top_level = 1
        ), macros as (
          SELECT dnt.dataset_presenter_id
               , o.name_for_filenames
               , o.project_id
               , o.public_abbrev as org_abbrev
               , o.source_id as org_pk
               , dnt.name
               , dsp.name as dataset_presenter_name
               , sa.source_id as sequence_source_id
               , pg.sequence_id as p_sequence_source_id
               , pg.gene_source_id as p_gene_id
               , pg.protein_source_id as p_protein_id
               , rg.sequence_id as r_sequence_source_id
               , rg.gene_source_id as r_gene_id
          FROM organismattributes o
             INNER JOIN datasetnametaxon dnt ON o.component_taxon_id = dnt.taxon_id
             INNER JOIN datasetpresenter dsp ON dnt.dataset_presenter_id = dsp.dataset_presenter_id
             INNER JOIN sequences sa ON dnt.taxon_id = sa.taxon_id
             LEFT JOIN (select * from proteomicsgenes where rn = 1) pg ON dnt.name = pg.name
             LEFT JOIN (select * from rnaseqgenes where rn = 1) rg ON dnt.name = rg.dataset_name
          WHERE sa.rn = 1
        )
        SELECT DISTINCT
             h.dataset_link_id, h.dataset_presenter_id, h.description
             , replace(h.text, 'DEFAULT_PROJECT', macros.project_id) as text
             , replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(h.url
                                                    , 'DEFAULT_PROJECT', macros.project_id)
                                                    , 'ORGANISM_FILE_NAME', macros.name_for_filenames)
                                                    , 'DEFAULT_SEQUENCE', macros.sequence_source_id)
                                                    , 'DEFAULT_ORG_ABBREV', macros.org_abbrev)
                                                    , 'DEFAULT_PROTEOMICS_SEQUENCE', macros.p_sequence_source_id)
                                                    , 'DEFAULT_PROTEOMICS_GENE', macros.p_gene_id)
                                                    , 'DEFAULT_PROTEOMICS_PROTEIN', macros.p_protein_id)
                                                    , 'DEFAULT_RNASEQ_GENE', macros.r_gene_id)
                                                    , 'DEFAULT_RNASEQ_SEQUENCE', macros.r_sequence_source_id)
                                                    , 'DEFAULT_DATASET_NAME', macros.name)
                                                    , 'DEFAULT_DATASET_PRESENTER_NAME', macros.dataset_presenter_name)
                                                    , 'DEFAULT_ORGANISM_PK', macros.org_pk) as url
             , h.isPublication
        FROM datasetpresenter dsp, macros, datasethyperlink h
        WHERE macros.dataset_presenter_id = dsp.dataset_presenter_id
          AND h.dataset_presenter_id = macros.dataset_presenter_id
          AND h.url like '/%'
      ]]>
    </sql>
  </tuningTable>

  <!--
    <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
      <comment> Stores changes in gene annotation. Used by the model for gene ID and
           table queries.
        </comment>
      <program commandLine="buildTrackOldAnnotationTT"/>
    </tuningTable>
  -->

  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProteomicsCitation&1 AS
        WITH pubs AS (
          SELECT name, id, contact_email,
                string_agg(publication, ',' order by publication) as pmids
          FROM (
            SELECT ds.name as name, ds.dataset_presenter_id as id,
                   c.email as contact_email, p.pmid as publication
            FROM DatasetPresenter ds, DatasetContact c, DatasetPublication p
            WHERE ds.dataset_presenter_id = c.dataset_presenter_id
              AND ds.dataset_presenter_id = p.dataset_presenter_id
              AND c.is_primary_contact = true
              AND ds.type = 'protein_expression'
              AND ds.subtype is null
          ) t
          GROUP BY name, id, contact_email
        ),
        samples AS (
          SELECT name, id, string_agg(sample_i, chr(10) order by sample) as sample_table
          FROM (
            SELECT distinct ds.name as name,
                             ds.dataset_presenter_id as id, sample,
                             '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
            FROM MSPeptideSummary mps, DatasetPresenter ds
            -- consider using the tuning table ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
            WHERE (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern)
          ) t
          group by name, id
        )
        SELECT name,
               substr(description, 4000, 1) || ' Primary Contact Email: '|| coalesce(email, 'unavailable')
               || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
               || sample_table || chr(10) ||
               ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
        FROM (
          SELECT ds.name as name, ds.summary as description, pubs.contact_email as email,
                 pubs.pmids as publications, samples.sample_table as sample_table
          FROM DatasetPresenter ds, pubs, samples
          WHERE ds.dataset_presenter_id = pubs.id
            AND ds.dataset_presenter_id = samples.id
        ) t
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EqtlSpan">
    <externalDependency name="dots.ChromosomeElementFeature"/>
    <externalDependency name="apidb.NaFeatureHaploblock"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.NaLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table eqtlSpan&1 as
        SELECT gene_source_id, project_id, haplotype_block_name as hapblock_id, sequence_id,
               start_min, end_max, start_max, end_min,
               max(score) as lod_score, organism
        FROM (SELECT ga.gene_source_id, ga.project_id, gls.haplotype_block_name,
                     ens.source_id as sequence_id, nl.start_min, nl.end_max, nl.start_max, nl.end_min,
                     gls.lod_score_mant * power(10::double precision, gls.lod_score_exp) as score,
                     replace (ga.organism, ' ', '+') as organism
              FROM dots.ChromosomeElementFeature cef, apidb.NAFeatureHaploblock gls,
                   dots.ExternalNaSequence ens, dots.NaLocation nl, TranscriptAttributes ga
              WHERE gls.na_feature_id = ga.gene_na_feature_id
                AND cef.name = gls.haplotype_block_name
                AND nl.na_feature_id = cef.na_feature_id
                AND cef.na_sequence_id = ens.na_sequence_id
                AND (gls.lod_score_mant * power(10::double precision, gls.lod_score_exp)) >= 1.5
        ) t
        GROUP BY gene_source_id, project_id, sequence_id, haplotype_block_name,
                 start_min, end_max, start_max, end_min, organism
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index eqtlSpan_ix&1
        on eqtlSpan&1 (gene_source_id, project_id, hapblock_id, sequence_id, start_min, end_max, start_max, end_min, organism, lod_score)

      ]]>
    </sql>
  </tuningTable>


<!--  <tuningTable name="Pubmed" alwaysUpdate="true">-->
  <tuningTable name="Pubmed">
    <!-- PubMed info
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <program commandLine="buildPubmedTT"/>
  </tuningTable>


  <tuningTable name="GenePubmed">
    <!-- PubMed records mapped to genes
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="Pubmed"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <sql>
      <![CDATA[
        CREATE TABLE GenePubmed&1 AS
        WITH feat_pm as (
          SELECT dbref_subset.na_feature_id,
                 pm.pubmed_id, pm.doi, pm.title,
                 substr(pm.authors, 2000, 1) authors
          FROM Pubmed pm,
               (SELECT dbna.na_feature_id, db.primary_identifier
                FROM dots.DbRefNaFeature dbna,
                     sres.DbRef db
                WHERE db.db_ref_id = dbna.db_ref_id
                 and db.external_database_release_id
                     in (  SELECT external_database_release_id
                           FROM ExternalDbDatasetPresenter
                           WHERE lower(dataset_presenter_display_name) like '%pubmed%'
                         UNION
                           SELECT edr.external_database_release_id
                           FROM sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
                           WHERE ed.external_database_id = edr.external_database_id
                             AND lower(ed.name) like '%pubmed%'
                        )
               ) dbref_subset
          WHERE dbref_subset.primary_identifier = pm.pubmed_id::varchar
        )
        SELECT ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors
        FROM TranscriptAttributes ta, feat_pm
        WHERE ta.na_feature_id = feat_pm.na_feature_id
        UNION
        SELECT ta.source_id, ta.gene_source_id, ta.project_id, pubmed_id, doi, title, authors
        FROM TranscriptAttributes ta, feat_pm
        WHERE ta.gene_na_feature_id = feat_pm.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_gene_idx&1
          on GenePubmed&1 (gene_source_id, source_id, project_id, pubmed_id, doi, title, authors)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_tx_idx&1
          on GenePubmed&1 (source_id, gene_source_id, project_id, pubmed_id, doi, title, authors)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Profile">
    <!-- One profile per gene per dataset. Used for graphs -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="CompoundAttributes"/>
    <externalDependency name="apidb.OntologyTermResult"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="apidb.NaFeatureMetacycle"/>
    <externalDependency name="apidb.LopitResults"/>
    <externalDependency name="apidb.EigenGeneWgcnaResults"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <sql>
      <![CDATA[
       CREATE TABLE Profile&1 (
         DATASET_NAME	    VARCHAR(200),
         DATASET_TYPE	    VARCHAR(50),
         DATASET_SUBTYPE    VARCHAR(50),
         PROFILE_TYPE	    VARCHAR(30),
         NODE_TYPE	    VARCHAR(100),
         SOURCE_ID	        VARCHAR(500),
         PROFILE_STUDY_ID	NUMERIC(7),
         PROFILE_SET_NAME	VARCHAR(400),
         PROFILE_SET_SUFFIX	VARCHAR(50),
         PROFILE_AS_STRING	VARCHAR(4000),
         MAX_VALUE	        NUMERIC,
         MIN_VALUE	        NUMERIC,
         MAX_TIMEPOINT	    VARCHAR(200),
         MIN_TIMEPOINT	    VARCHAR(200)
       )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        DO $$
        DECLARE
          ctrows NUMERIC := 0;
          commit_after NUMERIC := 10000;
          pf_rows record;
        BEGIN
          FOR pf_rows IN (
            SELECT
               ds.name as dataset_name, ds.type as dataset_type,
               ds.subtype as dataset_subtype, profile.profile_type, profile.node_type,
               profile.source_id, profile.node_set_id as profile_study_id,
               ps.name as profile_set_name,
               cast(case
                      when regexp_replace(ps.name, '\[.+\]', '') like '% - %'
                        then regexp_replace(regexp_replace(ps.name, ' *\[.+\]', ''), '.+ - ', '')
                      -- special cases for legacy datasets
                      when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %'
                        then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                      when regexp_replace(ps.name, '\[.+\]', '') like 'T.brucei paired end RNA-Seqdata from Horn%'
                        then regexp_replace(
                                 regexp_replace(
                                     regexp_replace(
                                         regexp_replace(
                                             regexp_replace(ps.name, '\[.+ nonunique\]', ''),
                                                        '\[.+ unique\]', ' - unique'),
                                                    '\[.+\]', ''),
                                                'aligned with cds coordinates ', 'cds coordinates'),
                                            'T.brucei paired end RNA-Seqdata from Horn ', '')
                      else null
                    end as varchar(50)
                   ) as profile_set_suffix,
               CASE WHEN replace(profile.profile_as_string, 'NA' || CHR(9), '') = 'NA' THEN null ELSE profile.profile_as_string END as profile_as_string,
               profile.max_value, profile.min_value,
               profile.max_timepoint, profile.min_timepoint
            FROM apidb.DataSource ds, sres.ExternalDatabase d,
              sres.ExternalDatabaseRelease r, study.NodeSet ps,
              (
                  -- gene profiles
                  SELECT gene_profile.node_set_id, ga.source_id, gene_profile.profile_type, gene_profile.node_type,
                         gene_profile.profile_as_string, gene_profile.max_value, gene_profile.min_value,
                         gene_profile.max_timepoint, gene_profile.min_timepoint
                  FROM GeneAttributes ga,
                    (
                        SELECT * FROM (
                          WITH result AS (
                            SELECT na_feature_id, protocol_app_node_id, max(value) as value
                            FROM results.NAFEATUREHOSTRESPONSE
                            GROUP BY na_feature_id, protocol_app_node_id
                          ), min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.value) over w1 as max_value,
                                first_value(result.value) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            from study.protocolappnode pan, study.NodeNodeSet sl, study.NodeSet s, result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.value ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.PROTOCOLAPPNODE pan, study.NodeNodeSet sl, study.NodeSet s, min_max, result
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t1
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.mean_phenotype) over w1 as max_value,
                              first_value(result.mean_phenotype) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.PROTOCOLAPPNODE pan, study.NodeNodeSet sl, study.NodeSet s, apidb.CrisprPhenotype result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                                PARTITION BY sl.node_set_id, result.na_feature_id
                                ORDER BY result.mean_phenotype ASC
                                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.mean_phenotype::numeric, 2)::varchar,'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.CrisprPhenotype result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND result.na_feature_id = min_max.na_feature_id
                            AND sl.node_set_id = min_max.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t2
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.score) over w1 as max_value,
                              first_value(result.score) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.PROTOCOLAPPNODE pan, study.NodeNodeSet sl, study.NodeSet s, apidb.PhenotypeScore result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.score ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
                            string_agg(coalesce(round(result.score::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                            min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.PhenotypeScore result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t3
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.relative_growth_rate) over w1 as max_value,
                              first_value(result.relative_growth_rate) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.PhenotypeGrowthRate result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.relative_growth_rate ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.relative_growth_rate::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.PhenotypeGrowthRate result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t4
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.value) over w1 as max_value,
                              first_value(result.value) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.value ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t5
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.percentile_channel1) over w1 as max_value,
                              first_value(result.percentile_channel1) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.percentile_channel1 ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'channel1_percentiles' as profile_type, s.node_type,
                                string_agg(coalesce(round(result.percentile_channel1::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                                min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t6
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                              last_value(result.percentile_channel2) over w1 as max_value,
                              first_value(result.percentile_channel2) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.percentile_channel2 ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'channel2_percentiles' as profile_type, s.node_type,
                                string_agg(coalesce(round(result.percentile_channel2::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                                min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t7
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.standard_error) over w1 as max_value,
                                first_value(result.standard_error) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.standard_error ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'standard_error' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.standard_error::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, results.NaFeatureExpression result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t8
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.pvalue) over w1 as max_value,
                                first_value(result.pvalue) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.pvalue ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'pvalue' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.pvalue::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t9
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.amplitude) over w1 as max_value,
                                first_value(result.amplitude) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.PROTOCOLAPPNODE pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.amplitude ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'amplitude' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.amplitude::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t10
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.period) over w1 as max_value,
                                first_value(result.period) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.period ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'period' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.period::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.NaFeatureMetacycle result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t11
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.probability_mean) over w1 as max_value,
                                first_value(result.probability_mean) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.probability_mean ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'probability_mean' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.probability_mean::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t12
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.sd) over w1 as max_value,
                                first_value(result.sd) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.sd ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'sd' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.sd::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t13
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.lower_CI) over w1 as max_value,
                                first_value(result.lower_CI) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.lower_CI ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'lower_CI' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.lower_CI::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t14
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.na_feature_id,
                                last_value(result.upper_CI) over w1 as max_value,
                                first_value(result.upper_CI) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.na_feature_id
                              ORDER BY result.upper_CI ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.na_feature_id, 'upper_CI' as profile_type, s.node_type,
                              string_agg(coalesce(round(result.upper_CI::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.LopitResults result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.na_feature_id = result.na_feature_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t15
-- TO FIX
--                      UNION ALL
--                        SELECT * FROM (
--                          WITH min_max AS (
--                              SELECT DISTINCT sl.node_set_id, result.na_feature_id,
--                                  null as max_value,
--                                  null as min_value,
--                                  last_value(pan.name) over w1 as max_timepoint,
--                                  first_value(pan.name) over w1 as min_timepoint
--                              FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.HaplotypeResult result
--                              WHERE result.protocol_app_node_id = sl.protocol_app_node_id
--                                AND result.protocol_app_node_id = pan.protocol_app_node_id
--                                AND sl.node_set_id = s.node_set_id
--                              WINDOW w1 AS (
--                                PARTITION BY sl.node_set_id, result.na_feature_id
--                                ORDER BY result.value ASC
--                                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
--                              )
--                          )
--                          SELECT sl.node_set_id, result.na_feature_id, 'values' as profile_type, s.node_type,
--                              string_agg(coalesce(result.value, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
--                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
--                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.HaplotypeResult result, min_max
--                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
--                            AND result.protocol_app_node_id = pan.protocol_app_node_id
--                            AND sl.node_set_id = s.node_set_id
--                            AND min_max.na_feature_id = result.na_feature_id
--                            AND min_max.node_set_id = sl.node_set_id
--                          GROUP BY sl.node_set_id, result.na_feature_id, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
--                        ) t16
                    ) gene_profile
                  WHERE ga.na_feature_id = gene_profile.na_feature_id
                UNION ALL
                  -- compound profiles
                  SELECT compound_profile.node_set_id,
                     case
                       WHEN compound_profile.isotopomer IS NOT NULL
                          THEN ca.source_id || '|' || compound_profile.isotopomer
                       WHEN compound_profile.mass IS NOT NULL
                          THEN ca.source_id || '|' || compound_profile.mass || '|' || compound_profile.retention_time
                       ELSE ca.source_id
                     END as source_id,
                     compound_profile.profile_type, compound_profile.node_type,
                     compound_profile.profile_as_string, compound_profile.max_value, compound_profile.min_value,
                     compound_profile.max_timepoint, compound_profile.min_timepoint
                  FROM CompoundAttributes ca,
                    (
                        SELECT * FROM (
                          WITH result AS (
                            SELECT max(value) as value, compound_id, protocol_app_node_id, isotopomer
                            FROM results.CompoundMassSpec
                            GROUP BY compound_id, protocol_app_node_id, isotopomer
                          ) , min_max AS (
                            SELECT DISTINCT sl.node_set_id, result.compound_id, result.isotopomer,
                                last_value(result.value) over w1 as max_value,
                                first_value(result.value) over w1 as min_value,
                                last_value(pan.name) over w1 as max_timepoint,
                                first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, result
                            WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                              AND result.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, result.compound_id, result.isotopomer
                              ORDER BY result.value ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, result.compound_id, result.isotopomer, 'values' as profile_type, s.node_type,
                              NULL::numeric as compound_peaks_id, NULL::numeric as mass, NULL::numeric as retention_time,
                              string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                              min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, result, min_max
                          WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                            AND result.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND min_max.compound_id = result.compound_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, result.compound_id, result.isotopomer, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t1
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, cpc.compound_id,
                              last_value(cmsr.value) over w1 as max_value,
                              first_value(cmsr.value) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                              apidb.CompoundMassSpecResult cmsr, apidb.Compoundpeaks cp,
                              apidb.CompoundPeaksChebi cpc
                            WHERE cmsr.protocol_app_node_id = sl.protocol_app_node_id
                              AND cmsr.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                              AND cp.compound_peaks_id = cmsr.compound_peaks_id
                              AND cpc.compound_peaks_id = cp.compound_peaks_id
                              AND pan.name like '%mean%'
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time
                              ORDER BY cmsr.value ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, cpc.compound_id, cpc.isotopomer, 'values' as profile_type, s.node_type,
                            cpc.compound_peaks_id, cp.mass, cp.retention_time,
                            string_agg(coalesce(round(cmsr.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                            min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                            apidb.CompoundMassSpecResult cmsr, apidb.Compoundpeaks cp,
                            apidb.CompoundPeaksChebi cpc, min_max
                          WHERE cmsr.protocol_app_node_id = sl.protocol_app_node_id
                            AND cmsr.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND cp.compound_peaks_id = cmsr.compound_peaks_id
                            AND cpc.compound_peaks_id = cp.compound_peaks_id
                            AND pan.name like '%mean%'
                            AND min_max.compound_id = cpc.compound_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t2
                      UNION ALL
                        SELECT * FROM (
                          WITH min_max AS (
                            SELECT DISTINCT sl.node_set_id, cpc.compound_id,
                              last_value(cmsr.percentile) over w1 as max_value,
                              first_value(cmsr.percentile) over w1 as min_value,
                              last_value(pan.name) over w1 as max_timepoint,
                              first_value(pan.name) over w1 as min_timepoint
                            FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                              apidb.CompoundMassSpecResult cmsr, apidb.Compoundpeaks cp,
                              apidb.CompoundPeaksChebi cpc
                            WHERE cmsr.protocol_app_node_id = sl.protocol_app_node_id
                              AND cmsr.protocol_app_node_id = pan.protocol_app_node_id
                              AND sl.node_set_id = s.node_set_id
                              AND cp.compound_peaks_id = cmsr.compound_peaks_id
                              AND cpc.compound_peaks_id = cp.compound_peaks_id
                              AND pan.name like '%mean%'
                            WINDOW w1 AS (
                              PARTITION BY sl.node_set_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time
                              ORDER BY cmsr.percentile ASC
                              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                            )
                          )
                          SELECT sl.node_set_id, cpc.compound_id, cpc.isotopomer, 'percentiles' as profile_type, s.node_type,
                            cpc.compound_peaks_id, cp.mass, cp.retention_time,
                            string_agg(coalesce(round(cmsr.percentile::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                            min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                          FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                            apidb.CompoundMassSpecResult cmsr, apidb.Compoundpeaks cp,
                            apidb.CompoundPeaksChebi cpc, min_max
                          WHERE cmsr.protocol_app_node_id = sl.protocol_app_node_id
                            AND cmsr.protocol_app_node_id = pan.protocol_app_node_id
                            AND sl.node_set_id = s.node_set_id
                            AND cp.compound_peaks_id = cmsr.compound_peaks_id
                            AND cpc.compound_peaks_id = cp.compound_peaks_id
                            AND pan.name like '%mean%'
                            AND min_max.compound_id = cpc.compound_id
                            AND min_max.node_set_id = sl.node_set_id
                          GROUP BY sl.node_set_id, cpc.compound_id, cpc.isotopomer, cpc.compound_peaks_id, cp.mass, cp.retention_time, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                        ) t3
                    ) compound_profile
                  WHERE ca.id = compound_profile.compound_id
                UNION ALL
                  -- OntologyTermResult
                  SELECT * FROM (
                    WITH min_max AS (
                      SELECT DISTINCT sl.node_set_id, ot.name,
                        last_value(otr.value) over w1 as max_value,
                        first_value(otr.value) over w1 as min_value,
                        last_value(pan.name) over w1 as max_timepoint,
                        first_value(pan.name) over w1 as min_timepoint
                      FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                        apidb.OntologyTermResult otr, sres.OntologyTerm ot
                      WHERE ot.ontology_term_id = otr.ontology_term_id
                        AND otr.protocol_app_node_id = sl.protocol_app_node_id
                        AND otr.protocol_app_node_id = pan.protocol_app_node_id
                        AND sl.node_set_id = s.node_set_id
                      WINDOW w1 AS (
                        PARTITION BY sl.node_set_id, ot.name
                        ORDER BY otr.value ASC
                        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                      )
                    )
                    SELECT sl.node_set_id, ot.name as source_id, 'value' as profile_type, s.node_type,
                      string_agg(coalesce(round(otr.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                      min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                    FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s,
                      apidb.OntologyTermResult otr, sres.OntologyTerm ot, min_max
                    WHERE ot.ontology_term_id = otr.ontology_term_id
                      AND otr.protocol_app_node_id = sl.protocol_app_node_id
                      AND otr.protocol_app_node_id = pan.protocol_app_node_id
                      AND sl.node_set_id = s.node_set_id
                      AND min_max.name = ot.name
                      AND min_max.node_set_id = sl.node_set_id
                    GROUP BY sl.node_set_id, ot.name, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                  ) t1
                UNION ALL
                  -- SubjectResult
                  SELECT * FROM (
                    WITH min_max AS (
                      SELECT DISTINCT sl.node_set_id, result.subject,
                        last_value(result.value) over w1 as max_value,
                        first_value(result.value) over w1 as min_value,
                        last_value(pan.name) over w1 as max_timepoint,
                        first_value(pan.name) over w1 as min_timepoint
                      FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.SubjectResult result
                      WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                        AND result.protocol_app_node_id = pan.protocol_app_node_id
                        AND sl.node_set_id = s.node_set_id
                      WINDOW w1 AS (
                        PARTITION BY sl.node_set_id, result.subject
                        ORDER BY result.value ASC
                        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                      )
                    )
                    SELECT sl.node_set_id, result.subject as source_id, 'values' as profile_type, s.node_type,
                      string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                      min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                    FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, min_max, apidb.SubjectResult result
                    WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                      AND result.protocol_app_node_id = pan.protocol_app_node_id
                      AND sl.node_set_id = s.node_set_id
                      AND min_max.subject = result.subject
                      AND min_max.node_set_id = sl.node_set_id
                    GROUP BY sl.node_set_id, result.subject, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                  ) t2
                UNION ALL
                  -- wgcna eigengene results
                  SELECT * FROM (
                    WITH min_max AS (
                      SELECT DISTINCT sl.node_set_id, result.module_name,
                        last_value(result.value) over w1 as max_value,
                        first_value(result.value) over w1 as min_value,
                        last_value(pan.name) over w1 as max_timepoint,
                        first_value(pan.name) over w1 as min_timepoint
                      FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, apidb.EigenGeneWgcnaResults result
                      WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                        AND result.protocol_app_node_id = pan.protocol_app_node_id
                        AND sl.node_set_id = s.node_set_id
                      WINDOW w1 AS (
                        PARTITION BY sl.node_set_id, result.module_name
                        ORDER BY result.value ASC
                        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                      )
                    )
                    SELECT sl.node_set_id, result.module_name as source_id, 'values' as profile_type, s.node_type,
                      string_agg(coalesce(round(result.value::numeric, 2)::varchar, 'NA'), chr(9) order by pan.node_order_num) as profile_as_string,
                      min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint
                    FROM study.ProtocolAppNode pan, study.NodeNodeSet sl, study.NodeSet s, min_max, apidb.EigenGeneWgcnaResults result
                    WHERE result.protocol_app_node_id = sl.protocol_app_node_id
                      AND result.protocol_app_node_id = pan.protocol_app_node_id
                      AND sl.node_set_id = s.node_set_id
                      AND min_max.module_name = result.module_name
                      AND min_max.node_set_id = sl.node_set_id
                    GROUP BY sl.node_set_id, result.module_name, min_max.max_value, min_max.min_value, min_max.max_timepoint, min_max.min_timepoint, s.node_type
                  ) t3
              ) profile
            WHERE ds.name = d.name
              AND ds.version = r.version
              AND d.external_database_id = r.external_database_id
              AND profile.node_set_id = ps.node_set_id
              AND ps.external_database_release_id = r.external_database_release_id
          )
          LOOP
            ctrows := ctrows + 1;
            INSERT INTO Profile&1
                (DATASET_NAME, DATASET_TYPE, DATASET_SUBTYPE, PROFILE_TYPE, NODE_TYPE, SOURCE_ID, PROFILE_STUDY_ID, PROFILE_SET_NAME,
                PROFILE_SET_SUFFIX, PROFILE_AS_STRING, MAX_VALUE, MIN_VALUE, MAX_TIMEPOINT, MIN_TIMEPOINT)
                VALUES
                (pf_rows.DATASET_NAME, pf_rows.DATASET_TYPE, pf_rows.DATASET_SUBTYPE, pf_rows.PROFILE_TYPE, pf_rows.NODE_TYPE, pf_rows.SOURCE_ID, pf_rows.PROFILE_STUDY_ID, pf_rows.PROFILE_SET_NAME,
                pf_rows.PROFILE_SET_SUFFIX, pf_rows.PROFILE_AS_STRING, pf_rows.MAX_VALUE, pf_rows.MIN_VALUE, pf_rows.MAX_TIMEPOINT, pf_rows.MIN_TIMEPOINT);
            IF ctrows >= commit_after THEN
              COMMIT;
              ctrows := 0;
            END IF;
          END LOOP;
        commit;
        END;
        $$ LANGUAGE PLPGSQL;
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_idx&1
          on Profile&1 (source_id, profile_type, profile_set_name)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index profset_idx&1
          on Profile&1 (profile_set_name, profile_type)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index srcdset_idx&1
          on Profile&1 (source_id, dataset_subtype, dataset_type)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET dataset_name = 'tbruTREU927_Rijo_Circadian_Regulation_rnaSeq_RSRC'
        WHERE dataset_name= 'tbruTREU927_RNASeq_Rijo_Circadian_Regulation_RSRC'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileType">
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProfileType&1 AS
        SELECT DISTINCT dataset_name, profile_study_id, profile_set_name, profile_set_suffix, node_type, profile_type,
               dataset_type, dataset_subtype
        FROM profile
        WHERE profile_as_string IS NOT NULL
        ORDER BY  dataset_name, profile_set_name,  profile_type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileSamples">
    <internalDependency name="ProfileType"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <sql>
      <![CDATA[
      CREATE TABLE ProfileSamples&1 AS
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id as study_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.nafeatureexpression r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
      AND pt.profile_type not in ('pvalue', 'period', 'amplitude', 'probability_mean','sd','lower_CI','upper_CI','correlation_coefficient')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.NAFeatureMetacycle r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.LopitResults r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          AND pt.profile_type not in ('values', 'channel1_percentiles', 'channel2_percentiles', 'standard_error')
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.compoundMassSpec r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, APIDB.compoundmassspecresult r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
          and pan.name like '%mean%'
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, apidb.ontologytermresult r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, results.nafeaturehostresponse r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, apidb.crisprphenotype r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, apidb.phenotypescore r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
      SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
        REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
        pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
        pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
      FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
        study.protocolAppNode pan, apidb.phenotypegrowthrate r
      WHERE pt.profile_study_id = s.node_set_id
      AND sl.node_set_id = s.node_set_id
      AND sl.protocol_app_node_id = pan.protocol_app_node_id
      AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
          SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.subjectresult r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
        UNION
          SELECT DISTINCT s.name AS study_name, pt.node_type, s.node_set_id,
            REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                           ' \(.+\)', '')AS protocol_app_node_name,
            pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
            pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
            pt.profile_set_suffix
          FROM profileType pt, study.nodeSet s, study.nodeNodeSet sl,
            study.protocolAppNode pan, apidb.EigenGeneWgcnaResults r
          WHERE pt.profile_study_id = s.node_set_id
          AND sl.node_set_id = s.node_set_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND  pan.protocol_app_node_id =r.protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psamp_ix&1
          on ProfileSamples&1
            (dataset_name, profile_type, study_id, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_name,
             node_type, protocol_app_node_name)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index psampstdy_ix&1
          on ProfileSamples&1
            (study_name, node_type, profile_type, node_order_num,
             protocol_app_node_id, profile_set_suffix, study_id,
             protocol_app_node_name, dataset_name)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGroupProfile">
    <comment> For all datasets, list all genes (source_id) of a gene_group where one of them (profile_graph_id)
      has data for a profile_set.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <internalDependency name="OrthologousTranscripts"/>
    <sql>
      <![CDATA[
        create table GeneGroupProfile&1 as
          select distinct other_gene.source_id, p.dataset_name,
               this_gene.source_id as profile_graph_id
          from OrthologousTranscripts ot
             , Profile p
             , GeneAttributes this_gene
             , GeneAttributes other_gene
          where p.source_id = ot.source_id
            and ot.source_id = this_gene.source_id
            and ot.ortho_gene_source_id = other_gene.source_id
            and this_gene.species = other_gene.species
            and ot.is_syntenic = 1
        union
          select ga.source_id, p.dataset_name, p.source_id as profile_graph_id
          from Profile p, GeneAttributes ga
          where p.source_id = ga.source_id
    ]]>
    </sql>
    <sql>
      <![CDATA[
          create index ggp_ix&1
            on GeneGroupProfile&1
              (source_id, dataset_name, profile_graph_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ExpressionGraphsData">
    <comment>
      for gene-page expression graphs
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ProfileSamples"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.NodeSet"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExpressionGraphsData&1  as
          -- RNASeq
          SELECT distinct ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast(case when ps.profile_set_suffix is null then ps.protocol_app_node_name
                          when ps.protocol_app_node_name ='value' then ps.profile_set_suffix 
                          else ps.protocol_app_node_name || ' - ' || ps.profile_set_suffix end ||
                      case when substr(dp.value, 1, 10) in ('0', 'false') and pan.name like '% firststrand %' then '- sense'
                           when substr(dp.value, 1, 10) in ('0', 'false') and pan.name like '% secondstrand %' then '- antisense'
                           when substr(dp.value, 1, 10) in ('1', 'true') and pan.name like '% firststrand %' then '- antisense'
                           when substr(dp.value, 1, 10) in ('1', 'true') and pan.name like '% secondstrand %' then '- sense'
                           else '' end ||
                      case when pan.name like '% unique%' then ' - unique' 
                           else '' end
                       as varchar(300)) AS sample_name,
                 round(nfe.value::numeric, 2) as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetPresenter dnt, DatasetProperty dp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND ps.dataset_name = dnt.name
            AND dnt.dataset_presenter_id = dp.dataset_presenter_id
            AND dp.property = 'switchStrandsProfiles'
            AND ps.study_name not like '%cuff%'
            AND ps.study_name not like '%htseq-intersection-nonempty%'
            AND ps.study_name not like '%htseq-intersection-strict%'
        UNION
          -- Splice Site data
          SELECT ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                            else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                        end as varchar(300)) AS sample_name,
                 round(nfe.value::numeric, 2) as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt,DatasetProperty dp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND d.name = dnt.name
            AND dnt.dataset_presenter_id = dp.dataset_presenter_id
            AND dp.property = 'type' and substr(dp.value, 1, 10) = 'Splice Site'
        UNION
          -- microarray expression, quantitative proteomics, and eQTL
          SELECT ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 cast (case when ps.profile_set_suffix is null
                              then ps.protocol_app_node_name
                             else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix
                       end as varchar(300)) AS sample_name,
                 CASE WHEN (d.NAME ='pfal3D7_quantitativeMassSpec_Apicoplast_ER_RSRC')
                   THEN round(nfe.VALUE::numeric, 6)
                   ELSE round(nfe.value::numeric, 2) END as value,
                 round(nfe.standard_error::numeric, 2) as standard_error,
                 round(nfe.percentile_channel1::numeric, 2) as percentile_channel1,
                 round(nfe.percentile_channel2::numeric, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          FROM results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.nodeSet s,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt, DatasetPresenter dsp
          WHERE ga.na_feature_id = nfe.na_feature_id
            AND nfe.protocol_app_node_id = pan.protocol_app_node_id
            AND pan.protocol_app_node_id = ps.protocol_app_node_id
            AND ps.study_id = s.node_set_id
            AND s.external_database_release_id = r.external_database_release_id
            AND r.external_database_id = d.external_database_id
            AND d.name = dnt.name
            AND dnt.dataset_presenter_id = dsp.dataset_presenter_id
            AND dsp.subtype != 'rnaseq'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edg_ix&1
          on ExpressionGraphsData&1
            (source_id, dataset_id, sample_name, value, standard_error, percentile_channel1, percentile_channel2)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Taxonomy">
    <comment>
      For each distinct organism in GeneAttributes, all ancestors in the taxon tree. For the gene page.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE Taxonomy&1 as
        WITH RECURSIVE cte AS (
          WITH tax AS(
              SELECT t.taxon_id, t.parent_id, t.ncbi_tax_id,
                cast(tn.name as varchar(80)) as name,
                cast(t.rank as varchar(24)) as rank
              FROM sres.Taxon t, sres.TaxonName tn
              WHERE t.taxon_id = tn.taxon_id
                  AND tn.name_class = 'scientific name'
          )
          SELECT tax.*, name as organism, ARRAY[taxon_id::numeric] as path
          FROM tax
          WHERE name IN (SELECT DISTINCT organism FROM GeneAttributes)
          UNION
          SELECT tax.*, cte.organism, cte.path || tax.taxon_id as path
          FROM tax, cte
          WHERE cte.parent_id = tax.taxon_id
              AND tax.name != 'root'
        )
        SELECT taxon_id, parent_id, ncbi_tax_id, name, rank, organism, row_number() over() as orderNum
        FROM (SELECT cte.* FROM cte ORDER BY path) t
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tax_ix&1
          on Taxonomy&1
            (organism, ordernum, taxon_id, parent_id, ncbi_tax_id, name, rank)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneModelDump">
    <comment>
      Materialization of GeneTables.GeneModelDump.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneModelDump&1 as
        SELECT source_id, project_id, sequence_id, gm_start,gm_end, type, is_reversed,
               string_agg(transcript_id, ',' ORDER BY transcript_id) AS transcript_ids
        FROM (
          SELECT distinct ta.source_id as transcript_id, ta.gene_source_id as source_id, ta.project_id,
              ta.sequence_id,gm.start_min as gm_start, gm.end_max as gm_end,
              gm.type, gl.is_reversed
          FROM
            apidb.FeatureLocation gl, dots.NaSequence s,
            TranscriptAttributes ta,
            (
              SELECT CASE el.feature_type WHEN 'ExonFeature' THEN 'Exon' ELSE el.feature_type END as type,
                  el.parent_id as na_feature_id, el.start_min as start_min, el.end_max as end_max
              FROM apidb.FeatureLocation el
              WHERE el.feature_type in  ('ExonFeature','five_prime_UTR', 'three_prime_UTR','CDS','Intron')
                AND el.is_top_level = 1
            ) gm
          WHERE gm.na_feature_id = ta.na_feature_id
            AND s.na_sequence_id = gl.na_sequence_id
            AND ta.na_feature_id = gl.na_feature_id
            AND gl.is_top_level = 1
        ) t
        GROUP BY source_id, project_id, sequence_id,
                 gm_start,  gm_end, type, is_reversed
        ORDER BY CASE WHEN is_reversed = 1 THEN -1 * gm_start ELSE gm_start END
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gmd_ix&1
          on GeneModelDump&1
            (source_id, project_id, sequence_id, gm_start, gm_end, is_reversed, type, transcript_ids)

      ]]>
    </sql>
  </tuningTable>


<!-- COMMENT FOR NOW, as no InferredParam table; FIX later
  <tuningTable name="RflpGenotypes">
    <comment>
      Ordered list of distinct genotypes for each protocol_app_node_id in apidb.RflpGenotypes
    </comment>
    <externalDependency name="apidb.RflpGenotype"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        CREATE TABLE RflpGenotypes&1 AS
        SELECT sd.protocol_app_node_id, sd.output_pan_id,
               cast (string_agg(genotype, ', ' order by genotype) as varchar(80)) as genotypes
        FROM (SELECT DISTINCT genotype, protocol_app_node_id FROM apidb.RflpGenotype) rg,
             SampleProcess sd
        WHERE sd.output_pan_id = rg.protocol_app_node_id
        GROUP BY sd.protocol_app_node_id, sd.output_pan_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index rflpG_ix&1
          on RflpGenotypes&1
            (protocol_app_node_id, output_pan_id, genotypes)

      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="GeneSummaryFilter">
    <comment>
      Distinct filter_name for gene query summary. For the initial version,
      at least, it's (GeneAttriutes.species UNION GeneAttributes.organism).
      Note that the UNION implies set bahavior and therefore distinctness.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneSummaryFilter&1 AS
        SELECT CAST(filter_name AS VARCHAR(80)) AS filter_name
        FROM (SELECT species as filter_name
              FROM GeneAttributes
            UNION
              SELECT organism as filter_name
              FROM GeneAttributes) t
       ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AaSequenceInfo">
    <comment>
      Info from dots.ExternalAaSequence records for BLAT alignments
    </comment>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <sql>
      <![CDATA[
        CREATE TABLE AaSequenceInfo&1 AS
        SELECT aa_sequence_id, source_id,
               CAST(description AS VARCHAR(300)) AS description
        FROM dots.ExternalAaSequence
        WHERE aa_sequence_id IN (SELECT query_aa_sequence_id
                                 FROM apidb.BlatProteinAlignment)
        ORDER by aa_sequence_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX aaSeqInf_ix&1
          ON AaSequenceInfo&1 (aa_sequence_id, source_id, description)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologousTranscripts">
    <comment>
      Materialization of the orthology transform. Also useful for GeneTables.Orthologs.
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.SyntenicGene"/>
    <externalDependency name="apidb.Organism"/>
    <intermediateTable name="SyntenicPairs"/>
    <sql>
      <![CDATA[
         create UNLOGGED table SyntenicPairs as
         select distinct ga.na_feature_id, sg.syn_na_feature_id
         from apidb.SyntenicGene sg, GeneAttributes ga
         where sg.na_sequence_id = ga.na_sequence_id
           and sg.end_max >= ga.start_min
           and sg.start_min <= ga.end_max
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index SynPair_idx&1
          on SyntenicPairs (na_feature_id, syn_na_feature_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table OrthologousTranscripts&1 as
        with all_pairs
             as (select ga.source_id
                      , ga.project_id
                      , ga.na_feature_id
                      , ota.source_id as ortho_source_id
                      , ota.gene_source_id as ortho_gene_source_id
                      , ota.project_id as ortho_project_id
                      , ota.gene_na_feature_id as ortho_na_feature_id
                      , ota.transcript_product as ortho_product
                      , ota.protein_length
                      , ga.name as ortho_name
                      , ota.organism as ortho_organism
                      , ota.taxon_id as ortho_taxon_id
                      , o.is_reference_strain
                 from Geneattributes ga
                    , TranscriptAttributes ota
                    , apidb.Organism o
                 where ga.ORTHOMCL_NAME = ota.ORTHOMCL_NAME
                 and ota.taxon_id = o.taxon_id
             ),
             syn_pairs
             as (select na_feature_id, syn_na_feature_id, 1 as is_syntenic from SyntenicPairs
             )
        select all_pairs.*
             , coalesce(syn_pairs.is_syntenic, 0) as is_syntenic
        from all_pairs
             left join syn_pairs
             on all_pairs.na_feature_id = syn_pairs.na_feature_id
                and all_pairs.ortho_na_feature_id = syn_pairs.syn_na_feature_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ot_idx&1
          on OrthologousTranscripts&1 (source_id, project_id, is_syntenic desc, ortho_source_id,
                                       ortho_project_id, ortho_gene_source_id, ortho_product,
                                       ortho_name, ortho_organism, ortho_taxon_id, is_reference_strain)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ot_smol_idx&1
          on OrthologousTranscripts&1 (is_syntenic, ortho_taxon_id, source_id, ortho_source_id,
                                       ortho_project_id, ortho_gene_source_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetGeneList">
    <comment>
      For each RNA-Seq Dataset, compute the top 500 ratios of max/min gene expression.
    </comment>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE DatasetGeneList&1 AS
          SELECT source_id, organism, orthomcl_name, profile_study_id, dataset_name, dataset_presenter_id,
            fdiff, fdiff_abs, min_value, min_timepoint, max_value, max_timepoint,
            row_number() OVER (PARTITION BY dataset_name,profile_study_id order by fdiff_abs DESC) AS myrow
          FROM
            (
              SELECT p.source_id, ga.organism, ga.orthomcl_name, p.profile_study_id, p.dataset_name
                , dp.dataset_presenter_id
                , ROUND ( max_value / CASE WHEN min_value < 1 THEN 1 ELSE min_value END,2) AS fdiff
                , ABS (ROUND ( max_value / CASE WHEN min_value < 1 THEN 1 ELSE min_value END,2)) AS fdiff_abs
                , ROUND (p.min_value, 2) as min_value
                , REGEXP_REPLACE (p.min_timepoint, ' \[.+\] \(.+\)', '') as min_timepoint
                , ROUND( p.max_value, 2) as max_value
                , REGEXP_REPLACE (p.max_timepoint, ' \[.+\] \(.+\)', '') as max_timepoint
              FROM Profile p, DatasetPresenter dp, DatasetProperty dprop, GeneAttributes ga
              WHERE p.dataset_type        = 'transcript_expression'
                AND p.dataset_subtype       = 'rnaseq'
                AND p.profile_type          = 'values'
                AND p.dataset_name          = dp.NAME
                AND dp.dataset_presenter_id = dprop.dataset_presenter_id
                AND p.profile_set_name like '%- unique]'
                AND property                = 'switchStrandsProfiles'
                AND ((substr(dprop.value, 1, 10) = 'false' AND p.min_timepoint LIKE '%firststrand%')
                  OR (substr(dprop.value, 1, 10) = 'true' AND p.min_timepoint LIKE '%secondstrand%')
                  OR (p.min_timepoint LIKE '%unstranded%'))
                AND p.source_id = ga.source_id
            ) t
          ORDER BY DATASET_NAME, profile_study_id, fdiff_abs DESC
       ]]>
    </sql>

    <sql>
      <![CDATA[
        create index DsGl_source_id_idx&1 ON DatasetGeneList&1 (source_id,organism)

      ]]>
    </sql>

    <sql>
      <![CDATA[
        create index DsGl_omcl_nme_idx&1 ON DatasetGeneList&1 (orthomcl_name,organism)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="RodMalPhenotype">
    <comment>
      for GeneTables.RodMalPhenotypeTable
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.NaFeaturePhenotypeModel"/>
    <externalDependency name="apidb.PhenotypeModel"/>
    <externalDependency name="apidb.PhenotypeResult"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE RodMalPhenotype&1 AS
        WITH mut
             AS (SELECT DISTINCT ga.source_id, ga.project_id, pm.source_id as rmgmid,
                                 pm.pubmed_id, pm.modification_type as mod_type,
                                 pm.is_successful as suc_of_gen_mod,
                                 pm.mutation_description, ot.name,
                                 SUBSTR(pr.phenotype_post_composition, 4000, 1) as phenotype1,
                                 SUBSTR(pr.phenotype_post_composition, 4000, 4001) as phenotype2,
                                 pm.has_multiple_mutations AS multiple, na.NA_FEATURE_ID as id,
                                 pm.phenotype_model_id
                 FROM apidb.PhenotypeResult pr
                      LEFT OUTER JOIN sres.OntologyTerm ot
                        ON pr.life_cycle_stage_term_id = ot.ontology_term_id,
                      apidb.PhenotypeModel pm, GeneAttributes ga,
                      apidb.NaFeaturePhenotypeModel na
                 WHERE pm.phenotype_model_id = pr.phenotype_model_id
                   AND na.phenotype_model_id = pm.phenotype_model_id
                   AND na.na_feature_id = ga.na_feature_id
                ),
             knockdown
             AS (SELECT DISTINCT genes.source_id, mods.phenotype_model_id as model_id
                 FROM apidb.PhenotypeModel mods, apidb.NaFeaturePhenotypeModel nod,
                      GeneAttributes genes, mut m
                 WHERE mods.phenotype_model_id = m.phenotype_model_id
                   AND m.phenotype_model_id = nod.phenotype_model_id
                   AND mods.phenotype_model_id = nod.phenotype_model_id
                   AND m.id != nod.na_feature_id
                   AND genes.na_feature_id = nod.na_feature_id
                   AND m.source_id != genes.source_id
                -- AND mods.has_multiple_mutations = 1
                ),
             results
             AS (SELECT CAST (m.source_id AS VARCHAR(30)) AS source_id,
                    --  m.project_id,
                        CAST (m.rmgmid AS VARCHAR(12)) AS rmgmid, m.pubmed_id,
                        CAST (m.mod_type AS VARCHAR(20)) as mod_type,
                        CASE
                          WHEN m.suc_of_gen_mod = 0
                            THEN 'NO'
                          ELSE 'YES'
                        END AS suc_of_gen_mod,
                        CAST(m.mutation_description AS VARCHAR(150)) AS mutation_description,
                        CAST(string_agg(m.name, ', ' ORDER BY m.name)
                             AS VARCHAR(250)) AS life_cycle_stage,
                        CONCAT(phenotype1,phenotype2) AS phenotype,
                        m.phenotype_model_id
                 FROM mut m
                 GROUP BY m.source_id, m.project_id, m.rmgmid, m.pubmed_id, m.mod_type,
                          m.suc_of_gen_mod, m.mutation_description, m.phenotype1,
                          m.phenotype2,m.phenotype_model_id
                )
        SELECT results.*,
               CAST(knockdown.source_id AS VARCHAR(30)) as other_source_id
        FROM results
             LEFT JOIN knockdown ON results.phenotype_model_id = knockdown.model_id
        WHERE knockdown.source_id <> results.source_id
           OR knockdown.source_id is null
        ORDER BY results.source_id, results.rmgmid
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX RodMal_ix&1
        ON RodMalPhenotype&1(source_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChrCopyNumbers">
    <comment>Chromosome data for CNV queries</comment>
    <internalDependency name="PANIO"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <sql>
        <![CDATA[
          CREATE TABLE ChrCopyNumbers&1 AS
          SELECT DISTINCT ta.na_sequence_id
            , ta.chromosome
            , ccn.chr_copy_number AS ploidy
            , io.input_pan_id
            , io.output_pan_id
          FROM apidb.ChrCopyNumber ccn
            , TranscriptAttributes ta
            ,  PANIo io
          WHERE ta.na_sequence_id = ccn.na_sequence_id
            AND ta.chromosome IS NOT NULL
            AND ccn.protocol_app_node_id = io.output_pan_id
        ]]>
    </sql>
    <sql>
        <![CDATA[
          CREATE INDEX ChrCN_ix&1
          ON ChrCopyNumbers&1(input_pan_id, na_sequence_id)

        ]]>
    </sql>
    <sql>
        <![CDATA[
          CREATE INDEX ChrCN_output&1
          ON ChrCopyNumbers&1(output_pan_id)

        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneCopyNumbers">
    <comment>Gene Data for CNV queries</comment>
    <internalDependency name="PANIO"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
            CREATE TABLE GeneCopyNumbers&1 AS
            SELECT DISTINCT ta.project_id
            , ta.source_id
            , ta.gene_source_id
            , REGEXP_REPLACE(pan.name, '_[A-Za-z0-9]+ (.+)$', '') AS strain
            , gcn.haploid_number AS raw_estimate
            , gcn.ref_copy_number AS ref_cn
            , CASE WHEN (gcn.haploid_number < 0.01) THEN 0
                WHEN (0.01 < gcn.haploid_number AND gcn.haploid_number < 1.85) THEN 1
                ELSE round(gcn.haploid_number) END AS haploid_number
            , ta.chromosome
            , ta.na_sequence_id
            , io.input_pan_id
            , io.output_pan_id
            FROM apidb.genecopynumber gcn
            , study.protocolappnode pan
            , TranscriptAttributes ta
            ,  PANIo io
            WHERE gcn.protocol_app_node_id = pan.protocol_app_node_id
            AND gcn.na_feature_id = ta.gene_na_feature_id
            AND gcn.protocol_app_node_id = io.output_pan_id
            AND (ta.gene_type = 'protein coding' or ta.gene_type = 'protein coding gene')
        ]]>
    </sql>
    <sql>
      <![CDATA[
            CREATE INDEX GeneCN_ix&1
            ON GeneCopyNumbers&1(input_pan_id, na_sequence_id)

        ]]>
    </sql>
  </tuningTable>


<!--  <tuningTable name="Stringdb" alwaysUpdate="true">-->
  <tuningTable name="Stringdb" >
    <comment> Data from STRING-DB.org, populated from their web service.
      Used in the gene record.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <program commandLine="buildStringdbTT"/>
  </tuningTable>


  <tuningTable name="InterproData">
    <comment>for TranscriptAttributes.InterproColumns</comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.DomainFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
          CREATE TABLE InterproData&1 AS
          WITH iprows AS (
            SELECT
              source_id,
              string_agg(CASE WHEN interpro_name = 'INTERPRO' THEN primary_id ELSE null END, ';' order by primary_id) as interpro_id,
              string_agg(CASE WHEN interpro_name = 'INTERPRO' THEN remark ELSE null END, ';' order by primary_id) as interpro_description,
              string_agg(CASE WHEN interpro_name = 'InterProScan' THEN primary_id ELSE null END, ';' order by primary_id) as interpro2_id,
              string_agg(CASE WHEN interpro_name = 'InterProScan' THEN remark ELSE null END, ';' order by primary_id) as interpro2_description,
              string_agg(CASE WHEN interpro_name = 'PFAM' THEN primary_id ELSE null END, ';' order by primary_id) as pfam_id,
              string_agg(CASE WHEN interpro_name = 'PFAM' THEN remark ELSE null END, ';' order by primary_id) as pfam_description,
              string_agg(CASE WHEN interpro_name = 'PIRSF' THEN primary_id ELSE null END, ';' order by primary_id) as pirsf_id,
              string_agg(CASE WHEN interpro_name = 'PIRSF' THEN remark ELSE null END, ';' order by primary_id) as pirsf_description,
              string_agg(CASE WHEN interpro_name = 'PROSITEPROFILES' THEN primary_id ELSE null END, ';' order by primary_id) as prositeprofiles_id,
              string_agg(CASE WHEN interpro_name = 'PROSITEPROFILES' THEN remark ELSE null END, ';' order by primary_id) as prositeprofiles_description,
              string_agg(CASE WHEN interpro_name = 'SMART' THEN primary_id ELSE null END, ';' order by primary_id) as smart_id,
              string_agg(CASE WHEN interpro_name = 'SMART' THEN remark ELSE null END, ';' order by primary_id) as smart_description,
              string_agg(CASE WHEN interpro_name = 'SUPERFAMILY' THEN primary_id ELSE null END, ';' order by primary_id) as superfamily_id,
              string_agg(CASE WHEN interpro_name = 'SUPERFAMILY' THEN remark ELSE null END, ';' order by primary_id) as superfamily_description,
              string_agg(CASE WHEN interpro_name = 'TIGRFAM' THEN primary_id ELSE null END, ';' order by primary_id) as tigrfam_id,
              string_agg(CASE WHEN interpro_name = 'TIGRFAM' THEN remark ELSE null END, ';' order by primary_id) as tigrfam_description
            FROM (
                SELECT DISTINCT
                  dr.primary_identifier as primary_id,
                  dr.remark, xd1.name as interpro_name, ta.source_id
                FROM TranscriptAttributes ta, dots.AaLocation al,
                  sres.ExternalDatabaseRelease xdr1, sres.ExternalDatabase xd1,
                  sres.ExternalDatabaseRelease xdr3, sres.ExternalDatabase xd3,
                  sres.DbRef dr, dots.DbRefAaFeature draf, dots.DomainFeature df
                  LEFT JOIN dots.DomainFeature df2 ON df.parent_id = df2.aa_feature_id
                WHERE xd3.name IN (
                    'InterproscanData_RSRC', 'INTERPRO', 'InterProScan',
                    'PFAM', 'PIRSF', 'PROSITEPROFILES',
                    'SMART', 'SUPERFAMILY', 'TIGRFAM'
                  )
                  AND ta.aa_sequence_id = df.aa_sequence_id
                  AND df.aa_feature_id = draf.aa_feature_id
                  AND df.aa_feature_id = al.aa_feature_id
                  AND draf.db_ref_id = dr.db_ref_id
                  AND dr.external_database_release_id = xdr1.external_database_release_id
                  AND xdr1.external_database_id = xd1.external_database_id
                  AND df.external_database_release_id = xdr3.external_database_release_id
                  AND xdr3.external_database_id = xd3.external_database_id
            ) t
            GROUP BY source_id
          )
          SELECT source_id,
                 substr(interpro_id, 1, 200)||substr(interpro2_id, 1, 200) as interpro_id,
                 substr(interpro_description, 1, 3000)||substr(interpro2_description, 1, 3000) as interpro_description,
                 substr(pfam_id, 1, 200) as pfam_id,
                 substr(pfam_description, 1, 3000) as pfam_description,
                 substr(pirsf_id, 1, 200) as pirsf_id,
                 substr(pirsf_description, 1, 3000) as pirsf_description,
                 substr(prositeprofiles_id, 1, 200) as prositeprofiles_id,
                 substr(prositeprofiles_description, 1, 3000) as prositeprofiles_description,
                 substr(smart_id, 1, 200) as smart_id,
                 substr(smart_description, 1, 3000) as smart_description,
                 substr(superfamily_id, 1, 200) as superfamily_id,
                 substr(superfamily_description, 1, 3000) as superfamily_description,
                 substr(tigrfam_id, 1, 200) as tigrfam_id,
                 substr(tigrfam_description, 1, 3000) as tigrfam_description
          FROM iprows
        ]]>
    </sql>
    <sql>
      <![CDATA[
            create index ipd_ix&1
            on InterproData&1(source_id)

        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ApolloUpdate" alwaysUpdate="true">
    <comment>annotation updates from Apollo</comment>
    <ancillaryTable name="ApolloID"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <program commandLine="loadGffApolloTT"/>
  </tuningTable>


  <tuningTable name="GeneLocations" prefixEnabled="true">
    <comment>semicolon-delimited list of formatted genomic locations for each gene</comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixGeneLocations&1 AS
        SELECT source_id,
               string_agg(location, '; ' order by is_top_level desc) as locations
        FROM (SELECT fl.feature_source_id as source_id, fl.is_top_level,
                     fl.sequence_source_id || ':'
                     || trim(to_char(fl.start_min,'999,999,999')) || '..'
                     || trim(to_char(fl.end_max,'999,999,999')) || '('
                     || CASE coalesce(fl.is_reversed, 0) WHEN 0 THEN '+' WHEN 1 THEN '-' ELSE fl.is_reversed::varchar END
                     || ')' as location
              FROM apidb.FeatureLocation fl, dots.NaSequence ns
              WHERE fl.feature_type = 'GeneFeature'
                AND fl.na_sequence_id = ns.na_sequence_id
                AND (ns.taxon_id::varchar = '&filterValue' or length('&filterValue') = 0)
          ) t
        GROUP BY source_id
      ]]>
    </sql>
    <sql>
        <![CDATA[
          create index gloc_ix&1
          on &prefixGeneLocations&1(source_id, locations)

        ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatabaseTaxonUrl">
    <comment>
      Stores a mapping between external databases, taxon IDs, and URLs
    </comment>
    <externalDependency name="apidb.ExternalResourceUrl"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table DatabaseTaxonUrl&1 as
        select edd.dataset_presenter_display_name AS dataset, ga.taxon_id, edr.id_url
        from sres.DbRef db, dots.DbRefNaFeature dbna,
             ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
             GeneAttributes ga
        where db.external_database_release_id = edd.external_database_release_id
          and edr.external_database_release_id = edd.external_database_release_id
         and dbna.db_ref_id = db.db_ref_id
         and ga.na_feature_id = dbna.na_feature_id
         and id_url not like 'http://chemlims.com/%'
      union
        select edd.dataset_presenter_display_name AS dataset, ta.taxon_id, edr.id_url
        from sres.dbref db, dots.DbRefNaFeature dbna,
             ExternalDbDatasetPresenter edd, sres.ExternalDatabaseRelease edr,
             TranscriptAttributes ta
        where db.external_database_release_id = edd.external_database_release_id
          and edr.external_database_release_id = edd.external_database_release_id
          and dbna.db_ref_id = db.db_ref_id
          and ta.na_feature_id = dbna.na_feature_id
      union
        select d.name as dataset, ga.taxon_id, eru.id_url
        from sres.DbRef dbr, dots.DbRefNaFeature dbrf, sres.ExternalDatabaseRelease r,
             sres.ExternalDatabase d, GeneAttributes ga,
             apidb.ExternalResourceUrl eru
        where dbr.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and dbr.db_ref_id = dbrf.db_ref_id
          and dbrf.na_feature_id = ga.na_feature_id
          and upper(d.name) = eru.database_name
      union
        select distinct
               d.name as dataset, ta.taxon_id, eru.id_url
        from sres.DbRef dbr, dots.DbRefAaFeature dbrf, dots.AaFeature aaf,
             sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
             TranscriptAttributes ta, apidb.ExternalResourceUrl eru
        where dbr.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and dbr.db_ref_id = dbrf.db_ref_id
          and dbrf.aa_feature_id = aaf.aa_feature_id
          and aaf.aa_sequence_id = ta.aa_sequence_id
          and upper(d.name) = eru.database_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index dtaxu_ix&1
          on DatabaseTaxonUrl&1 (taxon_id, dataset, id_url)

      ]]>
    </sql>
  </tuningTable>


<!-- commenting now; MUST FIX
  <tuningTable name="TranscriptGenomicSequence">
    <comment>The genomic sequence of each transcript. Used in the transcript record / gene record page.
    </comment>
   - COMMENTING OUT DEPENDENCIES FOR NOW 
    <externalDependency name="apidb.TranscriptLocation"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.TaxonName"/>

    <sql>
      <![CDATA[
        create table TranscriptGenomicSequence&1 as
        select gf.source_id as gene_source_id, t.source_id,
               cast (null as varchar(80)) as project_id,
               nas.sequence as genomic_sequence,
               length(nas.sequence) as genomic_sequence_length
        from dots.NaSequence nas, dots.GeneFeature gf, dots.Transcript t
        where 1 = 0
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create unique index txgseq_idx&1
          on TranscriptGenomicSequence&1(source_id, gene_source_id, project_id)

      ]]>
    </sql>

    <perl>
      <![CDATA[
use strict;

use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;
use DBD::Oracle;

use CBIL::Bio::SequenceUtils; #reverseComplementSequence

use Getopt::Long qw(GetOptions);

use Data::Dumper;

use EbrcModelCommon::Model::tmUtils;


my $insertSql = "INSERT INTO TranscriptGenomicSequence&1
    (gene_source_id, source_id, project_id,
     genomic_sequence, genomic_sequence_length)
 VALUES (?,?,?,?,?)";
my $insertSh = $dbh->prepare($insertSql);

my $sql = "SELECT ga.source_id AS gene_source_id
     , ga.project_id AS project_id
     , t.source_id
     , tl.start_min
     , tl.end_max
     , tl.is_reversed
     , gss.source_id
     , gss.sequence
FROM apidb.transcriptlocation tl
   , apidbtuning.geneattributes ga
   , dots.transcript t
   , apidbtuning.genomicsequencesequence gss
WHERE t.na_feature_id  = tl.na_feature_id
AND t.parent_id = ga.na_feature_id
AND tl.sequence_source_id = gss.source_id
ORDER BY gss.source_id";


# get the lob locator object here
my $sh = $dbh->prepare($sql, { ora_auto_lob => 0 } )
     or die "Can't prepare SQL statement: " . $dbh->errstr();
$sh->execute();

my ($prevSequenceSourceId, $sequence, $count);
while(my ($geneSourceId, $projectId, $sourceId, $start, $end, $isReversed, $sequenceSourceId, $sequenceLobLocator) = $sh->fetchrow_array()) {

  if($prevSequenceSourceId ne $sequenceSourceId) {
    # print STDERR "Processing Transcripts for sequence $sequenceSourceId\n";
    $sequence = &readClob($dbh, $sequenceLobLocator);
  }

  my $substrStart = $start - 1;
  my $substrLength = $end - $start + 1;

  my $transcriptGenomicSequence = substr($sequence, $substrStart, $substrLength);

  if($isReversed) {
    $transcriptGenomicSequence = CBIL::Bio::SequenceUtils::reverseComplementSequence($transcriptGenomicSequence);
  }

  $insertSh->execute($geneSourceId, $sourceId, $projectId, $transcriptGenomicSequence, $substrLength);

  if($count++ % 200000 == 0) {
    print STDERR "Commit point; count = $count\n";
    $dbh->commit();
  }

  $prevSequenceSourceId = $sequenceSourceId;
}

$dbh->commit();


sub readClob {
  my ($dbh, $lobLocator) = @_;

  my $chunkSize = $dbh->ora_lob_chunk_size($lobLocator);
  my $offset = 1;   # Offsets start at 1, not 0

  my $output;
  while(1) {
    my $data = $dbh->ora_lob_read($lobLocator, $offset, $chunkSize );
    last unless length $data;
    $output .= $data;
    $offset += $chunkSize;
  }
  return $output;
}


1;
      ]]>
    </perl>

  </tuningTable>
-->


  <tuningTable name="GroupPhylogeneticProfile">
    <comment>
      One phylogenetic-profile string per ortholog group
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <sql>
      <![CDATA[
        CREATE table GroupPhylogeneticProfile&1 as
        SELECT rep.orthomcl_name, pp.profile_string
        FROM apidb.PhylogeneticProfile pp,
             (SELECT orthomcl_name, max(source_id) as source_id
              FROM GeneAttributes
              GROUP BY orthomcl_name) rep
        WHERE rep.source_id = pp.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index group_pp_ix&1
          on GroupPhylogeneticProfile&1 (orthomcl_name)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ApolloUpdateGene">
    <comment>
      Text from ApolloUpdate that can be used in site search to find genes
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ApolloUpdate"/>
    <sql>
      <![CDATA[
        CREATE TABLE ApolloUpdateGene&1 AS
        SELECT ga.source_id
          , ga.project_id
          , au.id_attr
          , ta.gene_source_id
          , 'Y' as matched_result
          -- TODO, cast(utl_url.unescape(replace( replace(regexp_substr(au.attr, 'Name=[^;]*;'), 'Name=', ''), ';', '')) as varchar(400)) as apollo_transcript_id
          , 'TODO' as apollo_transcript_id
          , au.creationdate as comment_date
          , au.apolloproduct || au.apollosymbol || au.apolloowner || au.apollogoterm || au.apollopmid as attr
          , au.apolloproduct as apollo_description
          , au.apolloowner as apollo_owner
          , au.apollopmid as apollo_dbxref
          , au.apollosymbol as apollo_symbol
          , au.apollogoterm as apollo_go_term
          , au.creationdate as creation_date
          , au.apolloevidencecode as evidence_code
          , au.apolloevidencecodeassignment as evidence_code_parameter
          , 'TODO add owner details' as apollo_owner_details
          --, (select firstname.value || ' ' ||  lastname.value || ', ' || address.value from
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'first_name') firstname,
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'last_name') lastname,
          --    (select uap.value
          --        from useraccounts.accounts@acctdbn.profile uaa,  useraccounts.account_properties@acctdbn.profile uap
          --        where uaa.user_id = uap.user_id
          --        and uaa.stable_id = REGEXP_SUBSTR(apolloowner,'[^,]+',1,1)
          --        and uap.key = 'organization') address) as apollo_owner_details
        FROM ApolloUpdate au, GeneAttributes ga, TranscriptAttributes ta
        WHERE au.type = 'gene'
          AND (au.attr like '%gene_product=%'
              OR au.attr like '%description=%')
          AND ga.na_sequence_id = au.na_sequence_id
          AND ga.start_min <= au.mapping_end AND ga.end_max >= au.mapping_start
          AND ta.source_id = au.apolloTranscript
          AND ga.strand_plus_minus = au.strand
          AND ta.gene_source_id = ga.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index aug_ix&1
          on ApolloUpdateGene&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PreferredProductsGene">
    <comment>
      Text for PreferredProduct table on gene record page.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        -- PreferredProductsGene: check apidb.TranscriptProduct and
        -- apidb.GeneFeatureProduct for records with IS_PREFERRED set. If
        -- (and only if) that turns up nothing, check the PRODUCT column of
        -- dots.GeneFeature and dots.Transcript
        create table PreferredProductsGene&1 as
        with evids
          as (select distinct gaiec.go_evidence_code_id, ot.name
              from  dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm ot
              where ot.ontology_term_id = gaiec.go_evidence_code_id)
        -- end of WITH clause
        select ta.gene_source_id as source_id, tp.product, ta.project_id,
          string_agg(source_id, ', ' order by source_id) as transcript_ids,
          string_agg(publication, ', ' order by source_id) as reference,
          e.name as evidence_code,
          tp.with_from AS evidence_code_parameter,
          cast (max(tp.assigned_by) as varchar(20)) as assigned_by,
          'apidb.TranscriptProduct' as row_source
        from apidb.TranscriptProduct tp
          INNER JOIN TranscriptAttributes ta ON ta.na_feature_id = tp.na_feature_id
          LEFT JOIN evids e ON tp.evidence_code = e.go_evidence_code_id
        where tp.is_preferred = 1
        group by gene_source_id, ta.project_id, tp.product,
          e.name, tp.with_from
        union
        select ga.source_id, gfp.product, ga.project_id,
          null::varchar as transcript_ids,
          null::varchar as reference,
          null::varchar as evidence_code,
          null::varchar as evidence_code_parameter,
          null::varchar as  assigned_by,
          'apidb.GeneFeatureProduct' as row_source
        from apidb.GeneFeatureProduct gfp, GeneAttributes ga
        where ga.na_feature_id = gfp.na_feature_id
          and gfp.is_preferred = 1
        group by source_id, ga.project_id, gfp.product
        union
        select *
        from (select ta.gene_source_id as source_id, ta.transcript_product, ta.project_id,
                string_agg(source_id, ', ' order by source_id) as transcript_ids,
                null::varchar as reference,
                null::varchar as evidence_code,
                null::varchar as evidence_code_parameter,
                null::varchar as  assigned_by,
                'TranscriptAttributes/GeneAttributes' as row_source
              from TranscriptAttributes ta
              where ta.transcript_product is not null
              group by ta.gene_source_id, ta.transcript_product, ta.project_id
             ) t
        where source_id
          in (  select *
                from (  select source_id
                        from dots.GeneFeature
                        where product is not null
                        union
                        select ga.source_id
                        from dots.Transcript t, GeneAttributes ga
                        where t.product is not null
                          and t.parent_id = ga.na_feature_id
                     ) t
                EXCEPT
                select *
                from (  select ta.gene_source_id
                        from apidb.TranscriptProduct tp, TranscriptAttributes ta
                        where tp.na_feature_id = ta.na_feature_id
                        union
                        select ga.source_id
                        from apidb.GeneFeatureProduct gfp, GeneAttributes ga
                        where gfp.na_feature_id = ga.na_feature_id
                     ) t2
             )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index ppg_ix&1
          on PreferredProductsGene&1 (source_id, project_id)

      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="AlphaFoldGenes">
    <comment>
      Links AlphaFold entries to gene ids where Uniprot ids are directly assigned
    </comment>

    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="sres.externaldatabase"/>
    <externalDependency name="sres.externaldatabaserelease"/>
    <externalDependency name="sres.dbref"/>
    <externalDependency name="dots.dbrefaafeature"/>
    <externalDependency name="dots.aafeature"/>
    <externalDependency name="dots.dbrefnafeature"/>
    <externalDependency name="dots.nafeature"/>
    <externalDependency name="apidb.alphafold"/>
    <ancillaryTable name="uniprotGenes"/>
    <intermediateTable name="minRank"/>
    <intermediateTable name="alphaFoldHits"/>

    <sql>
      <![CDATA[
        CREATE TABLE uniprotGenes&1 AS
        SELECT DISTINCT ed.name
        , d.*
        , edr.version
        , aa.source_id
        , pa.gene_source_id
        , CASE WHEN (ed.name like '%SWISSPROT%' AND edr.version = 'xrefuniparc') THEN 1
            WHEN (ed.name like '%SPTREMBL%' AND edr.version = 'xrefuniparc') THEN 2
            WHEN (ed.name like '%SWISSPROT%' AND edr.version = 'xref_sprot_blastp') THEN 4
            WHEN (ed.name like '%SPTREMBL%' and edr.version = 'xref_trembl_blastp') THEN 5
            ELSE 6 END as rank
        , (af.last_residue_index - af.first_residue_index + 1) as hit_length
        FROM sres.dbref d
        LEFT JOIN apidb.AlphaFold af ON d.primary_identifier = af.uniprot_id
        , sres.externaldatabase ed
        , sres.externaldatabaserelease edr
        , dots.dbrefaafeature db
        , dots.aafeature aa
        , ProteinAttributes pa
        WHERE (ed.name = 'Uniprot/SWISSPROT' OR ed.name = 'Uniprot/SPTREMBL')
          AND (edr.version = 'xrefuniparc' OR edr.version = 'xref_sprot_blastp' OR edr.version = 'xref_trembl_blastp')
          AND edr.external_database_id = ed.external_database_id
          AND d.external_database_release_id = edr.external_database_release_id
          AND db.db_ref_id = d.db_ref_id
          AND aa.aa_feature_id = db.aa_feature_id
          AND pa.source_id = aa.source_id
        UNION
        SELECT DISTINCT ed.name
          , d.*
          , edr.version
          , na.source_id
          , ta.gene_source_id
          , 3 as rank
          , (af.last_residue_index - af.first_residue_index + 1) as hit_length
        FROM sres.dbref d
          LEFT JOIN apidb.AlphaFold af ON d.primary_identifier = af.uniprot_id
          , sres.externaldatabase ed
          , sres.externaldatabaserelease edr
          , dots.dbrefnafeature db
          , dots.nafeature na
          , TranscriptAttributes ta
        WHERE ed.name like '%_dbxref_%niprot_%RSRC'
          AND edr.external_database_id = ed.external_database_id
          AND d.external_database_release_id = edr.external_database_release_id
          AND db.db_ref_id = d.db_ref_id
          AND na.na_feature_id = db.na_feature_id
          AND (ta.transcript_source_id = na.source_id OR ta.gene_source_id = na.source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE minRank AS (
            SELECT gene_source_id
              , MIN(rank) as min_rank
            FROM uniprotGenes&1 upg
            WHERE hit_length is not null
            GROUP BY gene_source_id
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNLOGGED TABLE alphaFoldHits AS (
          SELECT DISTINCT gene_source_id
            , last_value(primary_identifier) over (PARTITION BY gene_source_id ORDER BY hit_length ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS uniprot_id
          FROM (
            SELECT upg.*
            FROM uniprotGenes&1 upg
              , minRank
            WHERE upg.gene_source_id = minRank.gene_source_id
            AND upg.rank = minRank.min_rank
          ) t
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE AlphaFoldGenes&1 AS (
          SELECT afh.gene_source_id
            , af.uniprot_id
            , af.source_id as alphafold_id
            , af.alphafold_version
            , af.first_residue_index
            , af.last_residue_index
          FROM apidb.alphafold af
            , alphaFoldHits afh
          WHERE afh.uniprot_id = af.uniprot_id
        )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE index AlphaFoldGenes_idx&1 ON AlphaFoldGenes&1 (gene_source_id, uniprot_id)                                                                                                

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="IntronSupportLevel" prefixEnabled="true">
    <comment>
      Stores intron support for introns
    </comment>
    <internalDependency name="GeneModelDump"/>
    <internalDependency name="GeneIntronJunction"/>
    <sql>
      <![CDATA[
        create table &prefixIntronSupportLevel&1 as
        SELECT * FROM (
          SELECT gene_source_id, ontology_term, replace(string_value, 'All' , 'Any-high') as string_value
          FROM (
            SELECT gene_source_id
            , ontology_term
            , case when count(*) = intron_count THEN 'All'
                when count(*) = 0 THEN 'None'
                else 'Any' end as string_value
            FROM (
              SELECT gij.gene_source_id
              , 'intron_junction' as ontology_term
              , intronCount.intron_count
              FROM apidbtuning.geneintronjunction gij, ApidbTuning.GeneIntJuncStats stats
              , (select count (*) as intron_count, source_id from apidbtuning.genemodeldump where type = 'Intron' group by source_id) intronCount
              WHERE gij.gene_source_id = intronCount.source_id
              and gij.na_sequence_id = stats.na_sequence_id
              and gij.annotated_intron = 'Yes'
              AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
              AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
              AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
            ) t
            GROUP BY gene_source_id, ontology_term, intron_count
          ) t
          WHERE string_value = 'All'

          UNION

          SELECT gene_source_id
          , ontology_term
          , case when count(*) = intron_count THEN 'All-high'
              when count(*) = 0 THEN 'None'
              else 'Any-high' end as string_value
          FROM (
            SELECT gij.gene_source_id
            , 'intron_junction' as ontology_term
            , intronCount.intron_count
            FROM apidbtuning.geneintronjunction gij, ApidbTuning.GeneIntJuncStats stats
            , (SELECT count (*) as intron_count, source_id FROM apidbtuning.genemodeldump WHERE type = 'Intron' GROUP BY source_id) intronCount
            WHERE gij.gene_source_id = intronCount.source_id
              AND gij.na_sequence_id = stats.na_sequence_id
              AND gij.annotated_intron = 'Yes'
              AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
              AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
              AND (gij.contained = 0 or gij.percent_max >= 2)
          ) t2
          GROUP BY gene_source_id, ontology_term, intron_count

          UNION

          SELECT gene_source_id
          , ontology_term
          , CASE WHEN count(*) = intron_count THEN 'All-low'
              WHEN count(*) = 0 THEN 'None'
              ELSE 'Any-low' END as string_value
          FROM (
            SELECT gij.gene_source_id
            , 'intron_junction' as ontology_term
            , intronCount.intron_count
            FROM apidbtuning.geneintronjunction gij, ApidbTuning.GeneIntJuncStats stats
            , (select count (*) as intron_count, source_id from apidbtuning.genemodeldump where type = 'Intron' group by source_id) intronCount
            WHERE gij.gene_source_id = intronCount.source_id
              AND gij.na_sequence_id = stats.na_sequence_id
              AND gij.annotated_intron = 'Yes'
              AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
              AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
              AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
              AND gij.intron_feature_id not in (
                SELECT gij.intron_feature_id
                FROM ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                WHERE gij.na_sequence_id = stats.na_sequence_id
                  AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                  AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                  AND (gij.contained = 0 or gij.percent_max >= 2)
              )
          ) t3
          GROUP BY gene_source_id, ontology_term, intron_count

          UNION

          SELECT gene_source_id, ontology_term, replace(string_value, 'All' , 'Any-low') as string_value
          FROM (
          SELECT gene_source_id
          , ontology_term
          , case when count(*) = intron_count THEN 'All'
              when count(*) = 0 THEN 'None'
              else 'Any' end as string_value
          FROM (
            SELECT gij.gene_source_id
              , 'intron_junction' as ontology_term
              , intronCount.intron_count
            FROM apidbtuning.geneintronjunction gij, ApidbTuning.GeneIntJuncStats stats
              , (select count (*) as intron_count, source_id from apidbtuning.genemodeldump where type = 'Intron' group by source_id) intronCount
            WHERE gij.gene_source_id = intronCount.source_id
              AND gij.na_sequence_id = stats.na_sequence_id
              AND gij.annotated_intron = 'Yes'
              AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
              AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
              AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
              AND gij.intron_feature_id not in (
                SELECT gij.intron_feature_id
                FROM ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                WHERE gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2)
              )
          ) t
          GROUP BY gene_source_id, ontology_term, intron_count
          ) t4
          WHERE string_value = 'All'
      ) t
]]>
   </sql>
  </tuningTable>

  <tuningTable name="AllGeneProducts" prefixEnabled="true">
    <comment>
      all products for each gene
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GeneProduct"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.GeneFeatureProduct"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>

    <sql>
     <![CDATA[
       create table &prefixAllGeneProducts&1 as
         with evids
            as (select distinct gaiec.go_evidence_code_id, ot.name
                from  dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm ot
                where ot.ontology_term_id = gaiec.go_evidence_code_id)
         select ta.gene_source_id AS source_id, tp.product, ta.project_id,
                CASE tp.is_preferred WHEN 1 THEN 'No' WHEN 0 THEN 'Yes' END as is_alternate,
                string_agg(source_id, ', ' order by source_id) as transcript_ids,
                string_agg(publication, ', ' order by source_id) as reference,
                e.name as evidence_code, tp.with_from as evidence_code_parameter,
                tp.assigned_by, 'apidb.TranscriptProduct' as source
         from TranscriptAttributes ta
            INNER JOIN apidb.TranscriptProduct tp ON ta.na_feature_id = tp.na_feature_id
            LEFT JOIN evids e ON tp.evidence_code = e.go_evidence_code_id
         group by gene_source_id, ta.project_id, tp.product, tp.is_preferred, e.name,
               tp.with_from, tp.assigned_by
       union
         select ga.source_id as source_id, gfp.product, ga.project_id,
                CASE gfp.is_preferred WHEN 1 THEN 'No' WHEN 0 THEN 'Yes' END as is_alternate,
                null as transcript_ids, null as reference, null as evidence_code,
                null as evidence_code_parameter, --gfp.assigned_by,
                -- CHECK AND FIX: OK that apidb.GeneFeatureProduct has NO assigned_by column?
                NULL as assigned_by,
                'apidb.GeneFeatureProduct' as source
         from apidb.GeneFeatureProduct gfp, GeneAttributes ga
         where ga.na_feature_id = gfp.na_feature_id
       union
         select ga.source_id as source_id, gf.product, ga.project_id,
                null as  is_alternate,
                null as transcript_ids, null as reference, null as evidence_code,
                null as evidence_code_parameter, null as assigned_by,
                'dots.GeneFeature' as source
         from dots.GeneFeature gf, GeneAttributes ga, GeneProduct gp
         where ga.na_feature_id = gf.na_feature_id
           and gf.product is not null
           and ga.source_id = gp.source_id
           and gp.source_rule >= 3 -- no product in apidb.GeneFeatureProduct
       union
         select ta.gene_source_id AS source_id, t.product, ta.project_id,
                null as is_alternate,
                string_agg(ta.source_id, ', ' order by ta.source_id) as transcript_ids,
                null as reference, null as evidence_code, null as evidence_code_parameter,
                null as assigned_by, 'dots.Transcript' as source
         from TranscriptAttributes ta, dots.Transcript t
         where ta.na_feature_id = t.na_feature_id
           and t.product is not null
           and ta.gene_source_id
               not in (select source_id
                   from GeneProduct
                   where source_rule < 6) -- product only in dots.Transcript
         group by ta.gene_source_id, ta.project_id, t.product
       union
         select gp.source_id as source_id, gp.product, ga.project_id,
                null as  is_alternate,
                null as transcript_ids, null as reference, null as evidence_code,
                null as evidence_code_parameter, null as assigned_by,
                'unspecified product' as source
         from GeneProduct gp, GeneAttributes ga
         where gp.source_rule = 7
           and gp.source_id = ga.source_id
       order by is_alternate desc, transcript_ids
       ]]>
    </sql>

    <sql>
      <![CDATA[
        create index allGeneProds_idx&1
        on &prefixAllGeneProducts&1 (source_id, product)

      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
