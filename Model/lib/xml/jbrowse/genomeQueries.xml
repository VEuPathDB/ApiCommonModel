<staticQueries>

  <query name="new:Segment">
<![CDATA[
SELECT etn.na_sequence_id srcfeature_id, 
       1 startm, 
       etn.length end, 
       etn.source_id name, 
       'Sequence' type, 
       ' ' atts
FROM   ApidbTuning.GenomicSeqAttributes etn, ApidbTuning.GenomicSequenceId si
WHERE  etn.source_id = si.id 
 and lower(si.id) = lower('$name') 
]]>
  </query>
  
  <query name="get_sequence">
<![CDATA[ 
SELECT ens.sequence 
FROM   DOTS.NASEQUENCE ens 
WHERE  ens.na_sequence_id = $srcfeature_id 
]]>
  </query>
  
  <query name="gene:annotation">
<![CDATA[
 SELECT
       ta.na_feature_id feature_id,
       ta.so_term_name type,
       'annotation' source,
       ta.source_id name,
       '1' phase, 
       '.' score,
       ta.na_sequence_id parent_id,
       fl.start_min startm,
       fl.end_max end,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || substr(ta.gene_product, 1, 400)  || '$dlm' ||
       'soTerm=' || ta.so_term_name || '$dlm' ||
       'geneId=' || ta.gene_source_id || '$dlm' ||
       'gName=' || ta.gene_name || '$dlm' ||
       'Contig=' || ta.sequence_id || '$dlm' ||
       'product=' || substr(ta.gene_product, 1, 400) || decode(ta.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'taxon=' || ta.organism || '$dlm' ||
       'isDeprecated=' || ta.is_deprecated || '$dlm' ||
       'orthomcl_name=' || ta.orthomcl_name || '$dlm' ||
       'isPseudo=' || ta.is_pseudo || '$dlm' ||
       'ProjectId=' || ta.project_id || '$dlm' ||
       'aaSeqId=' || ta.aa_sequence_id ||  '$dlm' || 
       'OrgAbbrev=' || o.public_abbrev atts
FROM
       ApidbTuning.TranscriptAttributes ta,
       apidb.FeatureLocation fl, apidb.organism o
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.feature_type = 'Transcript'
  AND  fl.na_feature_id = ta.na_feature_id
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  ta.taxon_id = o.taxon_id
ORDER BY 
       fl.start_min
]]>
  </query>


<!-- For this query, '%' is added onto the end of goterms to prevent ORA-29275: partial multibyte character. -->
  <query name="gene:annotation2">
<![CDATA[
  SELECT
       ga.name gene_name,
       ga.na_feature_id feature_id,
       'gene' type,
       'annotation' source,
       ga.source_id name,
       '1' phase,
       '.' score,
       ga.na_sequence_id parent_id,
       ga.start_min startm,
       ga.end_max end,
       aid.apolloid apolloid,
       decode (ga.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || substr(ga.product,0,400)  || ';;' ||
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'biotype=' || ga.gene_ebi_biotype || '$dlm' ||
       'geneId=' || ga.source_id || '$dlm' ||
       'gName=' || ga.name || '$dlm' ||
       'Contig=' || ga.sequence_id || '$dlm' ||
       'product=' || substr(ga.product,0,400) || decode(ga.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'taxon=' || ga.organism || '$dlm' ||
       'isDeprecated=' || ga.is_deprecated || '$dlm' ||
       'orthomcl_name=' || ga.orthomcl_name || '$dlm' ||
       'isPseudo=' || ga.is_pseudo || '$dlm' ||
       'ProjectId=' || ga.project_id || '$dlm' ||
       'OrgAbbrev=' || o.public_abbrev atts
FROM
       ApidbTuning.GeneAttributes ga
     , apidb.organism o, apidb.featurelocation fl
     , apidbtuning.apolloid aid
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = ga.na_feature_id
  AND  ga.taxon_id = o.taxon_id
  AND  ga.organism = aid.organism (+)
]]>
  </query>

  <query name="piggyBac:TransposableElement" includeProjects="PlasmoDB,UniDB">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'piggyBac' type, 
       'TransposableElement' source, 
       nas.source_id name, 
       blat.score, 
       blat.target_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM   DoTS.NASequence nas, 
       SRes.ExternalDatabaseRelease edr, 
       SRes.ExternalDatabase ed,
       DoTS.BlatAlignment blat 
WHERE  blat.query_na_sequence_id = nas.na_sequence_id 
   and edr.external_database_release_id = nas.external_database_release_id
   and ed.external_database_id = edr.external_database_id
   and ed.name = 'pfal3D7_PiggyBac_Clones_Adams_clonedInsertEnds_RSRC' 
   and blat.target_start <= $rend 
   and blat.target_end >= $base_start
   and blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
   blat.target_start
]]>
  </query>

    <query name="gsnap:unifiedintronjunction">
       <![CDATA[
                select gij.*, case when gij.annotated_intron = 'Yes' OR (gij.score >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                    AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
                    AND gij.score_exp_ratio >= CASE WHEN contained = 1 THEN stats.min_annot_score_ratio ELSE stats.perc05_score_exp_ratio END
                    ) then 'Strong Evidence' else 'Weak Evidence' end as evidence,
			    CASE 
        			WHEN gij.is_reversed = 0 THEN '+1'
        			WHEN gij.is_reversed = 1 THEN '-1'
        			ELSE '.'
    			    END AS strand
		    FROM ApidbTuning.GeneIntronJunction gij
		    JOIN ApidbTuning.GeneIntJuncStats stats 
		    ON gij.na_sequence_id = stats.na_sequence_id
                where gij.parent_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.parent_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 20
                AND (gij.annotated_intron = 'Yes'
                OR (gij.score >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                    AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                    AND gij.score_exp_ratio >= CASE WHEN contained = 1 THEN stats.min_annot_score_ratio ELSE 5*stats.min_annot_score_ratio END
                    )
                   )
       ]]>
  </query>


    <query name="gsnap:unifiedintronjunctionnew">
       <![CDATA[
                select gij.intron_feature_id as feature_id,gij.na_sequence_id as parent_id, gij.segment_start as startm, gij.segment_end as "end",'$source' as source, gij.contained, gij.matches_gene_strand as matchesgenestrand,
                gij.total_unique as score, gij.total_unique as totalscore, gij.total_isrpm as isrpm, gij.intron_feature_id as name, gij.percent_max as intronpercent,
gij.annotated_intron, gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed, gij.is_reversed as isreversed,
                case when gij.annotated_intron = 'Yes' OR (gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                    AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
                    ) then 'Strong Evidence' else 'Weak Evidence' end as evidence,
                            CASE 
                                WHEN gij.is_reversed = 0 THEN '+1'
                                WHEN gij.is_reversed = 1 THEN '-1'
                                ELSE '.'
                            END AS strand
                    FROM ApidbTuning.GeneIntronJunction gij
                    JOIN ApidbTuning.GeneIntJuncStats stats 
                    ON gij.na_sequence_id = stats.na_sequence_id
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 20
                AND (gij.annotated_intron = 'Yes'
                OR (gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                    AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                    )
                   )
       ]]>
  </query>

    <query name="gsnap:unifiedintronjunctionAnnotatedOnly">
       <![CDATA[
                select gij.intron_feature_id as feature_id,'gsnap' as type, gij.na_sequence_id as parent_id, gij.segment_start as startm, gij.segment_end as "end",'$source' as source, gij.contained, gij.matches_gene_strand as matchesgenestrand,
                gij.total_unique as score, gij.total_unique as totalscore, gij.total_isrpm as isrpm, 'Score='||gij.total_unique||', ISRPM='||gij.total_isrpm as name, gij.percent_max as intronpercent,gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed,
                            CASE 
                                WHEN gij.is_reversed = 0 THEN '+1'
                                WHEN gij.is_reversed = 1 THEN '-1'
                                ELSE '.'
                            END AS strand
                    FROM ApidbTuning.GeneIntronJunction gij
                    JOIN ApidbTuning.GeneIntJuncStats stats 
                    ON gij.na_sequence_id = stats.na_sequence_id
                where gij.na_sequence_id= $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'Yes'
       ]]>
  </query>



    <query name="gsnap:unifiedintronjunctionHCOnly">
       <![CDATA[
                select gij.intron_feature_id as feature_id,'gsnap' as type, gij.na_sequence_id as parent_id, gij.segment_start as startm, gij.segment_end as "end",'$source' as source, gij.contained, gij.matches_gene_strand as matchesgenestrand,
                gij.total_unique as score, gij.total_unique as totalscore, gij.total_isrpm as isrpm, 'Score='||gij.total_unique||', ISRPM='||gij.total_isrpm as name, gij.percent_max as intronpercent,gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed,
                            CASE 
                                WHEN gij.is_reversed = 0 THEN '+1'
                                WHEN gij.is_reversed = 1 THEN '-1'
                                ELSE '.'
                            END AS strand
                    FROM ApidbTuning.GeneIntronJunction gij
                    JOIN ApidbTuning.GeneIntJuncStats stats 
                    ON gij.na_sequence_id = stats.na_sequence_id
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
       ]]>
  </query>



    <query name="gsnap:unifiedintronjunctionLCOnly">
       <![CDATA[
                select gij.intron_feature_id as feature_id,'gsnap' as type, gij.na_sequence_id as parent_id, gij.segment_start as startm, gij.segment_end as "end",'$source' as source, gij.contained, gij.matches_gene_strand as matchesgenestrand,
                gij.total_unique as score, gij.total_unique as totalscore, gij.total_isrpm as isrpm, 'Score='||gij.total_unique||', ISRPM='||gij.total_isrpm as name, gij.percent_max as intronpercent,gij.annotated_intron as annotatedintron, gij.gene_source_id as genesourceid, gij.gene_na_feature_id, 
                gij.is_reversed,
                            CASE 
                                WHEN gij.is_reversed = 0 THEN '+1'
                                WHEN gij.is_reversed = 1 THEN '-1'
                                ELSE '.'
                            END AS strand
                    FROM ApidbTuning.GeneIntronJunction gij
                    JOIN ApidbTuning.GeneIntJuncStats stats 
                    ON gij.na_sequence_id = stats.na_sequence_id
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 20
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                AND gij.intron_feature_id not in (
                select gij.intron_feature_id
                from ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
               )
       ]]>
  </query>


  <query name="alignment:ORFlength">
<![CDATA[
 SELECT na_feature_id feature_id, 
             'alignment' type, 
             '$source' source, 
             feature_source_id name, 
             '' score, 
             na_sequence_id parent_id, 
             start_min startm, 
             end_max end, 
             decode (is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Length=' || (end_max-start_min+1)/3 atts
      FROM   apidb.FeatureLocation 
      WHERE  na_sequence_id = $srcfeature_id 
        AND  start_min <= $rend
        AND  end_max >= $base_start - 1 
        AND  feature_type='Miscellaneous'
        AND  end_max - start_min + 1 >= $$minLength$$
      ORDER BY start_min
]]>
  </query>
  
    <query name="alignment:ORF">
<![CDATA[
 SELECT na_feature_id feature_id, 
             'alignment' type, 
             'ORF' source, 
             feature_source_id name, 
             '' score, 
             na_sequence_id parent_id, 
             start_min startm, 
             end_max end, 
             decode (is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Length=' || (end_max-start_min+1)/3 atts
      FROM   apidb.FeatureLocation 
      WHERE  na_sequence_id = $srcfeature_id 
        AND  start_min <= $rend
        AND  end_max >= $base_start - 1 
        AND  feature_type='Miscellaneous'
      ORDER BY start_min
]]>
  </query>
  
  
  <query name="match:WU_BLASTX">
<![CDATA[
select * from (
SELECT b.similarity_id feature_id, 'match' type, 'WU_BLASTX' source, 
       b.name, b.score, b.pvalue, b.na_sequence_id parent_id, 
       b.startm, b.end, b.strand, b.atts
FROM   
       ApidbTuning.Blastx b
WHERE  
       b.startm between $base_start and $rend and
       b.end between $base_start and $rend and       
       b.na_sequence_id = $srcfeature_id
ORDER BY 
       b.pvalue asc
) where rownum < 4000
]]>
  </query>
  

  <query name="gene:syntenyMC">
<![CDATA[
select feature_id, type, source, name, score, parent_id, startm, end, strand, atts  from (
select
       gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       gattr.source_id name, 
       '.' score, 
       anch_left.synteny_id parent_id,
       apidb.compute_startm (syn.is_reversed, fl.start_min, fl.end_max,
                             anch_left.ref_loc, anch_right.ref_loc,
                             anch_left.syntenic_loc, anch_right.syntenic_loc,
                             syn.b_start, syn.b_end) startm,
       apidb.compute_end (syn.is_reversed, fl.start_min, fl.end_max,
                          anch_left.ref_loc, anch_right.ref_loc,
                          anch_left.syntenic_loc, anch_right.syntenic_loc,
                          syn.b_start, syn.b_end) end,
       CASE WHEN (fl.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'Note=' || substr(gattr.product,0,400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'SyntenyID=' || syn.synteny_id || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'Truncated=' || CASE WHEN fl.end_max > syn.b_end THEN syn.b_end 
                           WHEN fl.start_min < syn.b_start THEN syn.b_start 
                           END || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || gattr.organism atts
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       ApidbTuning.GeneAttributes gattr,
       apidb.FeatureLocation fl,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_left.ref_loc != anch_right.ref_loc
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND fl.na_sequence_id = syn.b_na_sequence_id
  AND fl.feature_type = 'GeneFeature'
  AND gattr.na_feature_id = fl.na_feature_id
  AND gattr.organism = ostr.organism
  AND apidb.compute_startm (syn.is_reversed, fl.start_min, fl.end_max,
                            anch_left.ref_loc, anch_right.ref_loc,
                            anch_left.syntenic_loc, anch_right.syntenic_loc,
                            syn.b_start, syn.b_end) <= $rend
  AND apidb.compute_end (syn.is_reversed, fl.start_min, fl.end_max,
                         anch_left.ref_loc, anch_right.ref_loc,
                         anch_left.syntenic_loc, anch_right.syntenic_loc,
                         syn.b_start, syn.b_end) >= $base_start
  AND fl.start_min <= syn.b_end
  AND fl.end_max >= syn.b_start
) 
WHERE startm <= $rend
  AND end >= $base_start
UNION
SELECT
       syn.synteny_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       b.source_id name, 
       '.' score, 
       syn.synteny_id parent_id, 
       CASE WHEN (anch_left.prev_ref_loc = -9999999999) 
         THEN anch_left.ref_loc
         ELSE $base_start
       END startm,
       CASE WHEN (anch_right.next_ref_loc = 9999999999) 
         THEN anch_right.ref_loc
         ELSE $rend
       END end, 
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'RefStart=' || syn.a_start || '$dlm' ||
       'RefEnd=' || syn.a_end || '$dlm' ||
       'RefContigLength=' || a.length || '$dlm' ||
       'SynStart=' || syn.b_start || '$dlm' ||
       'SynEnd=' || syn.b_end || '$dlm' ||
       'ContigLength=' || b.length || '$dlm' ||
       'Contig=' || b.source_id || '$dlm' ||
       'Chromosome=' || b.chromosome || '$dlm' ||
       'ExtDBName=' || ed.name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || b.organism || '$dlm' ||
       'SynType=' || 'span' ||  '$dlm' ||
       'LeftAnchSyntenicLoc=' || anch_left.syntenic_loc ||  '$dlm' ||
       'RightAnchSyntenicLoc=' || anch_right.syntenic_loc ||  '$dlm' ||
       'LeftAnchRefLoc=' || anch_left.ref_loc ||  '$dlm' ||
       'RightAnchRefLoc=' || anch_right.ref_loc ||  '$dlm' ||
       'LeftAnchPrevRefLoc=' || anch_left.prev_ref_loc ||  '$dlm' ||
       'RightAnchNextRefLoc=' || anch_right.next_ref_loc ||  '$dlm' ||
       'Scale=' || 
          (anch_right.ref_loc - anch_left.ref_loc + 1) / (abs(anch_right.syntenic_loc - anch_left.syntenic_loc) + 1)
         atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      ApidbTuning.GenomicSeqAttributes a,
      ApidbTuning.GenomicSeqAttributes b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed,
      apidbtuning.OrganismSelectTaxonRank ostr
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND b.organism = ostr.organism
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc) > 1 
UNION
-- for: reference organism - gene
SELECT
       gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       gattr.source_id name, 
       '.' score, 
       gattr.na_sequence_id parent_id,
       gattr.start_min startm,
       gattr.end_max end,
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'Note=' || (substr(gattr.product,0,400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' || 
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || gattr.organism atts
FROM 
       ApidbTuning.GeneAttributes gattr,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE gattr.na_sequence_id = $srcfeature_id
  AND start_min <= $rend
  AND end_max >= $base_start
  AND gattr.organism = ostr.organism
UNION
-- for: reference organism - span
SELECT
        na_sequence_id feature_id,
        'gene' type, 
        'syntenyMC' source, 
        source_id name, 
        '.' score, 
        null parent_id,
        round($base_start) startm,
        round($rend) end, 
        1 strand,
       'RefStart=' || $base_start || '$dlm' ||
       'RefEnd=' || $rend || '$dlm' ||
       'RefContigLength=' || length || '$dlm' ||
       'SynStart=' || $base_start || '$dlm' ||
       'SynEnd=' || $rend || '$dlm' ||
       'ContigLength=' || length || '$dlm' ||
        'Contig=' || source_id || '$dlm' ||
        'Chromosome=' || chromosome || '$dlm' ||
        'ExtDBName=' || database_name || '$dlm' ||
        'LeftAnchSyntenicLoc=' || $base_start ||  '$dlm' ||
        'RightAnchSyntenicLoc=' || $rend ||  '$dlm' ||
        'LeftAnchRefLoc=' || $base_start ||  '$dlm' ||
        'RightAnchRefLoc=' || $rend ||  '$dlm' ||
        'SynType=' || 'span' ||  '$dlm' ||
        'Scale=1' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || sa.organism atts
 FROM 
       ApidbTuning.GenomicSeqAttributes sa,
       apidbtuning.OrganismSelectTaxonRank ostr
 WHERE  na_sequence_id = $srcfeature_id 
 AND sa.organism=ostr.organism
]]>
  </query>

  <query name="gene:syntenyJBrowse">
<![CDATA[
-- for: reference organism - gene
SELECT
       'refgene_' || gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyJBrowse' source, 
       gattr.source_id name, 
       '.' score, 
       gattr.na_sequence_id parent_id,
       gattr.start_min startm,
       gattr.end_max end,
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'Note=' || (substr(gattr.product,0,400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' || 
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || gattr.organism ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
FROM 
       ApidbTuning.GeneAttributes gattr,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE gattr.na_sequence_id = $srcfeature_id
  AND start_min <= $rend
  AND end_max >= $base_start
  AND gattr.organism = ostr.organism
UNION
-- for: reference organism - span
SELECT
        'refseq_' || na_sequence_id feature_id,
        'gene' type, 
        'syntenyJBrowse' source, 
        source_id name, 
        '.' score, 
        null parent_id,
        1 startm,
        sa.length end, 
        1 strand,
       'RefStart=' || $base_start || '$dlm' ||
       'RefEnd=' || $rend || '$dlm' ||
       'RefContigLength=' || length || '$dlm' ||
       'SynStart=' || $base_start || '$dlm' ||
       'SynEnd=' || $rend || '$dlm' ||
       'ContigLength=' || length || '$dlm' ||
        'Contig=' || source_id || '$dlm' ||
        'Chromosome=' || chromosome || '$dlm' ||
        'ExtDBName=' || database_name || '$dlm' ||
        'SynType=' || 'span' ||  '$dlm' ||
        'Scale=1' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || sa.organism  ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
 FROM 
       ApidbTuning.GenomicSeqAttributes sa,
       apidbtuning.OrganismSelectTaxonRank ostr
 WHERE  na_sequence_id = $srcfeature_id 
 AND sa.organism=ostr.organism
UNION
-- for syntenic genes
SELECT
       sg.synteny_id || '_syngene_' || gattr.na_feature_id feature_id,
       'gene' type,
       'syntenyJBrowse' source,
       gattr.source_id name,
       '.' score,
       sg.na_sequence_id parent_id,
       sg.start_min startm,
       sg.end_max end,
       decode(sg.is_reversed, 0, +1, 1, -1, +1) strand,
       'Note=' || (substr(gattr.product,0,400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'IsReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' ||
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||
       'Phylum=' || ostr.phylum ||  '$dlm' ||
       'Genus=' || ostr.genus ||  '$dlm' ||
       'Species=' || ostr.species ||  '$dlm' ||
       'Taxon=' || gattr.organism  ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
FROM
       ApiDB.SyntenicGene sg,
       ApidbTuning.GeneAttributes gattr,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE sg.na_sequence_id = $srcfeature_id
  AND sg.start_min <= $rend
  AND sg.end_max >= $base_start
  AND sg.syn_na_feature_id = gattr.na_feature_id
  AND gattr.organism = ostr.organism
UNION
-- for syntenic spans
SELECT
        s.synteny_id || '_synseq_' || sa.na_sequence_id feature_id,
        'gene' type,
        'syntenyJBrowse' source,
        sa.source_id name,
        '.' score,
        null parent_id,
        s.a_start startm,
        s.a_end end,
        decode(s.is_reversed, 0, +1, 1, -1, +1) strand,
       'RefStart=' || s.a_start || '$dlm' ||
       'RefEnd=' || s.a_end || '$dlm' ||
       'RefContigLength=' || to_char(s.a_end-s.a_start+1)  || '$dlm' ||
       'SynStart=' || s.b_start || '$dlm' ||
       'SynEnd=' || s.b_end || '$dlm' ||
       'ContigLength=' || sa.length || '$dlm' ||
        'Contig=' || sa.source_id || '$dlm' ||
        'Chromosome=' || sa.chromosome || '$dlm' ||
        'ExtDBName=' || sa.database_name || '$dlm' ||
        'SynType=' || 'span' ||  '$dlm' ||
        'Scale=1' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||
       'Phylum=' || ostr.phylum ||  '$dlm' ||
       'Genus=' || ostr.genus ||  '$dlm' ||
       'Species=' || ostr.species ||  '$dlm' ||
       'Taxon=' || sa.organism  ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
 FROM
       Apidb.Synteny s,
       ApidbTuning.GenomicSeqAttributes sa,
       apidbtuning.OrganismSelectTaxonRank ostr
 WHERE  s.a_na_sequence_id = $srcfeature_id
 AND s.a_start <= $rend
 AND s.a_end >= $base_start
 AND s.b_na_sequence_id = sa.na_sequence_id
 AND sa.organism=ostr.organism

]]>
  </query>

  <query name="gene:syntenyJBrowseScaled">
<![CDATA[
-- for: reference organism - gene
SELECT
       'refgene_' || gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyJBrowseScaled' source, 
       gattr.source_id name, 
       '.' score, 
       gattr.na_sequence_id parent_id,
       gattr.start_min startm,
       gattr.end_max end,
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'Note=' || substr(gattr.product,0,400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'GeneStart=' || gattr.start_min || '$dlm' ||
       'GeneEnd=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' || 
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || gattr.organism ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
FROM 
       ApidbTuning.GeneAttributes gattr,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE gattr.na_sequence_id = $srcfeature_id
  AND start_min <= $rend
  AND end_max >= $base_start
  AND gattr.organism = ostr.organism
UNION
-- for: reference organism - span
SELECT
        'refseq_' || na_sequence_id feature_id,
        'gene' type, 
        'syntenyJBrowseScaled' source, 
        source_id name, 
        '.' score, 
        null parent_id,
        1 startm,
        sa.length end, 
        1 strand,
       'RefStart=' || $base_start || '$dlm' ||
       'RefEnd=' || $rend || '$dlm' ||
       'RefContigLength=' || length || '$dlm' ||
       'SynStart=' || $base_start || '$dlm' ||
       'SynEnd=' || $rend || '$dlm' ||
       'ContigLength=' || length || '$dlm' ||
        'Contig=' || source_id || '$dlm' ||
        'Chromosome=' || chromosome || '$dlm' ||
        'ExtDBName=' || database_name || '$dlm' ||
        'SynType=' || 'span' ||  '$dlm' ||
        'Scale=1' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||  
       'Phylum=' || ostr.phylum ||  '$dlm' ||  
       'Genus=' || ostr.genus ||  '$dlm' ||  
       'Species=' || ostr.species ||  '$dlm' || 
       'Taxon=' || sa.organism  ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
 FROM 
       ApidbTuning.GenomicSeqAttributes sa,
       apidbtuning.OrganismSelectTaxonRank ostr
 WHERE  na_sequence_id = $srcfeature_id 
 AND sa.organism=ostr.organism
UNION
-- for syntenic genes
select * from (
-- first get all genes in the visible region
with syn_genes as (
select sg.synteny_id
     , ga.start_min syn_gene_start 
     , ga.end_max syn_gene_end
     , ga.na_sequence_id as syn_na_sequence_id
     , ga.na_feature_id as syn_na_feature_id
     , sg.syn_organism_abbrev
     , sg.is_reversed as syn_gene_is_reversed
     , sg.start_min ref_gene_start
     , sg.end_max ref_gene_end
     , sg.na_sequence_id ref_na_sequence_id
from apidb.syntenicgene sg, 
     apidbtuning.geneattributes ga
where sg.na_sequence_id = $srcfeature_id
  AND sg.start_min <=  $$visibleRegionEnd$$
  AND sg.end_max >=  $$visibleRegionStart$$
  AND sg.syn_na_feature_id = ga.na_feature_id
),
-- calc stats for scaling
sscale as (
select synteny_id
     , min(syn_gene_start) syn_min
     , max(syn_gene_end) syn_max
     , max(syn_gene_end) - min(syn_gene_start) + 1 as syn_length
     , min(ref_gene_start) ref_min
     , max(ref_gene_end) ref_max
     , max(ref_gene_end) - min(ref_gene_start) + 1 as ref_length
from syn_genes
group by synteny_id),
-- calc gene coords in ref space
scaled_syngenes as (
select sg.syn_na_sequence_id
     , sg.syn_na_feature_id
     , sg.syn_organism_abbrev
     , sg.synteny_id
     , CASE WHEN s.is_reversed = 1 
            THEN round(ref_max - (((syn_gene_end - syn_min + 1) / syn_length) * ref_length))
            ELSE round(ref_min + (((syn_gene_start - syn_min + 1) / syn_length) * ref_length)) 
        END as s
     , CASE WHEN s.is_reversed = 1 
            THEN round(ref_max - (((syn_gene_start - syn_min + 1) / syn_length) * ref_length))
            ELSE round(ref_min + (((syn_gene_end - syn_min + 1) / syn_length) * ref_length))
        END as e
     , sg.syn_gene_is_reversed
     , ref_na_sequence_id
from syn_genes sg,
     sscale ss,
     apidb.synteny s
where sg.synteny_id = s.synteny_id
 and ss.synteny_id = s.synteny_id
)
SELECT
       sg.synteny_id || '_syngene_' || gattr.na_feature_id feature_id,
       'gene' type,
       'syntenyJBrowseScaled' source,
       gattr.source_id name,
       '.' score,
       sg.ref_na_sequence_id parent_id,
       sg.s startm, 
       sg.e end,
       decode(sg.syn_gene_is_reversed, 0, +1, 1, -1, +1) strand,
      'Note=' || substr(gattr.product, 0, 400) || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'GeneStart=' || gattr.start_min || '$dlm' ||
       'GeneEnd=' || gattr.end_max || '$dlm' ||
       'IsReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'gene' ||  '$dlm' ||
       'orthomcl_name=' || gattr.orthomcl_name || '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||
       'Phylum=' || ostr.phylum ||  '$dlm' ||
       'Genus=' || ostr.genus ||  '$dlm' ||
       'Species=' || ostr.species ||  '$dlm' ||
       'Taxon=' || gattr.organism  ||  '$dlm' ||
       'OrgAbbrev=' || ostr.public_abbrev atts
FROM   scaled_syngenes sg,
       ApidbTuning.GeneAttributes gattr,
       apidbtuning.OrganismSelectTaxonRank ostr
WHERE sg.ref_na_sequence_id = $srcfeature_id
  AND sg.s <= $rend
  AND sg.e >= $base_start
  AND sg.syn_na_feature_id = gattr.na_feature_id
  AND gattr.organism = ostr.organism 
)
UNION
-- for syntenic spans
SELECT
        s.synteny_id || '_synseq_' || sa.na_sequence_id feature_id,
        'gene' type,
        'syntenyJBrowseScaled' source,
        sa.source_id name,
        '.' score,
        null parent_id,
        s.a_start startm,
        s.a_end end,
        decode(s.is_reversed, 0, +1, 1, -1, +1) strand,
       'RefStart=' || s.a_start || '$dlm' ||
       'RefEnd=' || s.a_end || '$dlm' ||
       'RefContigLength=' || to_char(s.a_end-s.a_start+1)  || '$dlm' ||
       'SynStart=' || s.b_start || '$dlm' ||
       'SynEnd=' || s.b_end || '$dlm' ||
       'ContigLength=' || sa.length || '$dlm' ||
        'Contig=' || sa.source_id || '$dlm' ||
        'Chromosome=' || sa.chromosome || '$dlm' ||
        'ExtDBName=' || sa.database_name || '$dlm' ||
        'SynType=' || 'span' ||  '$dlm' ||
        'Scale=1' ||  '$dlm' ||
       'Kingdom=' || ostr.kingdom ||  '$dlm' ||
       'Class=' || ostr.class ||  '$dlm' ||
       'Phylum=' || ostr.phylum ||  '$dlm' ||
       'Genus=' || ostr.genus ||  '$dlm' ||
       'Species=' || ostr.species ||  '$dlm' ||
       'Taxon=' || sa.organism  ||  '$dlm' || 
       'OrgAbbrev=' || ostr.public_abbrev atts
 FROM
       Apidb.Synteny s,
       ApidbTuning.GenomicSeqAttributes sa,
       apidbtuning.OrganismSelectTaxonRank ostr
 WHERE  s.a_na_sequence_id = $srcfeature_id
 AND s.a_start <= $rend
 AND s.a_end >= $base_start
 AND s.b_na_sequence_id = sa.na_sequence_id
 AND sa.organism=ostr.organism

]]>
  </query>

  <query name="lowcomplexity:dust">
<![CDATA[
SELECT
       lc.na_feature_id feature_id,
       'lowcomplexity' type, 
       'dust' source, 
       lc.name name, 
       '.' score, 
       lc.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM 
       apidb.FeatureLocation fl, dots.LowComplexityNAFeature lc
WHERE
       fl.feature_type = 'LowComplexityNAFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id and
       fl.na_feature_id = lc.na_feature_id
ORDER BY 
       fl.start_min
]]>
  </query>
  
  
  <query name="MicroArrayProbes:expressionH"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
SELECT $srcfeature_id as feature_id,
       'MicroArrayProbes' as type, 
       '$source'       as source,
       $srcfeature_id as parent_id,
       $base_start       as startm,
       $rend             as end 
FROM   dual 
       ]]>
  </query>

  <query name="cnv:ArrayJBrowse"  includeProjects="TriTrypDB,UniDB">
       <![CDATA[
select ri.reporter_intensity_id as feature_id
     , 'cnv' as type
     , 'ArrayJBrowse' as source
     , ri.value as score
     , pan.name as parent_id
     , rl.reporter_start startm
     , rl.reporter_end end
from results.reporterintensity ri
   , platform.reporterlocation rl
   , study.protocolappnode pan
where ri.PROTOCOL_APP_NODE_ID = pan.protocol_app_node_id
and ri.reporter_id = rl.reporter_id
and pan.name = '$$sample$$'
AND rl.na_sequence_id = $srcfeature_id
AND rl.reporter_start <= $rend
AND rl.reporter_end >= $base_start
       ]]>
  </query> 


  <query name="MicroArrayProbes:expressionProbes" includeProjects="PlasmoDB,ToxoDB,TriTrypDB,VectorBase,UniDB">
<![CDATA[
SELECT rl.reporter_location_id as feature_id,
       'MicroArrayProbes' type, 
       '$source' source, 
       rl.na_sequence_id parent_id, 
       rl.reporter_start startm, 
       rl.reporter_end end, 
       decode (rl.on_reverse_strand, 0, '+1', 1, '-1', '.') strand,
       'SourceId='   || r.source_id || '$dlm'
        AS atts
FROM   platform.reporter r, PLATFORM.reporterLocation rl, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
WHERE  edr.external_database_id = ed.external_database_id
  AND  edr.external_database_release_id=r.external_database_release_id
  and r.reporter_id = rl.reporter_id
  AND  ed.NAME = $$edname$$
  AND  rl.reporter_start <= $rend
  AND  rl.reporter_end >= $base_start
  AND  rl.na_sequence_id = $srcfeature_id


       ]]>
  </query> 

  <query name="MicroArrayProbes:expressionD" includeProjects="PlasmoDB,ToxoDB,TriTrypDB,UniDB">
<![CDATA[
SELECT fl.na_feature_id as feature_id,
       'MicroArrayProbes' type, 
       '$source' source, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SourceId='   || fl.feature_source_id || '$dlm'
        as atts
FROM   apidb.FeatureLocation fl, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
WHERE  edr.external_database_id = ed.external_database_id
  AND  edr.external_database_release_id=fl.external_database_release_id
  AND  fl.feature_type = 'ArrayElementFeature'
  AND  ed.name = $$edname$$
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_sequence_id = $srcfeature_id]]>
  </query>

      <query name="splice:curated" includeProjects="TriTrypDB,UniDB">
<![CDATA[
SELECT 
       ra.nextgenseq_align_id feature_id,
       'splice' type,
       'curated' source,
       ra.na_sequence_id as parent_id, 
       CASE WHEN ra.strand = '+' THEN ra.end_a + 1 ELSE ra.start_a - 1 END as startm, 
       CASE WHEN ra.strand = '+' THEN ra.end_a + 1 ELSE ra.start_a - 1 END as end, 
       ra.query_id as name, ra.strand||'1' as strand, 
       'genome_matches=' || ra.genome_matches || '$dlm' ||
       'count='|| ra.intron_size || '$dlm' ||
       'utr_length='|| ra.end_b || '$dlm' || 
       'sample='|| ra.sample || '$dlm' || 
       'gene_id=' || REGEXP_REPLACE(ra.query_id,'(\-\d+\-?\*?\(\))','') atts
FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
 AND  rel.external_database_id = rel.external_database_id
 AND  ra.external_database_release_id = rel.external_database_release_id
 AND  ra.na_sequence_id = $srcfeature_id
 AND  ra.sample = 'curated_long_splice'
 AND  ra.start_a >= $base_start 
 AND  ra.end_a <= $rend
]]>
  </query>

      <query name="polya:curated" includeProjects="TriTrypDB,UniDB">
<![CDATA[
SELECT 
       ra.nextgenseq_align_id feature_id,
       'polya' type,
       'curated' source,
       ra.na_sequence_id as parent_id, 
       CASE WHEN ra.strand = '+' THEN ra.start_a - 1 ELSE ra.end_a + 1 END as startm, 
       CASE WHEN ra.strand = '+' THEN ra.start_a - 1 ELSE ra.end_a + 1 END as end, 
       ra.query_id as name, ra.strand||'1' as strand, 
       'genome_matches=1' || '$dlm' ||
       'count='|| ra.intron_size || '$dlm' ||
       'utr_length='|| ra.end_b || '$dlm' || 
       'sample='|| ra.sample || '$dlm' || 
       'gene_id=' || REGEXP_REPLACE(ra.query_id,'(\-\d+\-?\*?\(\))','') atts
FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
 AND  rel.external_database_id = rel.external_database_id
 AND  ra.external_database_release_id = rel.external_database_release_id
 AND  ra.na_sequence_id = $srcfeature_id
 AND  ra.sample = 'curated_long_polyA'
 AND  ra.start_a >= $base_start 
 AND  ra.end_a <= $rend
]]>
  </query>

      <query name="splice:alignseq" includeProjects="TriTrypDB,UniDB">
<![CDATA[
SELECT min(feature_id) as feature_id, parent_id, startm, startm as end,
        'splice' type, 'alignseq' source,
        CASE WHEN strand = '+1' THEN substr(max(name),3,length(max(name))-2) 
          ELSE substr(max(name),0,length(max(name))-2) END as name, 
        strand,
        'genome_matches='||min(genome_matches) || '$dlm' ||
        'sample='||sample || '$dlm' ||
        'count='||count(*) atts
FROM
  (SELECT ra.nextgenseq_align_id feature_id,
         ra.na_sequence_id as parent_id, 
         CASE WHEN strand = '+' THEN ra.start_a + 2 ELSE ra.end_a - 2 END as startm, 
         ra.query_id name, ra.strand||'1' as strand,
         ra.genome_matches,ra.sample
  FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
  WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
   AND  rel.external_database_id = rel.external_database_id
   AND  ra.external_database_release_id = rel.external_database_release_id
   AND  ra.na_sequence_id = $srcfeature_id
   AND  ra.sample = 'raw_splice'
   AND  ra.start_a >= $base_start
   AND  ra.end_a <= $rend )
GROUP BY parent_id,sample,strand,startm
]]>
  </query>

      <query name="polya:alignseq" includeProjects="TriTrypDB,UniDB">
<![CDATA[
SELECT min(feature_id) as feature_id, parent_id, startm, startm as end,
        'polya' type, 'alignseq' source,
        max(name) as name, 
        strand,
        'genome_matches='||min(genome_matches) || '$dlm' ||
        'count='||count(*) atts
FROM
  (SELECT ra.nextgenseq_align_id feature_id, 
         ra.na_sequence_id as parent_id, 
         CASE WHEN strand = '+' THEN ra.end_a ELSE ra.start_a END as startm, 
         ra.query_id name, ra.strand||'1' as strand,
         ra.genome_matches
  FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
  WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
   AND  rel.external_database_id = rel.external_database_id
   AND  ra.external_database_release_id = rel.external_database_release_id
   AND  ra.sample = 'raw_polyA'
   AND  ra.start_a >= $base_start
   AND  ra.end_a <= $rend)
GROUP BY parent_id,strand,startm
]]>
  </query>

  <query name="domain:spliceSites" includeProjects="TriTrypDB,FungiDB,UniDB">
<![CDATA[
SELECT distinct ssf.segment_start as  feature_id, 'domain' type,   '$source' as source,  
       ssf.segment_start as startm, ssf.segment_start as end,
       decode (ssf.strand,'+','1','-','0',null) strand,
       CASE WHEN gtable.source_id is null THEN  ssf.segment_start || '(' || count(pan.name)  || ')'
            ELSE  gtable.source_id || '(' || count(pan.name)  || ')' END AS name,  
        gtable.source_id as gene_id, gtable.utr_len as utr_length, gtable.dist_to_first_atg,
       'sample_name=' || listagg( replace(pan.name, ' [feature_loc] (SpliceSites)') , ',' on overflow truncate) within group (order by pan.name) || '$dlm' ||
       'count_per_mill=' || listagg(ssf.count_per_million, ',' on overflow truncate) within group (order by pan.name) || '$dlm' ||
       'is_unique=' || listagg(ssf.is_unique, ',' on overflow truncate) within group (order by pan.name)  || '$dlm' ||
       'avg_mismatches=' || listagg(ssf.avg_mismatches, ',' on overflow truncate) within group (order by ssf.avg_mismatches)  || '$dlm' ||
       'gene_id=' || gtable.source_id || '$dlm' ||
       'type=' || ssf.type || '$dlm' ||
       'utr_length=' || gtable.utr_len    atts
 FROM 
   study.study i, study.study s, study.studylink sl,
   study.protocolAppNode pan, apidb.spliceSiteFeature ssf
 JOIN (SELECT gene_source_id as source_id , na_sequence_id, type, location, strand,
          dist_to_first_atg, dist_to_cds AS utr_len
   FROM apidbtuning.splicesitetranscripts
   WHERE na_sequence_id = $srcfeature_id
   AND location >= $base_start
   AND location <= $rend
   ) gtable
  ON (ssf.NA_SEQUENCE_ID = gtable.NA_SEQUENCE_ID AND ssf.type = gtable.type AND ssf.strand=gtable.strand and gtable.location=ssf.segment_start)  
 WHERE ssf.na_sequence_id =  $srcfeature_id
   AND ssf.segment_start >=  $base_start
   AND ssf.segment_end <= $rend
   AND ssf.type = $$featType$$
   AND pan.protocol_app_NODE_ID = ssf.protocol_app_node_id
   AND pan.protocol_app_node_id = sl.protocol_app_node_id
   and sl.study_id = s.study_id
   and s.name like '%[feature_loc]'
   and s.investigation_id = i.study_id
   and i.name like  $$edName$$
   and ssf.count_per_million > $$minCntPerMill$$
  GROUP BY  ssf.segment_start, ssf.strand, gtable.source_id,gtable.utr_len, gtable.dist_to_first_atg, ssf.type
  order by  ssf.segment_start
]]>
  </query>

  <query name="domain:polyASites" includeProjects="TriTrypDB,UniDB">
<![CDATA[
SELECT 
       splice_site_feature_id feature_id,
       'domain' type,
       '$source' as source,
       location as startm, location as end, 
       CASE WHEN (source_id IS NULL) THEN ' (' || count_per_million || ')'
           WHEN (utr_len >0) THEN  source_id || '-' ||  utr_len || '(' || count_per_million || ')'
            ELSE  source_id || '-' ||  'within gene' || '(' || count_per_million || ')' END AS name, 
       strand as strand, 
       'sample_name='|| sample_name || '$dlm' ||
       'count_per_mill='|| count_per_million || '$dlm' ||
       'is_unique='|| is_unique || '$dlm' || 
       'is_dominant='|| is_dominant || '$dlm' || 
       'avg_mismatches='|| avg_mismatches || '$dlm' || 
       'gene_id='|| source_id || ';;' || 
       'utr_length='|| utr_len atts
FROM (
 SELECT 
       distinct ssf.splice_site_feature_id, ssf.location, ssf.strand,
       ssf.sample_name, ssf.count_per_million, ssf.is_unique, ssf.avg_mismatches,
       gtable.source_id, gtable.utr_len, gtable.is_dominant FROM  apidb.spliceSiteFeature ssf
 LEFT JOIN (SELECT source_id , sample_name, location, strand, is_dominant, count,
          CASE WHEN (within_cds=1) THEN (-1)*dist_to_cds ELSE dist_to_cds END AS utr_len
         FROM APIDB.polyagenes
   WHERE na_sequence_id = $srcfeature_id
   AND location >= $base_start
   AND location <= $rend
   ) gtable
  ON (ssf.sample_name = gtable.sample_name AND ssf.location = gtable.location AND ssf.strand=gtable.strand)
 WHERE ssf.na_sequence_id = $srcfeature_id
   AND ssf.location >= $base_start
   AND ssf.location <= $rend
   AND ssf.sample_name $$sample$$
   AND ssf.external_database_release_id in
     (SELECT external_database_release_id 
        FROM sres.externaldatabase ed, sres.externalDatabaseRelease edr
       WHERE ed.external_database_id = edr.external_database_id
         AND ed.name $$edName$$ )
   AND NOT (gtable.count=1 AND gtable.is_dominant is null)
   )
]]>
  </query>

  <query name="domain:MassSpecPeptide">
<![CDATA[
select * from (
select feature_id, type, source, parent_id, min(startm) as startm, max(end) as end, name, atts from (
select msps.peptide_aa_feature_id as feature_id,
       'domain' type,
       '$source' source,
       fl.na_sequence_id as Parent_Id, 
       fl.start_min as startm, 
       fl.end_max as end,
       msps.sample_display_name||'_'||msps.aa_sequence_id||'_'||msps.aa_start_min||'_'||msps.aa_end_max  as name, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Count=' || msps.spectrum_count || '$dlm' ||
       'ExtDbName=' || msps.external_database_name || '$dlm' ||
       'Experiment=' || msps.experiment  || '$dlm' ||
       'Sample=' || msps.sample_display_name  || '$dlm' ||
       'PepSeq=' || msps.peptide_sequence || '$dlm' ||
       'Color=' || msps.html_Color Atts
from apidb.FeatureLocation fl
   , apidbtuning.mspeptidesummary msps
where msps.peptide_na_feature_id = fl.na_feature_id
and fl.na_sequence_id = $srcfeature_id
and fl.start_min >= $base_start
and fl.end_max <= $rend
and msps.external_database_name $$edName$$
)
group by feature_id, type, source, parent_id, name, atts
 ) order by feature_id asc
]]>
  </query>

  <query name="domain:UnifiedMassSpecPeptides">
<![CDATA[
select feature_id, type, source, parent_id, min(startm) as startm, max(end) as end, name, atts from (
select msf.aa_feature_id as feature_id,
       'domain' type,
        'UnifiedMassSpecPeptides' source,
       fl.na_sequence_id as Parent_Id, 
       fl.start_min as startm, 
       fl.end_max as end,
       sdi.sample||'_'||msf.aa_sequence_id||'_'||aaloc.start_min||'_'||aaloc.end_max  as name, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Count=' || msf.spectrum_count || '$dlm' ||
       'ExtDbName=' || d.name || '$dlm' ||
       'Experiment=' || dsp.display_name  || '$dlm' ||
       'Sample=' || sdi.sample_display_name  || '$dlm' ||
       'PepSeq=' || dbms_lob.SUBSTR(aaseq.SEQUENCE, aaloc.end_max - aaloc.start_min + 1, aaloc.start_min) || '$dlm' ||
       'Color=' || sdi.html_Color Atts
from dots.massspecfeature msf
   , apidb.FeatureLocation fl
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
   , APIDB.MASSSPECSUMMARY mss
   , study.protocolappnode pan
   , apidbtuning.sampledisplayinfo sdi
   , apidbtuning.datasetdatasource dd
   , apidbtuning.datasetpresenter dsp
   , dots.aasequence aaseq
   , dots.aalocation aaloc
where msf.na_feature_id = fl.na_feature_id
and msf.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and fl.na_sequence_id = $srcfeature_id
and fl.start_min >= $base_start
and fl.end_max <= $rend
and msf.MASS_SPEC_SUMMARY_ID = mss.MASS_SPEC_SUMMARY_ID
and d.name = sdi.DATASET_NAME
and mss.PROTOCOL_APP_NODE_ID = pan.PROTOCOL_APP_NODE_ID
and (pan.name in (sdi.sample, sdi.sample || ' (MS Summary)') or sdi.sample is null)
and d.name = dd.NAME
and dd.DATASET_PRESENTER_ID = dsp.DATASET_PRESENTER_ID
and msf.AA_SEQUENCE_ID = aaseq.aa_sequence_id
and msf.AA_FEATURE_ID = aaloc.aa_feature_id
)
group by feature_id, type, source, parent_id, name, atts
]]>
  </query>
  
  <query name="UnifiedMassSpecPeptides:density">
<![CDATA[
SELECT etn.na_sequence_id feature_id,
       'UnifiedMassSpecPeptides' type,
       'density' source
FROM   dots.NASEQUENCE etn
WHERE  etn.na_sequence_id = $srcfeature_id
]]>
  </query>

  
<query name="alignment:TransposableElements" includeProjects="TrichDB,UniDB">
<![CDATA[
select l.na_feature_id as feature_id
     , 'alignment' as type
     , '$source' as source
     , f.source_id as name
     , l.na_sequence_id as parent_id
     , l.start_min as startm
     , l.end_max as end
     ,'alignLength=' || ( l.end_max - l.start_min + 1) || '$dlm' ||
      'sequence_id=' || l.sequence_source_id || '$dlm' ||
      'te_name=' || f.name atts
from apidb.FeatureLocation l
   , dots.transposableelement f
where l.na_feature_id = f.na_feature_id
and l.na_sequence_id = $srcfeature_id 
and l.start_min >= $base_start - 1 
and l.end_max <= $rend
]]>
  </query>

  <query name="alignment:GenericEndFeature">
<![CDATA[
select * from (
select f.feature_id, 
f.type, 
f.source, 
f.feature_id name, 
f.parent_id, 
f.startm, 
f.end,
--'sequence=' || substr(s.sequence, f.startm, f.end - f.startm + 1) || '$dlm' ||
'alignLength=' || ( f.end - f.startm + 1) atts
from  (
SELECT gef.feature_id, 
       'alignment' type, 
       '$source' source,
       max(gef.query_na_sequence_id) parent_id, 
       min(gef.target_start) startm, 
       max(gef.target_end) end,
       max(gef.target_na_sequence_id) as query_na_sequence_id
FROM (
SELECT regexp_substr(blat.$$sourceIdField$$, $$sourceIdRegex$$) as feature_id,
       blat.query_na_sequence_id, blat.target_start, blat.target_end,
       blat.target_na_sequence_id
FROM apidbtuning.GenericEndFeature blat
WHERE blat.target_na_sequence_id = $srcfeature_id 
AND (blat.target_end - blat.target_start ) < $$spanLengthCutoff$$
AND ('true' = $$includeMultipleSpans$$ OR blat.number_of_spans =1)
AND blat.name in ($$edName$$)
) gef
GROUP BY gef.feature_id
) f
)
where (startm >= $base_start  -1 and startm <= $rend )
   OR (end <= $rend and end >= $base_start - 1)
   OR (startm < $base_start - 1 and end > $rend)
]]>
  </query>


  <query name="annotation:density">
<![CDATA[
SELECT etn.na_sequence_id feature_id, 
       'annotation' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
  </query>
  
  <query name = "ORF:density"> 
<![CDATA[ 
SELECT etn.na_sequence_id feature_id, 
       'ORF' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
  </query>
  
  <query name="Centromere:overview"  includeProjects="PlasmoDB,ToxoDB,TriTrypDB,UniDB">
<![CDATA[
SELECT fl.na_sequence_id feature_id,
       'Centromere' type,
       'overview' source,
       start_min startm,
       end_max end
FROM  apidb.FeatureLocation fl, sres.ontologyTerm ot  
WHERE fl.na_sequence_id = $srcfeature_id
  AND ot.ontology_term_id = fl.sequence_ontology_id 
  AND ot.name='centromere'    
]]> 
  </query>

  <query name="repeat:RepeatElements">
<![CDATA[
SELECT rpt.na_feature_id feature_id,
       'repeat' type,
       '$source' source,
       rpt.parent_id, 
       fl.start_min startm, 
       fl.end_max end,
       rpt.source_id name, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Family=' || rpt.rpt_family || '$dlm' ||
       'edName=' || d.name atts
FROM   dots.Repeats rpt,
       apidb.FeatureLocation fl,
       sres.externaldatabase d,
       sres.externaldatabaserelease rel
WHERE  fl.na_sequence_id = $srcfeature_id
     and rpt.na_feature_id = fl.na_feature_id 
       and rel.external_database_release_id = rpt.external_database_release_id 
       and d.external_database_id  = rel.external_database_id 
       AND fl.start_min <= $rend
       AND fl.end_max >= $base_start
ORDER BY 
       fl.start_min
]]>
  </query>
 
  <query name="TandemRepeat:TRF">
<![CDATA[
 SELECT
       fl.na_feature_id feature_id,
       'TandemRepeat' type, 
       'TRF' source, 
       tr.name name, 
       '.' score, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM 
       dots.NaFeature tr,
       apidb.FeatureLocation fl
WHERE
       tr.na_feature_id = fl.na_feature_id and
       fl.feature_type = 'TandemRepeatFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id
ORDER BY 
       fl.start_min
]]>
  </query>

  <query name="feature:BindingSite">
<![CDATA[
 SELECT
       fl.na_feature_id feature_id,
       'feature' type, 
       'BindingSite' source, 
       BS.name name, 
       '.' score, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Name=' || BS.name || '$dlm' ||       
       'Sequence=' || case when fl.is_reversed =0 then substr(s.sequence, fl.start_min, fl.end_max - fl.start_min + 1) 
       else APIDB.REVERSE_COMPLEMENT_CLOB(substr(s.sequence, fl.start_min, fl.end_max - fl.start_min + 1)) end || '$dlm' ||
       'Score=' || to_char(exp(BS.primary_score),'9.99EEEE') as atts
FROM 
       dots.BindingSiteFeature BS,
       apidb.FeatureLocation fl,
       dots.nasequence s,
       sres.externaldatabase d,
       sres.externaldatabaserelease rel
WHERE
       fl.na_sequence_id = s.na_sequence_id and
       BS.na_feature_id = fl.na_feature_id and
       rel.external_database_release_id = BS.external_database_release_id and
       d.external_database_id  = rel.external_database_id and
       d.name like '%_genomeFeature_Llinas_TransFactorBindingSites%' and
       fl.feature_type = 'BindingSiteFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id
ORDER BY 
       fl.start_min
]]>
  </query>
 
  <query name="repeat_region:Genbank" includeProjects="TrichDB,UniDB">
<![CDATA[ 
SELECT gf.na_feature_id feature_id,
       'repeat_region' type, 
       'Genbank' source, 
       gf.source_id name, 
       gf.na_sequence_id parent_id, 
       ga.start_min startm, 
       ga.end_max end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || substr(ga.product, 1, 400)  || '$dlm' ||
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'product=' || substr(ga.product, 1, 400) || '$dlm' ||
       'taxon=' || ga.organism || '$dlm' ||
       'isPseudo=' || ga.is_pseudo
         as atts
FROM   dots.GENEFEATURE gf, 
       dots.NALOCATION nal,
       ApidbTuning.GeneAttributes ga 
WHERE  ga.so_term_name = 'repeat_region'
   AND nal.na_feature_id = gf.na_feature_id
   AND ga.start_min <= $rend 
   AND ga.end_max >= $base_start 
   AND gf.source_id = ga.source_id
   AND gf.na_sequence_id = $srcfeature_id 
]]>
  </query>    
  
  <query name="alignment:dbEST">
<![CDATA[
 SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'dbEST' source, 
       est.accession name, 
       blat.score || '' score, 
       blat.query_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'PercentIdentity=' || blat.percent_identity  || '$dlm' ||
       'Library=' || l.dbest_name  || '$dlm' atts 
FROM   
       dots.BlatAlignment blat, 
       dots.Est est, 
       dots.ExternalNASequence estseq,
       dots.Library l,
       sres.OntologyTerm ot
WHERE  
       blat.query_na_sequence_id = est.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       est.library_id = l.library_id and
       estseq.na_sequence_id = est.na_sequence_id and
       ot.ontology_term_id = estseq.sequence_ontology_id and
       ot.name = 'EST' and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
  </query>
  
  <query name="Microsatellite:sts" includeProjects="PlasmoDB,UniDB">
<![CDATA[
 SELECT S.na_feature_id as feature_id,
       'Microsatellite' type, 
       'sts' source, 
       s.source_id name, 
       s.na_sequence_id parent_id, 
       l.start_min startm, 
       l.end_max end, 
       decode (l.is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Name=' || s.name  || '$dlm' || 'SequenceId=' || nas.source_id  atts
      FROM   DoTS.STS s, SRes.ontologyTerm ot,
             apidb.FeatureLocation l, DOTS.NASequence nas
      WHERE  s.na_sequence_id = $srcfeature_id 
        AND  l.start_min <= $rend
        AND  l.end_max >= $base_start
        AND  s.na_feature_id = l.na_feature_id 
        AND  nas.na_sequence_id = s.na_sequence_id
        AND  s.sequence_ontology_id = ot.ontology_term_id
        AND ot.name = 'microsatellite'
]]>
  </query>
  
  <query name="Haplotype:Block">
<![CDATA[
SELECT  cef.na_feature_id feature_id,
       'Haplotype' type, 
       'Block' source, 
       cef.source_id name, 
       '.' score, 
       cef.na_sequence_id parent_id, 
       nl.start_min startm, 
       nl.end_max end, 
       'Boundary=' || 'Liberal'  || '$dlm' ||'Name=' || cef.name  || '$dlm' || 'SequenceId=' || ens.source_id  || '$dlm' || 'start_max=' || nl.start_max || '$dlm' ||'end_min=' || nl.end_min || '$dlm' || 'start_min=' || nl.start_min || '$dlm' || 'end_max=' || nl.end_max as atts
FROM DoTS.ChromosomeElementFeature cef, Dots.NaLocation nl, DoTS.ExternalNASequence ens
         WHERE  cef.na_sequence_id = $srcfeature_id 
         AND    cef.na_feature_id = nl.na_feature_id 
         AND    ens.na_sequence_id = cef.na_sequence_id
         AND    nl.start_min <= $rend
         AND    nl.end_max >= $base_start
]]>
  </query>
 
  <query name="match:IsolatePopset">
<![CDATA[
SELECT distinct sim.similarity_id feature_id, 
       'match' type, 
       'IsolatePopset' source, 
       extq.source_id name, 
       sim.score,
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue, 
       extt.na_sequence_id parent_id, 
       sim.min_subject_start startm, 
       sim.max_subject_end end, 
       decode (sim.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||'$dlm'|| 
       'MatchLen=' || sim.total_match_length || '$dlm' ||
       'Note=' || pan.description atts
FROM   
       dots.Similarity sim, 
       dots.ExternalNASequence extt, dots.NASequence extq,
       sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
       results.segmentResult sr, study.protocolAppNode pan
WHERE  
       extq.external_database_release_id = edr.external_database_release_id and
       ed.external_database_id = edr.external_database_id and
       (   ed.name in ('C. parvum isolate data', 'Toxoplasma isolates From David Sibley','Toxoplasma isolates From Genbank') 
        or ed.name like '%_isolates_genbank_RSRC') and
       sim.query_id = extq.na_sequence_id and 
       sim.subject_id = extt.na_sequence_id and 
       sim.pvalue_mant is not null and
       sim.pvalue_exp is not null and
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) < 1e-20 and 
       sim.min_subject_start >= $base_start and 
       sim.max_subject_end <= $rend and
       extt.na_sequence_id = $srcfeature_id and
       extq.source_id = pan.source_id and
       pan.protocol_app_node_id = sr.protocol_app_node_id
ORDER BY 
       sim.min_subject_start asc, 
       sim.max_subject_end asc, 
       pvalue asc
]]>
  </query>


  <query name="scaffold:genome">
<![CDATA[
select sgf.na_feature_id as feature_id,
     'scaffold' type,
     'genome' source,     
      'gap' as name,
      nal.start_min as startm,
      nal.end_max as end,
      '0' strand,
      'Length=' || (nal.end_max-nal.start_min+1) || '$dlm' ||
      'Type=' ||  'gap'  || '$dlm' ||
      'Note=' ||  ''  atts
from DOTS.scaffoldgapfeature sgf, dots.nalocation nal
where nal.na_feature_id = sgf.na_feature_id
and sgf.na_sequence_id = $srcfeature_id
UNION
select p.agp_piece_id as feature_id, 
     'scaffold' type,
     'genome' source,
      p.piece_id name,
      p.start_min as startm,
      p.end_max as end,
      decode(p.is_reversed, '0', '+1', '1', '-1', '0') strand,
      'Length=' || (p.end_max - p.start_min + 1) || '$dlm' ||
      'Type=scaffold' ||'$dlm' ||
      'Note=' || p.piece_id atts
from apidbtuning.genomicseqattributes gsa, apidb.agpPiece p
where gsa.source_id = p.source_id
and not p.piece_id is null
and gsa.na_sequence_id = $srcfeature_id
]]>
  </query>


  <query name="gene:AlternateModels">
<![CDATA[
SELECT
       gf.na_feature_id feature_id,
       'gene' type, 
       '$source' source, 
       gf.source_id name, 
       '.' score, 
       gf.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       ed.name||':'||edr.version external_database_name,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || gf.product  || '$dlm' ||
       'soTerm=' || so.term_name || '$dlm' ||
       'product=' || gf.product || '$dlm' ||
       'taxon=' || tn.name || '$dlm' ||
       'SecondaryScore=' || gf.secondary_score || '$dlm' ||
       'score=' || round(gf.score,4) || '$dlm' ||
       'isPseudo=' || gf.is_pseudo || '$dlm' ||
       'ExtDbName=' ||  ed.name || '$dlm' ||
       'Version=' ||  edr.version || '$dlm' ||
       'FeatureType=' || fl.feature_type
         as atts
FROM 
       dots.GeneFeature gf,
       apidb.FeatureLocation fl, 
       dots.NASequence ns,
       sres.TaxonName tn,
       sres.SequenceOntology so,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.na_sequence_id = ns.na_sequence_id
  AND  fl.feature_type = 'GenePrediction'
  AND  fl.na_feature_id = gf.na_feature_id 
  AND  so.sequence_ontology_id = gf.sequence_ontology_id
  AND  fl.start_min <= $rend 
  AND  fl.end_max >= $base_start 
  AND  tn.taxon_id = ns.taxon_id 
  AND  tn.name_class = 'scientific name' 
  AND  gf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name = $$extDbName$$ 
ORDER BY 
       fl.start_min
]]>
  </query>

  <query name="gff:basic" includeProjects="AmoebaDB,CryptoDB,FungiDB,PlasmoDB,ToxoDB,TrichDB,TriTrypDB,VectorBase,UniDB">
<![CDATA[ 
SELECT g3.gff3_feature_id feature_id,
       'gff' type,
       '$source' source,
       g3.id_attr name,
       nvl(to_char(score),'.') score,
       g3.na_sequence_id parent_id,
       g3.mapping_start startm,
       g3.mapping_end end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || ot.name || '$dlm' ||
       'source=' || g3.source|| '$dlm' ||
        replace( g3.attr, ';', '$dlm') atts 
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed, sres.ontologyTerm ot
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND ed.name = $$edName$$
  AND ot.ontology_term_id = g3.sequence_ontology_id
]]>
  </query>

  <query name="gff:basicAlt" includeProjects="PlasmoDB,ToxoDB,CryptoDB,FungiDB,AmoebaDB,TrichDB,UniDB">
<![CDATA[ 
SELECT g3.gff3_feature_id feature_id,
       'gff' type,
       source,
       g3.id_attr name,
       nvl(to_char(score),'.') score,
       g3.na_sequence_id parent_id,
       g3.mapping_start startm,
       g3.mapping_end end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || ot.name ||
        replace( g3.attr, ';', '$dlm') atts 
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed, sres.ontologyTerm ot
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND ed.name = $$edName$$
  AND source = $$source$$
  AND ot.ontology_term_id = g3.sequence_ontology_id
]]>
  </query>


  <query name="gff:processedTranscript" includeProjects="PlasmoDB,ToxoDB,CryptoDB,VectorBase,UniDB">
<![CDATA[ 
SELECT g3.id_attr feature_id,
       'gff' type,
--       'annotation' source,
       '$source' source,
       g3.id_attr name,
       '1' phase,
       g3.score score,
       g3.na_sequence_id parent_id,
       g3.mapping_start startm,
       g3.mapping_end end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
      replace( g3.attr, ';', '$dlm') atts 
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed, sres.ontologyterm so
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND g3.sequence_ontology_id = so.ontology_term_id
  AND SO.name in ('rRNA', 'tRNA', 'mRNA', 'transcript')
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND  ed.name = $$edName$$
]]>
  </query>

  <query name="gene:OldModels" includeProjects="PlasmoDB,ToxoDB,UniDB">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'gene' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'product=' ||  oa.value || '$dlm' ||
       'taxon=' || ga.organism atts 
FROM   dots.BlatAlignment blat, 
       dots.ExternalNASequence enas, dots.NASequence etn,
       apidb.OldAnnotation oa, apidbtuning.GeneAttributes ga, apidbtuning.GeneId gi,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.is_best_alignment = 1
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name like '%_old_transcript_sequences_RSRC%'
  AND  enas.source_id = oa.source_id(+)
  AND  oa.type(+) ='product'
  AND  enas.source_id = gi.id
  AND ga.source_id = gi.gene
]]>
  </query>

  <query name="alignment:sequence" includeProjects="AmoebaDB,CryptoDB,FungiDB,GiardiaDB,TriTrypDB,ToxoDB,VectorBase,UniDB">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'alignment' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       ' ' atts
FROM   dots.BlatAlignment blat, core.TableInfo ti,
       dots.ExternalNASequence enas, dots.NASequence etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.query_table_id = ti.table_id
  AND  ti.name='ExternalNASequence'
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.is_best_alignment = 1
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name = $$edName$$
]]>
  </query>
  
  <query name="SNP:density"  includeProjects="ToxoDB,AmoebaDB,TriTrypDB,CryptoDB,PlasmoDB,FungiDB,UniDB">
<![CDATA[
 SELECT etn.na_sequence_id feature_id, 
       'SNP' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
  </query>

  <query name="ChIP:ChIPSeqPeaks" includeProjects="FungiDB,PiroplasmaDB,PlasmoDB,ToxoDB,TriTrypDB,UniDB">
        <![CDATA[
            SELECT feature_id
            , type
            , source
            , parent_id
            , name
            , startm
            , end
            , tag_count || '$dlm' || fold_change || '$dlm' || p_value || '$dlm' || 'name=' || pan_name || '$dlm' || atts as atts
            FROM (
                SELECT feature_id
                , type
                , source
                , tag_count
                , fold_change
                , p_value
                , pan_name
                , parent_id
                , ' ' as name
                , startm
                , end
                , LISTAGG(attr, '$dlm' on overflow truncate) WITHIN GROUP (ORDER BY attr) AS atts
                FROM (
                    WITH data AS (
                        SELECT DISTINCT sr.segment_result_id as feature_id
                        , 'ChIPSeqPeaks' as type
                        , '$source' as source
                        , 'tag_count=' || sr.score1 as tag_count
                        , 'fold_change=' || sr.score2 as fold_change
                        , CASE WHEN sr.p_value = 0 THEN 'p_value=' || to_char(p_value)
                            ELSE 'p_value=' || to_char(p_value, '9.9EEEE') END as p_value
                        , $srcfeature_id as parent_id
                        , sr.segment_start as startm
                        , sr.segment_end as end
                        , '$$exp$$' as dataset_name
                        , pan.protocol_app_node_id as pan
                        , pan.name as pan_name
                        FROM
                        study.study s
                        , study.study i
                        , study.studylink sl
                        , study.protocolappnode pan
                        , results.segmentresult sr
                        WHERE s.name = '$$exp$$'
                        AND i.investigation_id = s.study_id
                        AND sl.study_id = i.study_id
                        AND pan.protocol_app_node_id = sl.protocol_app_node_id
                        AND sr.protocol_app_node_id = pan.protocol_app_node_id
                        AND sr.na_sequence_id = $srcfeature_id
                        AND sr.segment_start <= $rend
                        AND sr.segment_end >= $base_start
                        )
                    SELECT d.*
                    , m.property || '=' || m.string_value as attr
                    , CASE WHEN m. property = '$$sub$$' THEN m.string_value END as subtrack
                    FROM data d
                    LEFT OUTER JOIN apidbtuning.metadata m ON
                        (m.dataset_name = d.dataset_name
                        AND m.pan_id = d.pan)
                   )
                GROUP BY feature_id, type, source, tag_count, fold_change, p_value, parent_id, startm, end, pan_name
            )
        ]]>
 </query>

 <query name="ChIP:ChIPSeqPeaksjbrowse" includeProjects="FungiDB,PiroplasmaDB,PlasmoDB,ToxoDB,TriTrypDB,UniDB">
        <![CDATA[
            SELECT feature_id
            , type
            , source
            , startm
            , end
            , tag_count || '$dlm' || fold_change || '$dlm' || p_value || '$dlm' || atts as atts
            , sample_name
            FROM (
                SELECT feature_id
                , type
                , source
                , tag_count
                , fold_change
                , p_value
                , startm
                , end
                , LISTAGG(attr, '$dlm' on overflow truncate) WITHIN GROUP (ORDER BY attr) AS atts
                , sample_name
                FROM (
                    WITH data AS (
                        SELECT DISTINCT sr.segment_result_id as feature_id
                        , 'ChIPSeqPeaks' as type
                        , '$source' as source
                        , 'tag_count=' || sr.score1 as tag_count
                        , 'fold_change=' || sr.score2 as fold_change
                        , CASE WHEN sr.p_value = 0 THEN 'p_value=' || to_char(p_value)
                            ELSE 'p_value=' || to_char(p_value, '9.9EEEE') END as p_value
                        , sr.segment_start as startm
                        , sr.segment_end as end
                        , '$$exp$$' as dataset_name
                        , pan.protocol_app_node_id as pan
                        , pan.name as sample_name
                        FROM
                        study.study s
                        , study.study i
                        , study.studylink sl
                        , study.protocolappnode pan
                        , results.segmentresult sr
                        WHERE s.name = '$$exp$$'
                        AND i.investigation_id = s.study_id
                        AND sl.study_id = i.study_id
                        AND pan.protocol_app_node_id = sl.protocol_app_node_id
                        AND sr.protocol_app_node_id = pan.protocol_app_node_id
                        AND sr.na_sequence_id = $srcfeature_id
                        AND sr.segment_start <= $rend
                        AND sr.segment_end >= $base_start
                        AND pan.protocol_app_node_id = $$panId$$
                        )
                     SELECT d.*
                    , m.property || '=' || m.string_value as attr
                    , CASE WHEN m. property = '$$sub$$' THEN m.string_value END as subtrack
                    FROM data d
                    LEFT OUTER JOIN apidbtuning.metadata m ON
                        (m.dataset_name = d.dataset_name
                        AND m.pan_id = d.pan)
                   )
                GROUP BY feature_id, type, source, tag_count, fold_change, p_value, startm, end, sample_name
            )
        ]]>
  </query>

  <query name="ChIP:ChIPchip_peaks"  includeProjects="FungiDB,PlasmoDB,ToxoDB,TriTrypDB,UniDB">
        <![CDATA[
            SELECT feature_id
            , type
            , source
            , score
            , parent_id
            , ' ' as name
            , startm
            , end
            , listagg (attr, '$dlm' on overflow truncate) within group (order by attr) as atts
            FROM (
                WITH data AS (
                    SELECT DISTINCT sr.segment_result_id as feature_id
                    , 'ChIPPeaks' as type
                    , '$source' as source
                    , sr.score1 as score
                    , $srcfeature_id as parent_id
                    , sr.segment_start as startm
                    , sr.segment_end as end
                    , '$$exp$$' as dataset_name
                    , pan.protocol_app_node_id as pan
                    FROM
                    study.study s
                    , study.studylink sl
                    , study.protocolappnode pan
                    , results.segmentresult sr
                    WHERE s.name = '$$exp$$ - peaks'
                    AND sl.study_id = s.study_id
                    AND pan.protocol_app_node_id = sl.protocol_app_node_id
                    AND sr.protocol_app_node_id = pan.protocol_app_node_id
                    AND sr.na_sequence_id = $srcfeature_id
                    AND sr.segment_start <= $rend
                    AND sr.segment_end >= $base_start
                    AND sr.score1 > $$cutoff$$
                    )
                SELECT d.*
                , m.property || '=' || m.string_value as attr
                FROM data d
                LEFT OUTER JOIN apidbtuning.metadata m ON
                    (m.dataset_name = d.dataset_name
                    AND m.pan_id = d.pan)
                )
                GROUP BY feature_id, type, source, score, parent_id, startm, end
            ]]>
  </query>  

  <query name="ChIP:ChIPchip_peaksjbrowse"  includeProjects="FungiDB,PlasmoDB,ToxoDB,TriTrypDB,UniDB">
        <![CDATA[
            SELECT feature_id
            , type
            , source
            , score
            , parent_id
            , startm
            , end
            , listagg (attr, '$dlm' on overflow truncate) within group (order by attr) as atts
            , sample_name
            FROM (
                WITH data AS (
                    SELECT DISTINCT sr.segment_result_id as feature_id
                    , 'ChIPPeaks' as type
                    , '$source' as source
                    , sr.score1 as score
                    , pan.name as parent_id
                    , sr.segment_start as startm
                    , sr.segment_end as end
                    , '$$exp$$' as dataset_name
                    , pan.protocol_app_node_id as pan
                    , pan.name as sample_name
                    FROM
                    study.study s
                    , study.studylink sl
                    , study.protocolappnode pan
                    , results.segmentresult sr
                    WHERE s.name = '$$exp$$ - peaks'
                    AND sl.study_id = s.study_id
                    AND pan.protocol_app_node_id = sl.protocol_app_node_id
                    AND sr.protocol_app_node_id = pan.protocol_app_node_id
                    AND sr.na_sequence_id = $srcfeature_id
                    AND sr.segment_start <= $rend
                    AND sr.segment_end >= $base_start
                    AND sr.score1 > $$cutoff$$
                    AND pan.protocol_app_node_id = $$panId$$
                    )
                SELECT d.*
                , m.property || '=' || m.string_value as attr
                FROM data d
                LEFT OUTER JOIN apidbtuning.metadata m ON
                    (m.dataset_name = d.dataset_name
                    AND m.pan_id = d.pan)
                )
                GROUP BY feature_id, type, source, score, parent_id, startm, end, sample_name
            ]]>
  </query>

  <query name="GeneticMarkers:Sibley"  includeProjects="ToxoDB,UniDB">
<![CDATA[
 SELECT 
       sa.na_feature_id           as feature_id,
       'GeneticMarkers'           as type, 
       'Sibley'                   as source, 
       sa.source_id               as name, 
       '.'                        as score, 
       sa.seq_source_id           as parent_id, 
       sa.start_min               as startm, 
       sa.start_min               as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'RefNA='   || sa.reference_na || '$dlm' ||
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
          'Gene=' || sa.gene_source_id || '$dlm' ||
       'PositionInCDS=' || sa.position_in_CDS || '$dlm' ||
       'PositionInProtein=' || sa.position_in_protein || '$dlm' ||
       'RefStrain=' || sa.reference_strain || '$dlm' ||
       'RefAA='   || sa.reference_aa || '$dlm' ||
       sa.gene_strand || '$dlm' ||
       'SourceID='   ||  sa.source_id 
        as atts
FROM   apidb.FeatureLocation fl,
       ApidbTuning.SnpAttributesdots sa
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND  sa.dataset = 'tgonME49_SNP_Sibley_Tg10x_31_gff_RSRC'
]]>
  </query>
  
  <query name="GeneticMarkers:overview"  includeProjects="ToxoDB,UniDB">
<![CDATA[
 SELECT
       sv.na_feature_id as feature_id,
       'GeneticMarkers' type, 
       'overview' source, 
       SUBSTR (sv.source_id, 14) as name,
       '.' score, 
       l.sequence_source_id as parent_id, 
       l.start_min as startm, 
       l.end_max as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=GeneticMarkers' atts
FROM   dots.seqVariation sv, apidb.FeatureLocation l,
       sres.EXTERNALDATABASERELEASE edr, sres.EXTERNALDATABASE ed
WHERE  sv.external_database_release_id = edr.external_database_release_id and
       edr.external_database_id = ed.external_database_id and
       ed.name = 'tgonME49_SNP_Sibley_Tg10x_31_gff_RSRC'
 AND   l.na_sequence_id = $srcfeature_id
 AND  sv.parent_id=l.na_feature_id
]]>
  </query>

  <query name="ChIP:ChIPchip_smoothedjbrowse">
        <![CDATA[
        SELECT
        feature_id
        , type
        , source
        , score
        , parent_id || '_' || nvl(max(subtrack), ' ') as parent_id
        , startm
        , end
        , listagg (attr, '$dlm' on overflow truncate) within group (order by attr) as atts
        , sample_name
        FROM (
            WITH data AS (    
                SELECT DISTINCT
                sr.segment_result_id as feature_id
                , 'ChIP' as type
                , '$source' as source
                , sr.score1 as score
                , pan.name as parent_id
                , sr.segment_start as startm
                , sr.segment_end as end
                , '$$exp$$' as dataset_name
                , pan.protocol_app_node_id as pan
                , pan.name as sample_name
                FROM
                study.study s
                , study.studylink sl
                , study.protocolappnode pan
                , results.segmentresult sr
                WHERE s.name =  '$$exp$$ - smoothed'
                AND sl.study_id = s.study_id
                AND pan.protocol_app_node_id = sl.protocol_app_node_id
                AND sr.protocol_app_node_id = pan.protocol_app_node_id
                AND sr.na_sequence_id = $srcfeature_id
                AND sr.segment_start <= $rend
                AND sr.segment_end >= $base_start
                AND pan.protocol_app_node_id = $$panId$$
                )
            SELECT d.*
            , m.property || '=' || m.string_value as attr
            , CASE WHEN m.property = '$$sub$$' THEN m.string_value END as subtrack
            FROM data d
            LEFT OUTER JOIN apidbtuning.metadata m ON
                (m.dataset_name = d.dataset_name
                AND m.pan_id = d.pan)
            )
        GROUP BY feature_id, type, source, score, parent_id, startm, end, sample_name
        ]]>
  </query>

  <query name="ChIP:ChIPchip_smoothed" includeProjects = "FungiDB,PlasmoDB,ToxoDB, TriTrypDB,UniDB">
        <![CDATA[
        SELECT DISTINCT 
        CASE WHEN term = '$$sub$$' THEN feature_id || '_' || value 
        ELSE feature_id || '_ ' END as feature_id
        , type
        , source
        , CASE WHEN term = '$$sub$$' THEN value
        ELSE ' ' END as name
        , parent_id
        , startm
        , end
        , CASE WHEN term = '$$sub$$' THEN term || '=' || value 
            ELSE ' ' END as atts
        FROM (
            WITH data as (
                SELECT DISTINCT s.name as feature_id
                , 'ChIP' as type
                , '$source' as source
                , '$srcfeature_id' as parent_id
                , $base_start as startm
                , $rend as end
                , '$$exp$$' as dataset_name
                , pan.protocol_app_node_id as pan
                FROM study.study s
                , study.studylink sl
                , study.protocolappnode pan
                WHERE s.name = '$$exp$$ - smoothed'
                AND sl.study_id = s.study_id
                AND pan.protocol_app_node_id = sl.protocol_app_node_id
                )
            SELECT d.*
            , ppm.property AS term
            , ppm.value
            FROM data d
            LEFT OUTER JOIN apidbtuning.InferredParams ppm ON
                (ppm.dataset_name = d.dataset_name
                AND ppm.pan_id = d.pan)
        UNION
            SELECT d.*
            , pcm.property AS term
            , pcm.value
            FROM data d
            LEFT OUTER JOIN apidbtuning.InferredChars pcm ON
                (pcm.dataset_name = d.dataset_name
                AND pcm.pan_id = d.pan)
        UNION
          SELECT d.*
          , 'name' as term
          , fbm.pan_name as value
          FROM data d
          LEFT OUTER JOIN apidbtuning.DefaultChars fbm ON
            (fbm.dataset_name = d.dataset_name
            AND fbm.pan_id = d.pan
            AND fbm.pan_name like '%smoothed%')
        )
        WHERE term = '$$sub$$' OR 'no_sub' = '$$sub$$'
        ]]>
  </query>
 
  
  
  <query name="SNP:Population"  includeProjects="ToxoDB,AmoebaDB,TriTrypDB,CryptoDB,PlasmoDB,FungiDB,PiroplasmaDB,UniDB">
<![CDATA[
 SELECT 
       sa.source_id              as feature_id,
       'SNP'                     as type, 
       '$source'                 as source, 
       sa.source_id              as name, 
       sa.seq_source_id          as parent_id, 
       sa.location               as startm, 
       sa.location               as end, 
       decode(ga.strand_plus_minus, '+', '+1', '-', '-1', '.') as strand,
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'Nonsense='   || sa.has_stop_codon || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'Gene=' || sa.gene_source_id || '$dlm' ||
       'type=' || 'snp' || '$dlm' ||
       'position_in_CDS=' || sa.position_in_CDS || '$dlm' ||
       'position_in_protein=' || sa.position_in_protein || '$dlm' ||
       'gene_strand=' || decode(ga.strand_plus_minus, '+', '+1', '-', '-1', '.') || '$dlm' ||
       'reference_strain=' || sa.reference_strain || '$dlm' ||
       'reference_aa=' || sa.reference_aa || '$dlm' ||
       'reference_na=' || sa.reference_na || '$dlm' ||
       'major_allele=' || sa.major_allele || '$dlm' ||
       'minor_allele=' || sa.minor_allele || '$dlm' ||
       'major_product=' || sa.major_product || '$dlm' ||
       'minor_product=' || sa.minor_product || '$dlm' ||
       'num_strains=' || sa.distinct_strain_count || '$dlm' ||
       'major_allele_count=' || sa.major_allele_count || '$dlm' ||
       'minor_allele_count=' || sa.minor_allele_count || '$dlm' ||
       'major_allele_freq=' || sa.major_allele_frequency || '$dlm' ||
       'minor_allele_freq=' || sa.minor_allele_frequency || '$dlm' ||
       'source_id=' || sa.source_id as atts
FROM   ApidbTuning.SnpAttributes sa, apidbtuning.geneattributes ga
WHERE  sa.na_sequence_id = $srcfeature_id
  AND sa.gene_source_id = ga.source_id (+)
  AND  sa.location <= $rend
  AND  sa.location >= $base_start
]]>
  </query>
 
  <query name="SNP:Genotyping"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
SELECT 
       sa.na_feature_id          as feature_id,
       'SNP'                     as type, 
       'Genotyping'              as source, 
       sa.source_id              as name, 
       sa.na_sequence_id         as parent_id, 
       sa.start_min              as startm, 
       sa.start_min              as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'SNPChipType='   || replace (replace (sa.dataset,'pfal3D7_SNPChip_'), '_RSRC')  || '$dlm' ||
       'type=' || 'snp-chip' || '$dlm' ||
       'source_id='   || sa.source_id || '$dlm' ||
       'major_allele_freq=' || sa.major_allele_frequency || '$dlm' ||
       'minor_allele_freq=' || sa.minor_allele_frequency || '$dlm' ||
       'NonSyn='   || decode(sa.has_nonsynonymous_allele,'yes',1,'no',0) || '$dlm'||
       'Nonsense='   || CASE WHEN sa.major_product = '*' or sa.minor_product = '*' THEN 1 ELSE 0 END || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'position_in_CDS=' || sa.position_in_CDS || '$dlm' ||
       'position_in_protein=' || sa.position_in_protein || '$dlm' ||
       'reference_strain=' || sa.reference_strain || '$dlm' ||
       'reference_aa=' || sa.reference_aa || '$dlm' ||
       'reference_na=' || sa.reference_na || '$dlm' ||
       'major_allele=' || sa.major_allele || '$dlm' ||
       'minor_allele=' || sa.minor_allele || '$dlm' ||
       'major_product=' || sa.major_product || '$dlm' ||
       'minor_product=' || sa.minor_product || '$dlm' ||
       'major_allele_count=' || sa.major_allele_count || '$dlm' ||
       'minor_allele_count=' || sa.minor_allele_count AS atts
FROM   ApidbTuning.SnpChipAttributes sa
WHERE  sa.na_sequence_id = $srcfeature_id
  AND  sa.start_min <= $rend
  AND  sa.start_min >= $base_start
]]>
  </query> 

  <query name="SNP:Diversity">
<![CDATA[
SELECT etn.na_sequence_id feature_id, 
       'SNP' type, 
       '$source' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
  </query>

  <query name="SNP:DiversityJbrowse"  includeProjects="PlasmoDB,ToxoDB,UniDB">
<![CDATA[
SELECT 
       gff3.gff3_feature_id          as feature_id,
       'SNP_sub'                     as type, 
       '$source'                     as source, 
       gff3.score                    as score, 
       gff3.na_sequence_id           as parent_id, 
       gff3.mapping_start            as startm, 
       gff3.mapping_end              as end, 
       decode(gff3.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   ApiDB.GFF3 gff3,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr
WHERE  ed.name = $$edname$$
  AND  edr.external_database_id = ed.external_database_id
  AND  gff3.external_database_release_id = edr.external_database_release_id
  AND  gff3.na_sequence_id = $srcfeature_id
  AND  gff3.mapping_start <= $rend
  AND  gff3.mapping_end >= $base_start
]]>
  </query> 

  <query name="domain:tssJBrowse" includeProjects="FungiDB,UniDB">
<![CDATA[
SELECT distinct ssf.segment_start as  feature_id,
       'domain' type, 
       '$source' as source,
       sum(ssf.count_per_million) as score, 
       ssf.na_sequence_id  || ssf.strand parent_id,
       ssf.segment_start as startm, 
       ssf.segment_start as end, 
       decode(ssf.strand, '+',1,'-', -1, '.') as strand
 FROM 
   study.study i, study.study s, study.studylink sl,
   study.protocolAppNode pan, apidb.spliceSiteFeature ssf
 WHERE ssf.na_sequence_id =  $srcfeature_id
   AND ssf.segment_start >=  $base_start
   AND ssf.segment_end <= $rend
   AND ssf.type = $$featType$$
   AND pan.protocol_app_NODE_ID = ssf.protocol_app_node_id
   AND pan.protocol_app_node_id = sl.protocol_app_node_id
   and sl.study_id = s.study_id
   and s.name like '%[feature_loc]'
   and s.investigation_id = i.study_id
   and i.name like  $$edName$$
   and ssf.count_per_million > $$minCntPerMill$$
   and ssf.strand = '$$strand$$'
  GROUP BY  ssf.segment_start, ssf.strand, ssf.na_sequence_id
]]>
  </query>

  <query name="domain:tss">
<![CDATA[
SELECT distinct ssf.na_sequence_id  || '-' as  feature_id,
       'domain' type, 
       '$source' as source,
       '.' as score, 
       '' as parent_id,
       $base_start as startm, 
       $rend as end, 
       -1 as strand
FROM   apidb.spliceSiteFeature ssf 
WHERE  ssf.na_sequence_id =  $srcfeature_id
UNION
SELECT distinct ssf.na_sequence_id  || '+' as  feature_id,
       'domain' type, 
       '$source' as source,
       '.' as score, 
       '' as parent_id,
       $base_start as startm, 
       $rend as end, 
       1 as strand
FROM   apidb.spliceSiteFeature ssf 
WHERE  ssf.na_sequence_id =  $srcfeature_id
]]>
  </query>
  
  
  <query name="mapp:promoters"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
SELECT $srcfeature_id || '_-1'  as feature_id,
  'mapp'  as type, 
  'promoters'     as source,
  $base_start  as startm,
  $rend        as end,
  -1 as strand,
  '' as atts
from dual
UNION
SELECT $srcfeature_id || '_1'  as feature_id,
  'mapp'  as type, 
  'promoters'     as source,
  $base_start  as startm,
  $rend        as end,
  1 as strand,
  '' as atts
from dual
]]>
  </query>


  <query name="domain:tRNA" >
<![CDATA[
SELECT distinct loc.feature_location_id feature_id,
       'domain' type,
       'tRNA' source,
       rnaf.source_id name,
       loc.na_sequence_id parent_id,
       loc.start_min as startm,
       loc.end_max as end,
       decode (loc.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM
   apidb.FeatureLocation loc, ApidbTuning.genomicseqattributes ga,
   dots.rnafeature rnaf
WHERE  loc.na_sequence_id = $srcfeature_id
  AND  loc.feature_type = 'RNAFeature'
  AND  loc.start_min <= $rend
  AND  loc.end_max >= $base_start
  AND  ga.na_sequence_id = loc.na_sequence_id
  AND  rnaf.na_FEATURE_ID = loc.na_feature_id
]]>
  </query>




  <query name="rnaseq:gcpfwt"  includeProjects="TriTrypDB,UniDB">
       <![CDATA[
        SELECT 'gcpfwt_id' as feature_id,
               'rnaseq' type,
               'gcpfwt' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:gcbfall"  includeProjects="TriTrypDB,UniDB">
       <![CDATA[
        SELECT 'gcbfall_id' as feature_id,
               'rnaseq' type,
               'gcbfall' source,
                $base_start as startm,
                $rend       as end
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_three_samples"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'cn_three_sample' as feature_id,
               'rnaseq' type,
               sample as name,
               'cn_three_samples' source,
                $base_start as startm,
                $rend       as end
        FROM   apidb.rnaseq_coverage rc
        WHERE   rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('24h','8h','40h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
         GROUP BY rc.sample
       ]]>
  </query>

  <query name="rnaseq:cn_four_samples"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'cn_four_sample' as feature_id,
               'rnaseq' type,
               sample as name,
               'cn_four_samples' source,
                $base_start as startm,
                $rend       as end 
        FROM   apidb.rnaseq_coverage rc
        WHERE   rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('0h','16h','32h','48h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
         GROUP BY rc.sample
       ]]>
  </query>

  <query name="rnaseq:cn_pf0h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_0h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf0h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf8h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_8h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf8h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf16h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_16h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf16h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf24h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_24h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf24h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf32h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_32h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf32h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf40h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_40h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf40h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

  <query name="rnaseq:cn_pf48h_lin"  includeProjects="PlasmoDB,UniDB">
       <![CDATA[
        SELECT 'rnaseq_48h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf48h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
  </query>

    <query name="gsnap:unifiedintronjunctionAnnotatedOnly:bulksubfeatures">
       <![CDATA[
              select INTRON_FEATURE_ID as feature_id,
                     intron_feature_id as PARENT_ID,
                     'gsnap' as type,
                     segment_start - 10 as startm,
                     segment_END + 10 as "end",
                     CONTAINED,
                     MATCHES_GENE_STRAND,
                     PERCENT_MAX,
                     total_unique as SCORE,
                     ANNOTATED_INTRON,
                     to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                     to_char(10) || ',' || to_char(10) as blocksizes
                from ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                where gij.na_sequence_id= $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'Yes'
       ]]>
  </query>


    <query name="gsnap:unifiedintronjunctionHCOnly:bulksubfeatures">
       <![CDATA[
              select INTRON_FEATURE_ID as feature_id,
                     intron_feature_id as PARENT_ID,
                     'gsnap' as type,
                     segment_start - 10 as startm,
                     segment_END + 10 as "end",
                     CONTAINED,
                     MATCHES_GENE_STRAND,
                     PERCENT_MAX,
                     total_unique as SCORE,
                     ANNOTATED_INTRON,
                     to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                     to_char(10) || ',' || to_char(10) as blocksizes
                from ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
       ]]>
  </query>

    <query name="gsnap:unifiedintronjunctionLCOnly:bulksubfeatures">
       <![CDATA[
              select INTRON_FEATURE_ID as feature_id,
                     intron_feature_id as PARENT_ID,
                     'gsnap' as type,
                     segment_start - 10 as startm,
                     segment_END + 10 as "end",
                     CONTAINED,
                     MATCHES_GENE_STRAND,
                     PERCENT_MAX,
                     total_unique as SCORE,
                     ANNOTATED_INTRON,
                     to_char(segment_start - 10) || ',' || to_char(segment_end + 1) as tstarts,
                     to_char(10) || ',' || to_char(10) as blocksizes
                from ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 4
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 20
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.min_annot_score ELSE 5*stats.min_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= stats.min_annot_percent_max)
                AND gij.intron_feature_id not in (
                select gij.intron_feature_id
                from ApidbTuning.GeneIntronJunction gij, ApidbTuning.GeneIntJuncStats stats
                where gij.na_sequence_id = $srcfeature_id
                AND gij.segment_start <= $rend
                AND gij.segment_end >= $base_start
                and gij.na_sequence_id = stats.na_sequence_id
                AND gij.segment_end - gij.segment_start <= stats.max_intron_length * 2
                AND gij.segment_end - gij.segment_start <= ($rend - $base_start) * 12
                AND gij.annotated_intron = 'No'
                AND gij.total_unique >=  CASE WHEN contained = 1 THEN stats.perc01_annot_score ELSE 5*stats.perc01_annot_score END
                AND (gij.contained = 0 or gij.percent_max >= 2 /*stats.perc0005_annot_percent_max*/)
               )
       ]]>
  </query>



  <query name="gene:annotation2:bulksubfeatures">
<![CDATA[
select * from (
 SELECT
       ta.na_feature_id || '' feature_id,
       case when so_term_name in ('protein_coding_gene', 'transposable_element_gene')  then 'processed_transcript' else 'nc_transcript' end as type,
       'annotation' source,
       ta.source_id name,
       '1' phase, 
       ta.gene_na_feature_id parent_id,
       fl.start_min startm,
       fl.end_max end,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || ta.transcript_type || '$dlm' ||
       'geneId=' || ta.gene_source_id || '$dlm' ||
       'Contig=' || ta.sequence_id || '$dlm' ||
       'taxon=' || ta.organism || '$dlm' ||
       'isDeprecated=' || ta.is_deprecated || '$dlm' ||
       'isPseudo=' || ta.is_pseudo || '$dlm' ||
       'hasSeqEdit=' || ta.has_seqedit || '$dlm' ||
       'ProjectId=' || ta.project_id || '$dlm' ||
       'aaSeqId=' || ta.aa_sequence_id ||  '$dlm' || 
       'OrgAbbrev=' || o.public_abbrev atts,
       1 as has_children
FROM
       ApidbTuning.TranscriptAttributes ta,
       apidb.FeatureLocation fl, apidb.organism o
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.feature_type = 'Transcript'
  AND  fl.na_feature_id = ta.na_feature_id
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  ta.taxon_id = o.taxon_id
UNION
SELECT distinct exon_loc.feature_location_id || '-' || ta.na_feature_id feature_id, 
       case when ta.aa_sequence_id is null then 'nc_exon' when ta.transcript_type = 'pseudogenic_transcript' then 'pseudogenic_exon' else 'exon' end type,
       'annotation' source, 
       ta.source_id name,
       '1' phase, 
       ta.na_feature_id parent_id,
       exon_loc.start_min as startm,
       exon_loc.end_max as end,
       decode (exon_loc.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  ta.is_deprecated atts ,
       0 as has_children
FROM   
       apidb.FeatureLocation exon_loc, ApidbTuning.TranscriptAttributes ta, dots.rnafeatureexon rfe
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  AND  exon_loc.feature_type = 'ExonFeature'
  AND  exon_loc.start_min <= $rend
  AND  exon_loc.end_max >= $base_start
  AND  ta.na_feature_id = rfe.rna_feature_id
  AND  rfe.EXON_FEATURE_ID = exon_loc.na_feature_id
UNION
SELECT distinct exon_loc.feature_location_id || '-' || exon_loc.parent_id feature_id, 
       exon_loc.feature_type type, 
       'annotation' source, 
       ta.source_id name,
       '1' phase, 
       exon_loc.parent_id parent_id,
       exon_loc.start_min as startm,
       exon_loc.end_max as end,
       decode (exon_loc.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  ta.is_deprecated atts ,
       0 as has_children
FROM   
       apidb.FeatureLocation exon_loc, ApidbTuning.TranscriptAttributes ta
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  AND  (exon_loc.feature_type = 'CDS'
     OR exon_loc.feature_type in ('five_prime_UTR', 'three_prime_UTR') AND ta.transcript_type != 'pseudogenic_transcript')
  AND  exon_loc.start_min <= $rend
  AND  exon_loc.end_max >= $base_start
  AND ta.na_feature_id = exon_loc.parent_id
) order by has_children desc
]]>
  </query>

  <query name="gene:annotation:bulksubfeatures">
<![CDATA[
SELECT distinct exon_loc.feature_location_id feature_id, 
       'exon' type,
       'annotation' source, 
       ta.na_feature_id name,
       '1' phase, 
       ta.na_feature_id parent_id,
       exon_loc.start_min as startm,
       exon_loc.end_max as end,
       decode (exon_loc.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  ta.is_deprecated atts 
FROM   
       apidb.FeatureLocation exon_loc, ApidbTuning.TranscriptAttributes ta, dots.rnafeatureexon rfe
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  AND  exon_loc.feature_type = 'ExonFeature'
  AND  exon_loc.start_min <= $rend
  AND  exon_loc.end_max >= $base_start
  AND  ta.na_feature_id = rfe.rna_feature_id
  AND  rfe.EXON_FEATURE_ID = exon_loc.na_feature_id
UNION
SELECT distinct exon_loc.feature_location_id feature_id, 
       exon_loc.feature_type type, 
       'annotation' source, 
       ta.na_feature_id name,
       '1' phase, 
       exon_loc.parent_id parent_id,
       exon_loc.start_min as startm,
       exon_loc.end_max as end,
       decode (exon_loc.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  ta.is_deprecated atts 
FROM   
       apidb.FeatureLocation exon_loc, ApidbTuning.TranscriptAttributes ta
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  AND  (exon_loc.feature_type = 'CDS' or exon_loc.feature_type = 'five_prime_UTR' or exon_loc.feature_type = 'three_prime_UTR')
  AND  exon_loc.start_min <= $rend
  AND  exon_loc.end_max >= $base_start
  AND ta.na_feature_id = exon_loc.parent_id
]]>
  </query>

  <query name="gff:processedTranscript:bulksubfeatures" includeProjects="PlasmoDB,ToxoDB,CryptoDB,VectorBase,UniDB">
<![CDATA[ 
SELECT g3.id_attr feature_id,
       so.name type,
--       'annotation' source,
--       '$source' source,
       so.name source,
       g3.id_attr name,
       '1' phase,
--       nvl(to_char(score),'.') score,
       g3.parent_attr parent_id,
       g3.mapping_start startm,
       g3.mapping_end end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
      replace( g3.attr, ';', '$dlm') atts 
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed, sres.ontologyterm so
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND g3.sequence_ontology_id = so.ontology_term_id
  AND SO.name in ('CDS', 'UTR', 'five_prime_UTR', 'three_prime_UTR') 
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND  ed.name = $$edName$$
]]>
  </query>


  <query name="gff:apolloTranscript">
<![CDATA[ 
SELECT g3.attr AS attr,
       g3.apolloproduct AS apolloproduct,
       g3.apollopmid AS apollopmid,
       g3.apolloevidencecode AS apolloevidencecode,
       g3.apolloobsolete AS apolloobsolete,
       g3.id_attr AS feature_id,
       g3.type AS type,
       '$source' AS source,
       g3.apollotranscript AS name,
       '1' AS phase,
       g3.score AS score,
       g3.id_attr AS parent_id,
       g3.mapping_start AS startm,
       g3.mapping_end AS "end",
       g3.apolloid AS apolloid,
       CASE
           WHEN g3.strand = '+' THEN '+1'
           WHEN g3.strand = '-' THEN '-1'
           ELSE '.'
       END AS strand,
       REPLACE(g3.attr, ';', '$dlm') AS atts
FROM apidbtuning.ApolloUpdate g3
WHERE g3.na_sequence_id = $srcfeature_id
  AND g3.type LIKE '%gene'
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
]]>
  </query>

  <query name="gff:apolloTranscript:bulksubfeatures">
<![CDATA[
SELECT apolloproduct, apollopmid, apolloevidencecode, apolloobsolete, feature_id, type, source, name, phase, score, parent_id, startm, "end", apolloid, strand, atts  
FROM (
  WITH transcripts AS (
    SELECT g3.attr AS attr,
           g3.apolloproduct AS apolloproduct,
           g3.apollopmid AS apollopmid,
           g3.apolloevidencecode AS apolloevidencecode,
           g3.apolloobsolete AS apolloobsolete,
           g3.id_attr AS feature_id,
           g3.type AS type,
           '$source' AS source,
           g3.apollotranscript AS name,
           '1' AS phase,
           g3.score AS score,
           g3.parent_attr AS parent_id,
           g3.mapping_start AS startm,
           g3.mapping_end AS "end",
           g3.apolloid AS apolloid,
           CASE 
             WHEN g3.strand = '+' THEN '+1'
             WHEN g3.strand = '-' THEN '-1'
             ELSE '.' 
           END AS strand,
           REPLACE(g3.attr, ';', '$dlm') AS atts
    FROM apidbtuning.ApolloUpdate g3
    WHERE g3.na_sequence_id = $srcfeature_id
      AND (g3.type IN ('exon', 'UTR', 'ncRNA', 'mRNA', 'CDS'))
      AND g3.mapping_start <= $rend
      AND g3.mapping_end >= $base_start
  )
  SELECT * FROM transcripts t
  UNION ALL
  SELECT t.attr, 
         t.apolloproduct, 
         t.apollopmid, 
         t.apolloevidencecode, 
         t.apolloobsolete,
         t.feature_id,
         'nc_exon' AS type,
         t.source,
         t.name,
         t.phase,
         t.score,
         t.parent_id,
         t.startm,
         t."end",
         t.apolloid,
         t.strand,
         t.atts
  FROM transcripts p
  JOIN transcripts t ON p.feature_id = t.parent_id
  WHERE p.type = 'ncRNA' AND t.type = 'exon'
) AS combined
GROUP BY apolloproduct, apollopmid, apolloevidencecode, apolloobsolete, feature_id, type, source, name, phase, score, parent_id, startm, "end", apolloid, strand, atts
]]>
  </query>




  <query name="gene:syntenyMC:attribute:Ortholog">
<![CDATA[
select ga2.source_id 
from ApidbTuning.GeneAttributes ga1, ApidbTuning.GeneAttributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
 </query>

  <query name="gene:syntenyJBrowse:attribute:Ortholog">
<![CDATA[
select ga2.source_id 
from ApidbTuning.GeneAttributes ga1, ApidbTuning.GeneAttributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
 </query>

  
  
  <query name="gene:annotation:attribute:Ortholog">
<![CDATA[
select ga2.source_id 
from ApidbTuning.GeneAttributes ga1, ApidbTuning.GeneAttributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
 </query>

  <query name="domain:UnifiedMassSpecPeptides:bulksubfeatures">
<![CDATA[
SELECT  msf.aa_feature_id || fl.start_min || fl.end_max as feature_id,
        'Peptide' type,
        '$source' as source,
        fl.start_min as startm,
        fl.end_max as end,
        msf.aa_feature_id as parent_id,
        decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
        'ExtDbName=' || ed.name atts
 FROM dots.MassSpecFeature msf, apidb.FeatureLocation fl,
       sres.externaldatabaserelease edr, sres.externaldatabase ed
 WHERE msf.na_feature_id = fl.na_feature_id
  AND  fl.start_min >= $base_start 
  AND  fl.end_max <= $rend
  AND  fl.na_sequence_id = $srcfeature_id
  AND  msf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
]]>
  </query>

  <query name="domain:MassSpecPeptide:bulksubfeatures">
<![CDATA[
SELECT  msf.aa_feature_id || fl.start_min || fl.end_max as feature_id,
        'Peptide' type,
        '$source' as source,
        fl.start_min as startm,
        fl.end_max as end,
        msf.aa_feature_id as parent_id,
        decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
        'ExtDbName=' || ed.name atts
 FROM dots.MassSpecFeature msf, apidb.FeatureLocation fl,
       sres.externaldatabaserelease edr, sres.externaldatabase ed
 WHERE msf.na_feature_id = fl.na_feature_id
  AND  fl.start_min >= $base_start 
  AND  fl.end_max <= $rend
  AND  fl.na_sequence_id = $srcfeature_id
  AND  msf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$edName$$
]]>
  </query>

   <query name="UnifiedMassSpecPeptides:density:bulksubfeatures"> 
<![CDATA[ 
SELECT interval feature_id, 
       na_sequence_id as parent_id,
      'UnifiedMassSpecPeptides' type, 
      'density' source,
      count(interval) score, 
      interval * 50 startm, 
      (interval + 1) * 50 end,
      'score=' || count(interval) atts
FROM ( SELECT ceil(nal.start_min /50) interval, nal.na_sequence_id
 FROM  dots.massspecfeature msf,
       apidb.massspecsummary mss,
       apidb.FeatureLocation nal,
       dots.nasequence enas
 WHERE msf.mass_spec_summary_id = mss.mass_spec_summary_id
  AND  msf.na_feature_id = nal.na_feature_id
  AND  nal.na_sequence_id = $srcfeature_id
  AND  enas.na_sequence_id = $srcfeature_id
  AND  nal.start_min >= $base_start
  AND  nal.end_max <= $rend
 ORDER BY nal.start_min)
GROUP BY interval, na_sequence_id
]]> 
  </query>
 

  <query name="alignment:GenericEndFeature:bulksubfeatures">
       <![CDATA[
                SELECT blat.blat_alignment_id feature_id, 
                       'generic_end' type,
                       '$source' source,
                       blat.source_id name, 
                       regexp_substr(blat.$$sourceIdField$$, $$sourceIdRegex$$) parent_id,
                       blat.score, 
                       blat.target_start startm,
                       blat.target_end end,
                       'pct=' || blat.percent_identity atts
                FROM apidbtuning.GenericEndFeature blat
                WHERE blat.target_na_sequence_id = $srcfeature_id
                 AND blat.target_start <= $rend 
                 AND blat.target_end >= $base_start - 1
                 AND (blat.target_end - blat.target_start ) < $$spanLengthCutoff$$
                 AND ('true' = $$includeMultipleSpans$$ OR blat.number_of_spans =1)
                 AND blat.name in ($$edName$$)
       ]]>
  </query>


  <query name="annotation:density:subfeatures">
<![CDATA[
SELECT interval feature_id, 
       $parent_id as parent_id,
      'annotation' type, 
      'density' source, 
      count(interval) score, 
      (interval - 1) * 50000 startm, 
      interval * 50000 end 
FROM ( 
      SELECT ceil(fl.start_min / 50000) interval 
      FROM   ApidbTuning.GeneAttributes gf, apidb.FeatureLocation fl

      WHERE  gf.na_feature_id = fl.na_feature_id and 
             fl.na_sequence_id = $parent_id 
      ORDER BY fl.start_min) 
GROUP BY interval 
]]>
  </query>

  <query name="ORF:density:bulksubfeatures" excludeProjects="ToxoDB,CryptoDB,GiardiaDB"> 
<![CDATA[ 
SELECT interval feature_id, 
       na_sequence_id as parent_id,
      'ORF' type, 
      'density' source,
      count(interval) score, 
      interval * 500 startm, 
      (interval + 1) * 500 end,
      'score=' || count(interval) atts
FROM ( 
   SELECT ceil(start_min /500) interval, na_sequence_id
   FROM   apidb.FeatureLocation 
   WHERE  end_max - start_min + 1 >= $$minLength$$
      AND na_sequence_id = $srcfeature_id
      AND start_min >= $base_start - 1 
      AND end_max <= $rend
ORDER BY start_min)
GROUP BY interval, na_sequence_id
]]> 
  </query> 

  <query name="SNP:Diversity:bulksubfeatures"  includeProjects="PlasmoDB,ToxoDB,UniDB">
<![CDATA[
SELECT 
       gff3.gff3_feature_id          as feature_id,
       'SNP_sub'                     as type, 
       '$source'                     as source, 
       gff3.score                    as score, 
       gff3.na_sequence_id           as parent_id, 
       gff3.mapping_start            as startm, 
       gff3.mapping_end              as end, 
       decode(gff3.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   ApiDB.GFF3 gff3,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr
WHERE  ed.name = $$edname$$
  AND  edr.external_database_id = ed.external_database_id
  AND  gff3.external_database_release_id = edr.external_database_release_id
  AND  gff3.na_sequence_id = $srcfeature_id
  AND  gff3.mapping_start <= $rend
  AND  gff3.mapping_end >= $base_start
]]>
  </query> 

  <query name="domain:tss:bulksubfeatures" includeProjects="FungiDB,UniDB">
<![CDATA[
SELECT distinct ssf.segment_start as  feature_id,
       'domain' type, 
       '$source' as source,
       sum(ssf.count_per_million) as score, 
       ssf.na_sequence_id  || ssf.strand parent_id,
       ssf.segment_start as startm, 
       ssf.segment_start as end, 
       decode(ssf.strand, '+',1,'-', -1, '.') as strand
 FROM 
   study.study i, study.study s, study.studylink sl,
   study.protocolAppNode pan, apidb.spliceSiteFeature ssf
 WHERE ssf.na_sequence_id =  $srcfeature_id
   AND ssf.segment_start >=  $base_start
   AND ssf.segment_end <= $rend
   AND ssf.type = $$featType$$
   AND pan.protocol_app_NODE_ID = ssf.protocol_app_node_id
   AND pan.protocol_app_node_id = sl.protocol_app_node_id
   and sl.study_id = s.study_id
   and s.name like '%[feature_loc]'
   and s.investigation_id = i.study_id
   and i.name like  $$edName$$
   and ssf.count_per_million > $$minCntPerMill$$
  GROUP BY  ssf.segment_start, ssf.strand, ssf.na_sequence_id
]]>
  </query>

  <query name="gene:syntenyJBrowse:bulksubfeatures">

<![CDATA[
SELECT
       sg.synteny_id || '_synexons_' || sg.syn_na_feature_id feature_id,
       'exon' type,
       'syntenyJBrowse' source,
       sg.syn_na_feature_id name,
       '.' score,
       sg.synteny_id || '_syngene_' || sg.syn_na_feature_id parent_id,
       sg.start_min startm,
       sg.end_max end,
       decode(sg.is_reversed, 0, +1, 1, -1, +1) strand,
       sg.tstarts TSTARTS,
       sg.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       ApiDB.SyntenicGene sg
WHERE sg.na_sequence_id = $srcfeature_id
  AND sg.start_min <= $rend
  AND sg.end_max >= $base_start
UNION
SELECT distinct exon_loc.na_feature_id || '_refexon' feature_id, 
       'exon' type, 
       'annotation' source, 
       exon_loc.na_feature_id name,
       '.' score,
       'refgene_' || exon_loc.parent_id,
       exon_loc.start_min as startm,
       exon_loc.end_max as end,
       decode (exon_loc.is_reversed, 0, +1, 1, -1, +1) strand,
       '' tstarts,
       '' blocksizes,
       ' ' atts 
FROM   
       apidb.FeatureLocation exon_loc, ApidbTuning.TranscriptAttributes ta, dots.rnafeatureexon rfe
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  AND  exon_loc.feature_type = 'ExonFeature'
  AND  exon_loc.start_min <= $rend
  AND  exon_loc.end_max >= $base_start
  AND rfe.exon_feature_id = exon_loc.na_feature_id
  AND ta.na_feature_id = rfe.rna_feature_id
UNION
SELECT
       ss.synteny_id || '_minispans_' || ss.syntenic_scale_id feature_id,
       'minispan' type,
       'syntenyJBrowse' source,
       ss.syntenic_scale_id name,
       '.' score,
       ss.synteny_id || '_synseq_' || s.b_na_sequence_id parent_id,
       ss.start_min startm,
       ss.end_max end,
        decode(s.is_reversed, 0, +1, 1, -1, +1) strand,
       '' tstarts,
       '' blocksizes,
      'scale=' || ss.scale atts
 FROM Apidb.Synteny s,
       Apidb.SyntenicScale ss
 WHERE s.synteny_id = ss.synteny_id
 AND ss.na_sequence_id = $srcfeature_id
 AND ss.start_min <= $rend
 AND ss.end_max >= $base_start
 and abs(ss.scale) > 1.5
]]>
  </query>

  <query name="gene:syntenyJBrowseScaled:bulksubfeatures">

<![CDATA[
-- for syntenic genes
select * from (
select * from (
-- first get all exons in the visible region
with syn_genes as (
select sg.synteny_id
     , fl.start_min syn_exon_start 
     , fl.end_max syn_exon_end
     , fl.na_sequence_id as syn_na_sequence_id
     , fl.na_feature_id as syn_na_feature_id
     , sg.syn_organism_abbrev
     , sg.is_reversed as syn_gene_is_reversed
     , sg.start_min ref_gene_start
     , sg.end_max ref_gene_end
     , sg.na_sequence_id ref_na_sequence_id
     , fl.parent_id
     , fl.feature_type
from apidb.syntenicgene sg, 
     apidb.featurelocation fl
where sg.na_sequence_id = $srcfeature_id
  AND sg.start_min <=  $$visibleRegionEnd$$
  AND sg.end_max >=  $$visibleRegionStart$$
  AND sg.syn_na_feature_id = fl.parent_id
  and fl.feature_type in ('Transcript')
UNION ALL
select sg.synteny_id
     , fl.start_min syn_exon_start 
     , fl.end_max syn_exon_end
     , fl.na_sequence_id as syn_na_sequence_id
     , fl.na_feature_id as syn_na_feature_id
     , sg.syn_organism_abbrev
     , sg.is_reversed as syn_gene_is_reversed
     , sg.start_min ref_gene_start
     , sg.end_max ref_gene_end
     , sg.na_sequence_id ref_na_sequence_id
     , fl.parent_id
     , fl.feature_type
from apidb.syntenicgene sg, 
     apidb.featurelocation fl, 
     apidbtuning.transcriptattributes ta
where sg.na_sequence_id = $srcfeature_id
  AND sg.start_min <=  $$visibleRegionEnd$$
  AND sg.end_max >=  $$visibleRegionStart$$
  AND sg.syn_na_feature_id = ta.gene_na_feature_id
  and fl.feature_type in ('CDS', 'five_prime_UTR', 'three_prime_UTR')
  and ta.na_feature_id = fl.parent_id
),
-- calc stats for scaling
sscale as (
select synteny_id
     , min(syn_exon_start) syn_min
     , max(syn_exon_end) syn_max
     , max(syn_exon_end) - min(syn_exon_start) + 1 as syn_length
     , min(ref_gene_start) ref_min
     , max(ref_gene_end) ref_max
     , max(ref_gene_end) - min(ref_gene_start) + 1 as ref_length
from syn_genes
group by synteny_id),
-- calc exon coords in ref space
scaled_syngenes as (
select sg.syn_na_sequence_id
     , sg.syn_na_feature_id
     , sg.syn_organism_abbrev
     , sg.synteny_id
     , CASE WHEN s.is_reversed = 1 
            THEN round(ref_max - (((syn_exon_end - syn_min + 1) / syn_length) * ref_length))
            ELSE round(ref_min + (((syn_exon_start - syn_min + 1) / syn_length) * ref_length)) 
        END as s
     , CASE WHEN s.is_reversed = 1 
            THEN round(ref_max - (((syn_exon_start - syn_min + 1) / syn_length) * ref_length))
            ELSE round(ref_min + (((syn_exon_end - syn_min + 1) / syn_length) * ref_length))
        END as e
     , sg.syn_gene_is_reversed
     , ref_na_sequence_id
     , sg.parent_id
     , sg.feature_type
from syn_genes sg,
     sscale ss,
     apidb.synteny s
where sg.synteny_id = s.synteny_id
 and ss.synteny_id = s.synteny_id
)
-- SynTranscripts
SELECT sg.synteny_id || '_syntranscript_' || sg.syn_na_feature_id as feature_id,
       case when so_term_name in ('protein_coding_gene', 'transposable_element_gene') then 'processed_transcript' else 'nc_transcript' end as type,
       'syntenyJBrowseScaled' source,
       sg.syn_na_feature_id name,
       '.' score,
       sg.synteny_id || '_syngene_' || sg.parent_id parent_id,
       sg.s startm,
       sg.e end,
       decode(sg.syn_gene_is_reversed, 0, +1, 1, -1, +1) strand,
       ' ' atts,
       1 as has_children
FROM   scaled_syngenes sg,
       ApidbTuning.TranscriptAttributes gattr
WHERE sg.feature_type = 'Transcript'
  AND sg.ref_na_sequence_id = $srcfeature_id
  AND sg.s <= $rend
  AND sg.e >= $base_start
  AND sg.syn_na_feature_id = gattr.na_feature_id
UNION ALL
-- Syn UTR/CDS
SELECT sg.syn_na_feature_id || '_syncdsorutr' as feature_id,
       sg.feature_type type,
       'syntenyJBrowseScaled' source,
       sg.syn_na_feature_id name,
       '.' score,
       sg.synteny_id || '_syntranscript_' || sg.parent_id parent_id,
       sg.s startm,
       sg.e end,
       decode(sg.syn_gene_is_reversed, 0, +1, 1, -1, +1) strand,
       ' ' atts,
       0 as has_children
FROM   scaled_syngenes sg
WHERE sg.feature_type in ('CDS', 'five_prime_UTR', 'three_prime_UTR')
  AND sg.ref_na_sequence_id = $srcfeature_id
  AND sg.s <= $rend
  AND sg.e >= $base_start
)
UNION ALL
-- Transcipts
SELECT distinct loc.na_feature_id || '_reftranscript' feature_id, 
       case when ta.so_term_name in ('protein_coding_gene', 'transposable_element_gene') then 'processed_transcript' else 'nc_transcript' end as type,
       'annotation' source, 
       loc.na_feature_id name,
       '.' score,
       'refgene_' || loc.parent_id as parent,
       loc.start_min as startm,
       loc.end_max as end,
       decode (loc.is_reversed, 0, +1, 1, -1, +1) strand,
       ' ' atts ,
       1 as has_children
FROM   
       apidb.FeatureLocation loc, ApidbTuning.TranscriptAttributes ta
WHERE  loc.na_sequence_id = $srcfeature_id
  AND  loc.feature_type = 'Transcript'
  AND  loc.start_min <= $$visibleRegionEnd$$
  AND  loc.end_max >= $$visibleRegionStart$$
  AND loc.na_feature_id = ta.na_feature_id
UNION ALL
-- UTR / CDS
SELECT distinct loc.feature_location_id || '_refexon' feature_id, 
       loc.feature_type type, 
       'annotation' source, 
       loc.na_feature_id name,
       '.' score,
       loc.parent_id || '_reftranscript' as parent,
       loc.start_min as startm,
       loc.end_max as end,
       decode (loc.is_reversed, 0, +1, 1, -1, +1) strand,
       ' ' atts ,
      0 as has_children
FROM   
       apidb.FeatureLocation loc, ApidbTuning.TranscriptAttributes ta
WHERE  loc.na_sequence_id = $srcfeature_id
  AND  loc.feature_type in ( 'CDS', 'five_prime_UTR', 'three_prime_UTR')
  AND  loc.start_min <= $$visibleRegionEnd$$
  AND  loc.end_max >= $$visibleRegionStart$$
  AND  ta.na_feature_id = loc.parent_id
) order by has_children desc
--SELECT distinct exon_loc.na_feature_id || '_refexon' feature_id, 
--       'exon' type, 
--       'annotation' source, 
--       exon_loc.na_feature_id name,
--       '.' score,
--       'refgene_' || exon_loc.parent_id,
--       exon_loc.start_min as startm,
--       exon_loc.end_max as end,
--       decode (exon_loc.is_reversed, 0, +1, 1, -1, +1) strand,
--       ' ' atts 
--FROM   
--       apidb.FeatureLocation loc, ApidbTuning.TranscriptAttributes ta, dots.rnafeatureexon rfe
--WHERE  exon_loc.na_sequence_id = $srcfeature_id
--  AND  exon_loc.feature_type = 'ExonFeature'
--  AND  exon_loc.start_min <= $rend
--  AND  exon_loc.end_max >= $base_start
--  AND rfe.exon_feature_id = exon_loc.na_feature_id
--  AND ta.na_feature_id = rfe.rna_feature_id
]]>
  </query>

  <query name="gene:syntenyMC:bulksubfeatures">
<![CDATA[
SELECT
* FROM (SELECT
       exfloc.na_feature_id feature_id,
       'CDS' type, 
       'syntenyMC' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                             anch_left.ref_loc, anch_right.ref_loc,
                             anch_left.syntenic_loc, anch_right.syntenic_loc,
                             syn.b_start, syn.b_end) startm,
       apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                          anch_left.ref_loc, anch_right.ref_loc,
                          anch_left.syntenic_loc, anch_right.syntenic_loc,
                          syn.b_start, syn.b_end) end,
       CASE WHEN (exfloc.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'isDeprecated=' atts 
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       apidb.FeatureLocation exfloc
WHERE syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND anch_left.ref_loc != anch_right.ref_loc
  AND exfloc.feature_type = 'ExonFeature'
  AND exfloc.na_sequence_id = syn.b_na_sequence_id 
  AND apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                            anch_left.ref_loc, anch_right.ref_loc,
                            anch_left.syntenic_loc, anch_right.syntenic_loc,
                            syn.b_start, syn.b_end) <= $rend
  AND apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                         anch_left.ref_loc, anch_right.ref_loc,
                         anch_left.syntenic_loc, anch_right.syntenic_loc,
                         syn.b_start, syn.b_end) >= $base_start
  AND exfloc.start_min <= syn.b_end
  AND exfloc.end_max >= syn.b_start
UNION ALL
-- for: reference organism - gene
SELECT
       exfloc.na_feature_id feature_id,
       'CDS' type, 
       'syntenyMC' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       CASE WHEN exfloc.is_reversed = 0 THEN
         exfloc.start_min ELSE exfloc.end_max END as startm,
       CASE WHEN exfloc.is_reversed = 0 THEN
         exfloc.end_max ELSE exfloc.start_min END as end,
       decode (exfloc.is_reversed, 0, +1, 1, -1,+1) strand,
       'isDeprecated=' atts 
FROM 
       apidb.FeatureLocation exfloc
WHERE exfloc.na_sequence_id = $srcfeature_id
  AND exfloc.start_min <= $rend
  AND exfloc.end_max >= $base_start
  AND exfloc.feature_type = 'ExonFeature'
)
WHERE startm <= $rend
  AND end >= $base_start

]]>
  </query>
  
  <query name="match:WU_BLASTX:bulksubfeatures">
<![CDATA[
 SELECT sim.similarity_span_id feature_id, 
       sim.similarity_id as parent_id,
       'HSP' type, 
       'WU_BLASTX' source, 
       sim.similarity_span_id name, 
       '.' phase, 
       sim.span_score || '' score, 
       sim.query_start startm, 
       sim.query_end end, 
       decode (sim.span_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       '' atts 
FROM   ApidbTuning.SimilaritySpanLocation sim
WHERE  sim.query_id = $srcfeature_id
AND    (sim.max_query_end - sim.min_query_start) < 5000
AND    to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) < 1e-10 
AND    sim.min_query_start >= $base_start 
AND    sim.max_query_end <= $rend
]]>
  </query>
  
  <query name="alignment:dbEST:bulksubfeatures">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'dbEST' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       dots.BlatAlignment blat,
       dots.EST est,
       dots.EXTERNALNASEQUENCE etn
WHERE  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.target_na_sequence_id = $srcfeature_id
  AND  est.na_sequence_id = blat.query_na_sequence_id
  AND  etn.na_sequence_id = est.na_sequence_id
ORDER BY
       blat.target_start
]]>
  </query>
  
  <query name="alignment:BLAT:seq" excludeProjects="PlasmoDB,TriTrypDB,ToxoDB">
<![CDATA[
SELECT est.na_sequence_id, est.source_id, est.sequence
FROM   DOTS.NASEQUENCE est
WHERE  est.source_id = '$name'
]]>
  </query>

  <query name="scaffold:genome:bulksubfeatures">
<![CDATA[
SELECT sg.na_feature_id as feature_id,
       'gap' type,
       'genome' source,
       sg.source_id name,
       sg.na_feature_id parent_id,
       fl.start_min as startm,
       fl.end_max as end,
       '0' as strand,
       'Type=sgap' as atts
FROM   DoTS.ScaffoldGapFeature sg,
       DoTS.NaLocation fl,
       ApidbTuning.GenomicSeqAttributes gsa
WHERE  fl.na_feature_id = sg.na_feature_id
   AND gsa.na_sequence_id = sg.na_sequence_id
   AND gsa.na_sequence_id = $srcfeature_id
   AND fl.start_min < $rend 
   AND fl.end_max > $base_start
]]>
  </query>
 

  <query name="gene:AlternateModels:bulksubfeatures">
<![CDATA[
SELECT
       fl.na_feature_id feature_id, 
       'exon' type, 
       '$source' source, 
       fl.na_feature_id name,
       gf.na_feature_id parent_id, 
       '.' score, 
       fl.start_min startm,            
       fl.end_max end, 
       ed.name||':'||edr.version external_database_name,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SecondaryScore=' || gf.secondary_score || '$dlm' ||
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM   
      dots.GeneFeature gf,
       apidb.FeatureLocation fl,
       apidb.FeatureLocation fl_gf,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed,
       ApidbTuning.GeneAttributes ga
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.feature_type = 'ExonFeature'
  AND  gf.na_feature_id = fl.parent_id
  AND  fl_gf.na_feature_id = gf.na_feature_id
  AND  fl_gf.start_min <= $rend
  AND  fl_gf.end_max >= $base_start
  AND  gf.external_database_release_id = edr.external_database_release_id 
  AND  edr.external_database_id = ed.external_database_id 
  AND  fl_gf.na_sequence_id = fl.na_sequence_id
  AND  ga.na_feature_id (+) = fl.parent_id
  AND  ed.name = $$extDbName$$ 
ORDER BY 
       fl.start_min
]]>
  </query>
  
  <query name="gene:OldModels:bulksubfeatures" includeProjects="PlasmoDB,ToxoDB,UniDB">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   dots.BlatAlignment blat, 
       dots.externalnasequence enas,
       dots.NASEQUENCE etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.is_best_alignment = 1
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name like '%_old_transcript_sequences_RSRC%'
ORDER BY blat.target_start
]]>
  </query>

  <query name="alignment:sequence:bulksubfeatures" includeProjects="AmoebaDB,CryptoDB,FungiDB,GiardiaDB,TriTrypDB,ToxoDB,VectorBase,UniDB">
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   dots.BlatAlignment blat, 
       dots.externalnasequence enas,
       dots.NASEQUENCE etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.is_best_alignment = 1
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name = $$edName$$
]]>
  </query>
  
  <query name="SNP:density:subfeatures"  includeProjects="ToxoDB,AmoebaDB,TriTrypDB,CryptoDB,PlasmoDB,FungiDB,UniDB">
<![CDATA[
 SELECT interval feature_id, 
      'SNP' type, 
      'density' source, 
      count(interval) score, 
      (interval - 1) * 50000 startm, 
      interval * 50000 end 
FROM (
      SELECT ceil(sa.location/ 50000) interval
      FROM   apidb.sequenceVariation sv, ApidbTuning.SnpAttributes sa
      WHERE  sv.location = sa.location
       AND   sv.ref_na_sequence_id = sa.na_sequence_id
       AND   sa.na_sequence_id = $parent_id
      ORDER BY sa.location )
GROUP BY interval
]]>
  </query>
  
  <query name="GeneticMarkers:Sibley:bulkAttribute"  includeProjects="ToxoDB,UniDB">
<![CDATA[
SELECT    sa.na_feature_id as feature_id,
          var.strain,
          var.allele,
          var.phenotype,
          var.product
FROM ApidbTuning.SnpAttributesdots sa,
     dots.SeqVariation var,
     apidb.FeatureLocation fl
WHERE fl.na_sequence_id = $srcfeature_id
  AND fl.start_min <= $rend
  AND fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND  sa.dataset = 'tgonME49_SNP_Sibley_Tg10x_31_gff_RSRC'
  AND var.parent_id = fl.na_feature_id
 ORDER BY var.strain
 
]]>
  </query>

  <query name="ChIP:ChIPchip_smoothed:bulksubfeatures" includeProjects="FungiDB,PlasmoDB, ToxoDB, TriTrypDB,UniDB">
        <![CDATA[
        SELECT
        feature_id
        , type
        , source
        , score
        , parent_id || '_' || nvl(max(subtrack), ' ') as parent_id
        , startm
        , end
        , listagg (attr, '$dlm' on overflow truncate) within group (order by attr) as atts
        FROM (
            WITH data AS (    
                SELECT DISTINCT
                pan.name as feature_id
                , 'ChIP' as type
                , '$source' as source
                , sr.score1 as score
                , s.name as parent_id
                , sr.segment_start as startm
                , sr.segment_end as end
                , '$$exp$$' as dataset_name
                , pan.protocol_app_node_id as pan
                FROM
                study.study s
                , study.studylink sl
                , study.protocolappnode pan
                , results.segmentresult sr
                WHERE s.name =  '$$exp$$ - smoothed'
                AND sl.study_id = s.study_id
                AND pan.protocol_app_node_id = sl.protocol_app_node_id
                AND sr.protocol_app_node_id = pan.protocol_app_node_id
                AND sr.na_sequence_id = $srcfeature_id
                AND sr.segment_start <= $rend
                AND sr.segment_end >= $base_start
                )
            SELECT d.*
            , m.property || '=' || m.string_value as attr
            , CASE WHEN m.property = '$$sub$$' THEN m.string_value END as subtrack
            FROM data d
            LEFT OUTER JOIN apidbtuning.metadata m ON
                (m.dataset_name = d.dataset_name
                AND m.pan_id = d.pan)
            )
        GROUP BY feature_id, type, source, score, parent_id, startm, end
        ]]>
  </query>

  
  <query name="mapp:promoters:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT location feature_id, 
             'mapp' type, 
             'promoters' source, 
             '' name, 
             value score, 
             na_sequence_id || '_' || strand parent_id, 
             location startm, 
             location end, 
             strand,
             '' atts
       FROM  ApiDB.plasmoMapp
       WHERE na_sequence_id = $srcfeature_id 
         AND location <= $rend
         AND location >= $base_start - 1 
]]>
  </query>
 
  <query name="SNP:Population:bulkAttribute"  includeProjects="ToxoDB,AmoebaDB,TriTrypDB,CryptoDB,PlasmoDB,FungiDB,UniDB">
<![CDATA[
SELECT sa.source_id as feature_id, var.strain, var.allele, var.product
FROM ApidbTuning.SnpAttributes sa,
     apidb.SequenceVariation var
WHERE sa.dataset = $$edname$$
  AND sa.na_sequence_id = $srcfeature_id
  AND sa.location <= $rend
  AND sa.location >= $base_start
  AND var.location = sa.location
  AND var.ref_na_sequence_id = sa.na_sequence_id
ORDER BY var.strain
]]>
  </query>
  
   <query name="MicroArrayProbes:expressionH:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
SELECT interval as feature_id,
       $srcfeature_id as parent_id,
       'MicroArrayProbes' type, 
       '$source' source,
       count(interval) score, 
       (interval - 1) * 1000 startm, 
       interval * 1000 end
FROM
(
  SELECT ceil(fl.start_min / 1000) interval 
  FROM   apidb.FeatureLocation fl, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
  WHERE  edr.external_database_id = ed.external_database_id
    AND  edr.external_database_release_id=fl.external_database_release_id
    AND  fl.feature_type = 'ArrayElementFeature'
    AND  ed.name = $$edname$$
    AND  fl.start_min <= $rend
    AND  fl.end_max >= $base_start
    AND  fl.na_sequence_id = $srcfeature_id
) 
GROUP BY interval
]]>
  </query>

    <query name="rnaseq:gcsample_blat:bulksubfeatures"  includeProjects="TriTrypDB,UniDB">
<![CDATA[
      SELECT rc.location feature_id, 
             'rnaseq' type, 
             'gcsample_blat' source, 
             '' name, 
             rc.coverage score, 
             'gcsample_id' parent_id, 
             rc.location startm, 
             rc.location end, 
             '+1' strand,
             'binaryColor='||rc.multiple atts
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'GC_sample'
         AND rc.type = 'max14'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
]]>
  </query>

    <query name="rnaseq:gcpfwt:bulksubfeatures"  includeProjects="TriTrypDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'gcpfwt' source, 
             CASE WHEN multiple = 1 THEN min(coverage) ELSE max(coverage) END score, 
             'gcpfwt_id' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||multiple atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage,rc.multiple
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'PF_WT'
         AND rc.type = 'bt'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,multiple
]]>
  </query>

    <query name="rnaseq:gcbfall:bulksubfeatures"  includeProjects="TriTrypDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'gcbfall' source, 
             CASE WHEN multiple = 1 THEN min(coverage) ELSE max(coverage) END score, 
             'gcbfall_id' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||multiple atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage,rc.multiple
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'BF_All'
         AND rc.type = 'bt'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,multiple
]]>
  </query>

    <query name="rnaseq:cn_three_samples:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT sample||interval feature_id, 
             'rnaseq' type, 
             'cn_three_samples' source, 
             power(2,max(coverage)) score, 
             'cn_three_sample' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'sample='||sample atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage, rc.sample
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('24h','8h','40h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,sample
]]>
  </query>

    <query name="rnaseq:cn_four_samples:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT sample||interval feature_id, 
             'rnaseq' type, 
             'cn_four_samples' source, 
             power(2,max(coverage)) score, 
             'cn_four_sample' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'sample='||sample atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage, rc.sample
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('0h','16h','32h','48h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,sample
]]>
  </query>

    <query name="rnaseq:cn_pf0h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf0h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_0h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '0h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf8h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf8h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_8h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '8h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf16h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf16h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_16h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '16h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf24h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf24h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_24h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '24h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf32h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf32h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_32h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '32h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf40h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf40h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_40h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '40h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

    <query name="rnaseq:cn_pf48h_lin:bulksubfeatures"  includeProjects="PlasmoDB,UniDB">
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf48h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_48h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '48h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
  </query>

  
  <query name="Haplotype:Block:bulksubfeatures">
<![CDATA[
SELECT  cef.source_id feature_id, 
       'Haplotype_Inner' type, 
       'Block' source, 
       cef.name name,
       cef.na_feature_id parent_id, 
       '.' score, 
       nl.start_max startm,            
       nl.end_min end, 
       'Boundary=' || 'Conservative'  || '$dlm' ||'Name=' || cef.name  || '$dlm' || 'SequenceId=' || ens.source_id  as atts
FROM    DoTS.ChromosomeElementFeature cef, Dots.NaLocation nl, DoTS.ExternalNASequence ens
         WHERE  cef.na_sequence_id = $srcfeature_id 
         AND    cef.na_feature_id = nl.na_feature_id 
         AND    ens.na_sequence_id = cef.na_sequence_id
         AND    nl.start_max <= $rend
         AND    nl.end_min >= $base_start
]]>
  </query>




</staticQueries>
