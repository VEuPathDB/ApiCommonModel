#!/usr/bin/perl

use strict;
use lib $ENV{GUS_HOME} . "/lib/perl";
use JSON;
use ApiCommonModel::Model::JBrowseUtil;
use ApiCommonModel::Model::JBrowseTrackConfig::Segments;
use ApiCommonModel::Model::JBrowseTrackConfig::NrdbProteinTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::UnifiedMassSpecTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::UnifiedSnpTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::ScaffoldsTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::CentromereTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::TrnaTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::PopsetsTrackConfig;
#use ApiCommonModel::Model::JBrowseTrackConfig::VcfTrack;
use Data::Dumper;
use URI::Escape;

use Storable 'dclone';
use Tie::IxHash;

my %datasets;
my $t = tie %datasets, 'Tie::IxHash';


my ($organismAbbrev, $projectName, $isApollo, $buildNumber, $applicationType) = @ARGV;

my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName, organismAbbrev => $organismAbbrev, fileName => "_organismSpecificCache.json"});

my $buildProps = $jbrowseUtil->getBuildProperties();

#my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName});

my $dbh = $jbrowseUtil->getDbh();   

my $result = {"tracks" => [] };
#my $result = {"tracks" => []};

### Get organism properties
my $orgHash = ($buildProps->{'organism'});
my $nameForFileNames = ($orgHash->{organismNameForFiles});
my $projectName = ($orgHash->{projectName});
my $isAnnotated = ($orgHash->{isAnnotatedGenome});
#print "NfFN=$nameForFileNames\n";

&addScaffolds($dbh, $result);

&addCentromere($dbh, $result);

&addUnifiedMassSpec($dbh, $result);
&addUnifiedSnp($dbh, $result);

# TODO: Add back
# &addSynteny($dbh, $result);
&addDatasets($dbh, \%datasets) unless($isApollo);

my $datasetProperties = &datasetProperties($dbh);

#&addChipChipTracks($dbh, $result, $datasetProperties);
&addSmallNcRnaSeq($dbh, $result, $datasetProperties);

# TODO: Add back
# &addProteinExpressionMassSpec($dbh, $result, $datasetProperties);
&addVCF($dbh, $result, $datasetProperties);
#&addGFF($dbh, $result, $datasetProperties);

# TODO: Add back
&addTRNA($dbh, $result, $datasetProperties);
if ($projectName !~ m/HostDB/ && $organismAbbrev !~ m/cgloCBS148.51/ && $organismAbbrev !~ m/pgig/ && $organismAbbrev !~ m/amutUAMH3576/ && $organismAbbrev !~ m/anigUAMH3544/ && $organismAbbrev !~ m/bcerUAMH5669/){
  &addNrdbProteinAlignments($dbh, $result, $datasetProperties, $projectName);
}

# TODO: Add back
&addPopsets($dbh, $result, $datasetProperties);

if ($organismAbbrev !~ m/dmeliso-1/ ){
# TODO: Add back
# &addApolloGFF($dbh, $result);
}
&addMergedRnaSeq($dbh, $result, $datasetProperties, $projectName);

# other organism specific tracks
if($organismAbbrev eq 'tcruCLBrenerEsmeraldo-like') {
# TODO: Add back
# &addCnvArray($dbh, $result);
}
# TODO: Add back
#if ($isAnnotated eq 'true'){
#    &addAnnotatedGenome($dbh, $result, $datasetProperties);
#}
#&addFastaAssemblyTrack($dbh, $result, $datasetProperties);

unless($isApollo) {
  $result->{datasets} = \%datasets;
  $result->{dataset_id} = $organismAbbrev;
}

print encode_json($result);
# TODO: make new method to add GFF
#sub addAnnotatedGenome {
#    my annotatedGffTrack;
#    my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/gff/annotated_transcripts.gff.gz");
#    my $annotatedGenomeTrack = ApiCommonModel::Model::JBrowseTrackConfig::AnnotatedGenomeTrackConfig->new({dataset_name => $dsName,
#                                                                                                url_template => $gffUrl,
#                                                                                                application_type => $applicationType,
#                                                                                                label => $label,
                                                                                                #strand =>  $strand,
#                                                                                                category => $category,
#                                                                                                subcategory => $subCategory,
#                                                                                                attribution => $shortAttribution,
#                                                                                                summary => $summary,
                                                                                                #alignment => $alignment,
#                                                                                                organism_abbrev => $organismAbbrev
#                                                                                              })->getConfigurationObject();
#}
# TODO: make new method to add FASTA
#sub addFastaAssemblyTrack{
#    my fastaAssembly;
#    my $fastaFile = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/fasta/genome.fasta");
#}

sub addDatasets {
  my ($dbh) = @_;
  #Public facing track requires public_abbrev here!
  my $sql = "select public_abbrev, organism_name FROM APidbtuning.organismattributes order by organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($abbrev, $name) = $sh->fetchrow_array()) {
    $datasets{$abbrev}->{name} = $name;
    $datasets{$abbrev}->{url} = "?data=/a/service/jbrowse/tracks/${abbrev}";
#    $result->{datasets}->{$abbrev}->{name} = $name;
#    $result->{datasets}->{$abbrev}->{url} = "?data=tracks/${abbrev}";
  }
  $sh->finish();
}

sub datasetProperties {
  my ($dbh) = @_;

  my $sql = "select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_chipChipExper%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dnt.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
   , apidbtuning.datasetnametaxon dnt
where dnt.name like '${organismAbbrev}%_ebi_VCF_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
and dsp.dataset_presenter_id = dnt.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_ebi_GFF3_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_ebi_rnaSeq_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}_smallNcRna_%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select distinct dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
from apidbtuning.datasetnametaxon dnt,
     apidbtuning.datasetproperty prop,
     apidbtuning.datasetpresenter dsp,
     apidb.organism o
where dnt.taxon_id = o.taxon_id
and o.abbrev = '${organismAbbrev}'
and dnt.name like '%_massSpec%_RSRC'
and dnt.dataset_presenter_id = prop.dataset_presenter_id
and prop.dataset_presenter_id = dsp.dataset_presenter_id
";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my %datasetProperties;
  while(my ($datasetName, $datasetPresenterId, $prop, $val, $extdbName) = $sh->fetchrow_array()) {
    $datasetProperties{$datasetName}->{$prop} = $val;
    $datasetProperties{$datasetName}->{datasetPresenterId} = $datasetPresenterId;
    $datasetProperties{$datasetName}->{datasetExtdbName} = $extdbName;
  }
  $sh->finish();

  return \%datasetProperties;
}

sub addVCF {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /VCF/);
    
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;;
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset;
      my ($vcfFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;
      my $keyName = $vcfFileName;
 	  $keyName =~ s/_/ /g;
      my $vcfUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/vcf/${sampleName}/${vcfFileName}.vcf.gz");
#      my $alignment = {my $alignment = {storeClass => "JBrowse/Store/SeqFeature/VCFTabix",
#                       urlTemplate => $vcfUrl,
#                           #key => "${vcfFileName} SNPs from VCF",
#                           key => "$keyName SNPs from VCF",
#                           label => "${sampleName} SNPs",
#                           type => "JBrowse/View/Track/CanvasVariants",
#                           glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
#                           category => "Genetic Variation",
#                           chunkSizeLimit => '10000000',
#                           metadata => {
#                             subcategory => 'DNA polymorphism',
#                             dataset => $datasetDisplayName,
#                             trackType => 'VCF from VectorBase',
#                             attribution => $shortAttribution,
#                             description => $summary,
#                           },
#                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
#                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
#      };

      my $alignment = ApiCommonModel::Model::JBrowseTrackConfig::VcfTrackConfig->new({
                                                                                                store_type => "JBrowse/Store/SeqFeature/VCFTabix",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                key => "$keyName SNPs from VCF",
                                                                                                label => "${sampleName} SNPs",
                                                                                                category => "Genetic Variation",
                                                                                                subcategory => "DNA polymorphism",
                                                                                                url_template => $vcfUrl,
                                                                                                application_type => $applicationType,
                                                                                                chunkSizeLimit => '10000000',
                                                                                                trackType => 'VCF from VectorBase',
                                                                                                attribution => $shortAttribution,
                                                                                                description => $summary,
                                                                                                glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
                                                                                                fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                                                                                                fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",

                                                                                              })->getConfigurationObject();

      push @{$result->{tracks}}, $alignment;
    }
  }
}

#sub addGFF {
#  my ($dbh, $result, $datasetProperties) = @_;
#
#  foreach my $dataset (keys %$datasetProperties) {
#    next unless($dataset =~ /GFF/);
#
#    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_GFF3_RSRC/;;
#    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
#    my $summary = $datasetProperties->{$dataset}->{summary};
#    $summary =~ s/\n/ /g;
#    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};
#
#    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '$dataset'";
#    my $sh = $dbh->prepare($sql);
#    $sh->execute();
#
#    my %lookup = (aaegLVP_AGWG => 'Aedes aegypti LVP_AGWG %5BAaegL5.2%5D',
#                  aalbSTECLA => 'Anopheles albimanus STECLA %5BAalbS2.6%5D',
#                  aaraDongola => 'Anopheles arabiensis Dongola %5BAaraD1.11%5D',
#                  aatrEBRO => 'Anopheles atroparvus EBRO %5BAatrE3.1%5D',
#                  achrACHKN1017 => 'Anopheles christyi ACHKN1017 %5BAchrA1.7%5D',
#                  acolNgousso => 'Anopheles coluzzii Ngousso %5BAcolN1.0%5D',
#                  'aculA-37' => 'Anopheles culicifacies A-37 %5BAculA1.6%5D',
#                  adarCoari => 'Anopheles darlingi Coari %5BAdarC3.8%5D',
#                  adirWRAIR2 => 'Anopheles dirus WRAIR2 %5BAdirW1.8%5D',
#                  aepiEpiroticus2 => 'Anopheles epiroticus Epiroticus2 %5BAepiE1.7%5D',
#                  afarFAR1 => 'Anopheles farauti FAR1 %5BAfarF2.6%5D',
#                  afunFUMOZ => 'Anopheles funestus FUMOZ %5BAfunF3.1%5D',
#                  agamPEST => 'Anopheles gambiae str. PEST %5BAgamP4.12%5D',
#                  amacmaculatus3 => 'Anopheles maculatus maculatus3 %5BAmacM1.5%5D',
#                  amelCM1001059 => 'Anopheles melas CM1001059_A %5BAmelC2.6%5D',
#                  amerMAF => 'Anopheles merus MAF %5BAmerM2.9%5D',
#                  aminMINIMUS1 => 'Anopheles minimus MINIMUS1 %5BAminM1.8%5D',
#                  aquaSANGWE => 'Anopheles quadriannulatus SANGWE %5BAquaS1.11%5D',
#                  asinSINENSIS => 'Anopheles sinensis SINENSIS %5BAsinS2.5%5D',
#                  'asteSDA-500' => 'Anopheles stephensi SDA-500 %5BAsteS1.7%5D',
#                  bglaBB02 => 'Biomphalaria glabrata BB02 %5BBglaB1.6%5D',
#                  cquiJohannesburg => 'Culex quinquefasciatus Johannesburg %5BCpipJ2.4%5D',
#                  gausTTRI => 'Glossina austeni TTRI %5BGausT1.7%5D',
#                  gfusIAEA => 'Glossina fuscipes IAEA %5BGfusI1.7%5D',
#                  gmorYale => 'Glossina morsitans Yale %5BGmorY1.9%5D',
#                  gpalIAEA => 'Glossina pallidipes IAEA %5BGpalI1.7%5D',
#                  gpapIAEA => 'Glossina palpalis IAEA %5BGpapI1.4%5D',
#                  iscaWikel => 'Ixodes scapularis Wikel %5BIscaW1.6%5D',
#                  llonJacobina => 'Lutzomyia longipalpis Jacobina %5BLlonJ1.5%5D',
#                  mdomaabys => 'Musca domestica aabys %5BMdomA1.3%5D',
#                  phumUSDA => 'Pediculus humanus USDA %5BPhumU2.4%5D',
#                  ppapIsrael => 'Phlebotomus papatasi Israel %5BPpapI1.5%5D',
#                  rproCDC => 'Rhodnius prolixus CDC %5BRproC3.3%5D',
#                  scalUSDA => 'Stomoxys calcitrans USDA %5BScalU1.5%5D',
#                  );
#
#    my $organismLookup = $lookup{${organismAbbrev}};
#    my $organismUrl = $organismLookup;
#    $organismUrl =~ s/ /%20/g;
#    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
#      my ($sampleName) = $sampleDataset;
#      my ($gffFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_GFF3_RSRC/;
#      my $keyName = $datasetDisplayName;
#      my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/gff/${sampleName}/${organismAbbrev}_apolloPatch.gff3.gz");
#      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
#                       urlTemplate => $gffUrl,
#                           key => "$keyName",
#                           label => "${sampleName}",
#                           category => "Gene Models",
#			   type => "NeatCanvasFeatures/View/Track/NeatFeatures",
#			   menuTemplate => [
#			   {label =>  'Open {name} in Apollo',
#			    iconClass => 'dijitIconDatabase' ,
#			    action => 'iframeDialog',
#			    url => "function(track,feature,featureDiv) {return 'https://apollo.veupathdb.org/annotator/loadLink?loc='  + feature.get('seq_id') +  ':' + feature.get('start') + '..' + feature.get('end') + '&organism=$organismLookup&tracks=' }" } ],
#			   noncodingType => "nc_transcript",
#			   subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
#			   impliedUTRs => "true",
#                           metadata => {
#                             subcategory => "Annotation Updates",
#                             dataset => $datasetDisplayName,
#                             trackType => "Community Updates from Apollo",
#                             attribution => $shortAttribution,
#                             description => $summary,
#                             apollo => '',
#                           },
#                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
#                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
#                          fmtMetaValue_Apollo => "function() { return '<a href=https://apollo.veupathdb.org/annotator/loadLink?organism=$organismUrl&tracks= target=_blank>Add annotations in Apollo</a>'; }"
#      };
#
#      push @{$result->{tracks}}, $alignment;
#    }
#  }
#}

#sub addFunctionalAnnotations {
#  my ($dbh, $result) = @_;
#
#  my $sql = "select count(*) from apidbtuning.ApolloUpdate";
#
#  my $sh = $dbh->prepare($sql);
#  $sh->execute();
#  my $count = $sh->fetchrow_array();
#  $sh->finish();
#  if($count > 0) {
#
#    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
#                 baseUrl => "/a/service/jbrowse",
#                 type => "NeatCanvasFeatures/View/Track/NeatFeatures",
#                 key => "Functional Annotations",
#                 label => "Functional Annotations",
#                 category => "Gene Models",
#                 unsafePopup => JSON::true,
#                 displayMode => "normal",
#                 noncodingType => "nc_transcript",
#                 subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
#                 style => {
#                 color => "{processedApolloTranscriptColor}",
#                 borderColor => "{processedTranscriptBorderColor}",
#                 },
#                 impliedUTRs => "true",
#                 query => {'feature' => "gff:apolloTranscript",
#                 },
#                 onClick => {
#                 content => "{functionalAnnotationDetails}",
#                 },
#                 menuTemplate => [
#                   {label => "View Details",
#                    content => "{functionalAnnotationDetails}",
#                   },
#                     ],
#    };
#    push @{$result->{tracks}}, $track;
#  }
#}

sub addApolloGFF {
    my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.ApolloId aid, apidbtuning.organismattributes oa where oa.public_abbrev='".$organismAbbrev."' and aid.organism = oa.organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "NeatCanvasFeatures/View/Track/NeatFeatures",
                 key => "Community annotations from Apollo",
                 label => "Community annotations from Apollo",
                 category => "Gene Models",
                 unsafePopup => JSON::true,
                 metadata => {
                     category => "Gene Models",
                     trackType => "Processed transcript from Apollo",
                     description => "Community annotation represents user provided effort to improve the current gene models and offer alternatives based on -omic level evidence. Users can utilise our Apollo instance for creating and editing functional annotation to be displayed in this track. Only when the status of the gene model is changed to 'Finished' will the model be displayed, normally within 24 hours of the status change.",
                 },
                 displayMode => "normal",
                 noncodingType => "nc_transcript",
                 subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
                 style => {
                 color => "{processedApolloTranscriptColor}",
                 borderColor => "{processedTranscriptBorderColor}",
                 },
                 impliedUTRs => "true",
                 query => {'feature' => "gff:apolloTranscript",
                 },
                 onClick => {
                 content => "{apolloGeneDetails}",
                 label => "{apolloProductsFxn}",
                 },
                 menuTemplate => [
                   {label => "View Details",
                    content => "{apolloGeneDetails}",
                   },
                     ],
    };
    push @{$result->{tracks}}, $track;
  }
}

sub addMergedRnaSeq {
  my ($dbh, $result, $datasetProperties, $projectName) = @_;
  my @urlArray;
  my $genomeName;
  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /rnaSeq/);
my @urlArrayProject;
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};
    my $keyName = $datasetDisplayName;
    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
    $genomeName = ${nameForFileNames};
      my ($sampleName) = $sampleDataset;
      my ($bigwigFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
      my $keyName = $bigwigFileName;
         $keyName =~ s/_/ /g;

        my $bigWigRelativePath = "/var/www/Common/apiSiteFilesMirror/webServices/${projectName}/build-${buildNumber}/${nameForFileNames}/bigwig/${sampleName}/mergedBigwigs/*";
        my @bigwigFiles = glob($bigWigRelativePath);
        my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};
        foreach(@bigwigFiles){
                my $bigwigPath = $_;
                my $bigwigName = (split '/', $bigwigPath)[-1];
                my $shortBigwigName = $bigwigName;
                my $shortBigwigName = substr($shortBigwigName,0, -3);
                my $bigwigUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/bigwig/${sampleName}/mergedBigwigs/${bigwigName}");
                my $template = { url=>${bigwigUrl}, name=> ${shortBigwigName}, color=> 'black' };
                push (@urlArray, $template);
                push (@urlArrayProject, $template);
                }
        ### Print out combinedRNAseq track for experiment
#        my $arrayLength = @urlArrayProject;
#
#    if ($arrayLength > 0){
#
#        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
#        urlTemplates =>
#        \@urlArrayProject
#        ,
#        showTooltips => "true",
#        key => "${datasetDisplayName} combined RNAseq plot",
#        label => "${datasetDisplayName} combined RNAseq plot",
#        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
#        category => "Transcriptomics",
#        autoscale => "global",
#        style => {'height' => "100",
#        },
#                  metadata => {
#                    subcategory => "RNA-Seq",
#                    dataset => $datasetDisplayName,
#                    trackType => "Multi XY plot",
#                    attribution => $shortAttribution,
#                   },
#        fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
#      };
#      push @{$result->{tracks}}, $alignment;
#   }
  }
 }
        ### Print out combinedRNAseq track for organism
        my $arrayLength = @urlArray;

    if ($arrayLength > 0){
        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
        urlTemplates =>
        \@urlArray
        ,
        showTooltips => "true",
        key => "${genomeName} combined RNAseq plot",
        label => "${genomeName} combined RNAseq plot",
        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
        category => "Transcriptomics",
        autoscale => "local",
        yScalePosition => "left",
        style => {'height' => "40",
        },
                  metadata => {
                    subcategory => "RNA-Seq",
                    dataset => "Combined all RNA-Seq data for ${genomeName}",
                    trackType => "Multi XY plot",
                    alignment => "Unique", 
                   },
      };
      push @{$result->{tracks}}, $alignment;
  }
}


sub addProteinExpressionMassSpec {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /_massSpec_/);

    my $experimentName = $datasetProperties->{$dataset}->{name};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $datasetPresenterId = $datasetProperties->{$dataset}->{datasetPresenterId};
    my $category = $datasetProperties->{$dataset}->{datasetClassCategory};

    my $datasetExtdbName = $datasetProperties->{$dataset}->{datasetExtdbName};

    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $massSpec = {storeClass => "JBrowse/Store/SeqFeature/REST",
                    baseUrl => "/a/service/jbrowse",
                    type => "JBrowse/View/Track/CanvasFeatures",
                    glyph => "JBrowse/View/FeatureGlyph/Segments",
                    subParts => "Peptide",
                    displayMode => "compact",
                    query => {'feature' => "domain:MassSpecPeptide",
                              'edName' => "like '${datasetExtdbName}'",
                    },
                    key => "${datasetDisplayName}  MS/MS Peptides  ${shortAttribution}",
                    label => "${dataset}",
                    category => "Proteomics",
                    style => {'color' => "{massSpecColor}",
                              'label' => "Sample,sample,name",
                    },
                    metadata => {
                      subcategory => 'Protein Expression',
                      dataset => $datasetDisplayName,
                      trackType => 'Segments',
                      attribution => $shortAttribution,
                      description => $summary,
                    },
                    fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetId('${datasetPresenterId}', '${datasetDisplayName}'); }",
                    fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                    onClick => {
                      content => "{massSpecDetails}",
                    },
                    menuTemplate => [
                      {label => "View Details", 
                       content => "{massSpecDetails}",
                      },
                        ],
    };

    push @{$result->{tracks}}, $massSpec;
  }
}

sub addSmallNcRnaSeq {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /smallNcRna/);

    my $experimentName = $datasetProperties->{$dataset}->{experimentName};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '${organismAbbrev}%_smallNcRnaSample_RSRC'";

    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset =~ /${organismAbbrev}_${experimentName}_(.+)_smallNcRnaSample_RSRC/;

      # Example: EhistolyticaHM1IMSS/bam/Singh_Small_RNA/Rahman/Rahman.bam
      my $bamUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/bam/$experimentName/${sampleName}/${sampleName}.bam");

      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/BAM",
                       urlTemplate => $bamUrl,
                           key => "${sampleName} Small Non-coding RNAs",
                           label => "${sampleName} Small Non-coding RNAs",
                           type => "SmallRNAPlugin/View/Track/smAlignments",
                           category => "Transcriptomics",
                           yScalePosition => "left",
                       unsafePopup => JSON::true,
                           metadata => {
                             subcategory => 'small non-coding RNA',
                             dataset => $datasetDisplayName,
                             trackType => 'Small RNA',
                             attribution => $shortAttribution,
                             description => $summary,
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}

sub addCentromere {
  my ($dbh, $result) = @_;
  my $sql = "select count(*) from apidbtuning.organismattributes where hasCentromere = 1 and  internal_abbrev = '${organismAbbrev}'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {
     my $track = ApiCommonModel::Model::JBrowseTrackConfig::CentromereTrackConfig->new({application_type => $applicationType})->getConfigurationObject();
     push @{$result->{tracks}}, $track;
    };



}

sub addScaffolds {
  my ($dbh, $result) = @_;

  # TODO:  get rid of this sql
  my $sql = "select count(*) from dots.scaffoldgapfeature sgf, apidbtuning.genomicseqattributes sa, apidb.organism o where sa.na_sequence_id = sgf.na_sequence_id and o.taxon_id = sa.taxon_id and o.abbrev = '${organismAbbrev}'";


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {
      my $track = ApiCommonModel::Model::JBrowseTrackConfig::ScaffoldsTrackConfig->new({application_type => $applicationType})->getConfigurationObject();
      push @{$result->{tracks}}, $track;
  }
}

sub addSynteny {
  my ($dbh, $result) = @_;
  # Requires public_abbrev here!
  my $sql = "select otr.organism, oa.internal_abbrev as public_abbrev, otr.phylum, otr.genus, otr.species, otr.kingdom, otr.class, gt.gtracks
            from APIDBTUNING.ORGANISMSELECTTAXONRANK otr
               , APIDBTUNING.ORGANISMATTRIBUTES oa
               , (select * from APIDBTUNING.GBROWSETRACKSORGANISM where type = 'synteny' ) gt
            where oa.ORGANISM_NAME = otr.organism 
            and oa.IS_ANNOTATED_GENOME = 1
            and oa.PROJECT_ID in (select distinct name from core.projectinfo)
            and oa.ORGANISM_NAME = gt.organism (+)";

  my $hasSyntenyTracks = 0;

  my $orgGTracks;
  my %subtracks;
  my %defaults;

  my $taxonNamesToNode = {};
  my $rootNode = _Tree->new({_name => 'root'});
  my $refOrganism;


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  while(my ($organism, $publicAbbrev, $phylum, $genus, $species, $kingdom, $class, $gTracks) = $sh->fetchrow_array()) {
    if($publicAbbrev eq $organismAbbrev) {
      $hasSyntenyTracks = 1;
      $gTracks =~ s/^.+Synteny\///;
      %defaults = map { $_ => 1 } split(/\+/, $gTracks);
      $refOrganism = $organism;
    }
    my $kingdomNode = &makeTreeNode('k_' . $rootNode, $kingdom, $taxonNamesToNode, $rootNode);
    my $phylumNode = &makeTreeNode('p_' . $kingdom, $phylum, $taxonNamesToNode, $kingdomNode);
    my $classNode = &makeTreeNode('c_'. $phylum, $class, $taxonNamesToNode, $phylumNode);
    my $genusNode = &makeTreeNode('g_'. $class, $genus, $taxonNamesToNode, $classNode);
    my $speciesNode = &makeTreeNode('s_'. $genus, $species, $taxonNamesToNode, $genusNode);
    my $strainNode = &makeTreeNode('', $organism, $taxonNamesToNode, $speciesNode);

    # stuff these things in the leaf nodes
    $strainNode->setAbbrev($publicAbbrev);
    $strainNode->setFeatureFilters({ "taxon" => $organism});
    $strainNode->setMetadata({"Kingdom" => $kingdom,
                              "Phylum" => $phylum,
                              "Class" => $class,
                              "Genus" => $genus,
                              "Species" => $species 
                             });
  }
  $sh->finish();

  if($hasSyntenyTracks) {
    my $subtracksAr = [];

    my $refOrganismNode = $taxonNamesToNode->{$refOrganism};

    &addSubtracks($subtracksAr, $refOrganismNode, $taxonNamesToNode, \%defaults, $organismAbbrev);

    my $syntenyTrack = {storeClass => "EbrcTracks/Store/SeqFeature/REST",
                        baseUrl => "/a/service/jbrowse",
                        type => "EbrcTracks/View/Track/Synteny",
                        transcriptType => "processed_transcript",
                        noncodingType => ["nc_transcript"],
                        glyph => "function(f){return f.get('syntype') === 'span' ? 'JBrowse/View/FeatureGlyph/Box' : 'JBrowse/View/FeatureGlyph/Gene'; }",
                        subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon,pseudogenic_exon",
                        key => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        label => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        region_feature_densities => "function(){return false}",
                        category => "Comparative Genomics",
			unsafePopup => JSON::true,
                        geneGroupAttributeName => "orthomcl_name",
                        displayMode => "normal",

                        style => {
                          color => "{syntenyColorFxn}",
                          unprocessedTranscriptColor => "lightgrey",
                          utrColor => "grey",
#                          borderWidth => 4,
                          connectorThickness => "function(f){return f.get('syntype') === 'span' ? 3 : 1; }",
                          showLabels => "function(){return false}",
                          strandArrow => "function(f){return f.get('syntype') === 'span' ? false : true; }",
                          height => "function(f){return f.get('syntype') === 'span' ? 2 : 5; }",
#                          height => 5,
                          marginBottom => 0,
                       },
                        metadata => {
                          subcategory => "Orthology and Synteny",
                          trackType => 'Segments',
                        },
                        query => {'feature' => "gene:syntenyJBrowseScaled"
                        },
                        subtracks => $subtracksAr,
                        onClick => {
                          content => "{syntenyTitleFxn}",
                        },
                        menuTemplate => [
                          {label => "View Details", 
                           content => "{syntenyTitleFxn}",
                          },
                          {label => "View Gene or Sequence Page",
                           title => "function(track,f) { return f.get('syntype') == 'span' ? f.get('contig') : f.get('name'); }", 
                           iconClass => "dijitIconDatabase", 
                           action => "iframeDialog", 
                           url => "function(track,f) { return f.get('syntype') == 'span' ? '/a/app/record/genomic-sequence/' + f.get('contig') : '/a/app/record/gene/' + f.get('name') }"}
                            ],
    };
    
    push @{$result->{tracks}}, $syntenyTrack;


  }

}



sub addSubtracks {
  my ($subtracks, $node, $taxonNamesToNode, $defaults, $organismAbbrev) = @_;

  return if($node->getAlreadySeen());
  return if($node->isRoot());

  if($node->isLeaf()) {
    my $abbrev = $node->getAbbrev();

    foreach my $type ("gene", "span") {
      my $metadataClone = dclone $node->getMetadata();
      my $ffClone = dclone $node->getFeatureFilters();
      $ffClone->{syntype} = $type;

      my $label = "${abbrev}_${type}";

      my $visible = $abbrev eq $organismAbbrev || $defaults->{$label} ? 'true' : 'false';

      my $subtrack = {featureFilters => $ffClone,
                      metadata => $metadataClone,
                      label => "$abbrev $type",
                      visible => $visible
      };
      push @$subtracks, $subtrack;
    }
  }
  else {
    my $children = $node->getChildren();

    foreach my $child (@$children) {
      &addSubtracks($subtracks, $child, $taxonNamesToNode, $defaults, $organismAbbrev);
    }
  }

  $node->setAlreadySeen(1);

  my $parent = $node->getParent();
  
  &addSubtracks($subtracks, $parent, $taxonNamesToNode, $defaults, $organismAbbrev);
}

sub makeTreeNode {
  my ($prefix, $name, $taxonNamesToNode, $parentNode) = @_;

  my $key = $prefix . $name;

  my $node = $taxonNamesToNode->{$key};
  unless($node) {
    $node = _Tree->new({_parent => $parentNode, _name => $name});
    $parentNode->addChild($node);
  }
  
  $taxonNamesToNode->{$key} = $node;

  return $node;
}


sub addUnifiedSnp {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%HTS_SNP_%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $snpCount = $sh->fetchrow_array();
  $sh->finish();

  if($snpCount > 0) {

    my $desc ="The SNPs in this track are gathered from the high-throughput sequencing data of multiple strains and isolates. For more details on the methods used, go to the Data menu, choose Analysis Methods, and then scroll down to the Genetic Variation and SNP calling section. SNPs in this track are represented as colored diamonds, where dark blue = non-synonymous, light blue = synonymous, red = nonsense, and yellow = non-coding.";

#                    glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
#                    key => "SNPs by coding potential",
#                    label => "SNPs by coding potential",

    #                    maxFeatureScreenDensity => 0.01,
#                    region_feature_densities => "function(){return true}",



#                    style => {
#                      color => "",
#                      strandArrow => "function(){return false}",
#                      labelScale => 1000000000000000, #some really big number so labels are not shown; showLabels=false not working here or in hook TODO
#                    },
#                    metadata => {
#                      subcategory => "DNA polymorphism",
#                      trackType => 'Unified SNPs',
#                      description => $desc
#                    },
#                    query => {'feature' => "SNP:Population",
#                              'edname' => 'InsertSnps.pm NGS SNPs INTERNAL'
#                    },
#                     onClick => {
#                       content => "{snpTitleFxn}",
#                     },
#                     menuTemplate => [
#                       {label => "View Details",
#                        content => "{snpTitleFxn}",
#                       },
#                         ],
    my $snpTrack = ApiCommonModel::Model::JBrowseTrackConfig::UnifiedSnpTrackConfig->new({
                                                                                                store_type => "JBrowse/Store/SeqFeature/REST",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                key => "SNPs by coding potential",
                                                                                                label => "SNPs by coding potential",
                                                                                                max_feature_screen_density => 0.01,
                                                                                                region_feature_densities => "function(){return true}",
                                                                                                category => "Genetic Variation",
                                                                                                subcategory => "DNA polymorphism",
                                                                                                color => "{snpColorFxn}",
                                                                                                baseUrl => "/a/service/jbrowse",
                                                                                                application_type => $applicationType,
                                                                                                display_mode => "normal",
                                                                                                glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
                                                                                              })->getConfigurationObject();

#    };

    push @{$result->{tracks}}, $snpTrack;

  };

}

sub addUnifiedMassSpec {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%massSpec%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $massSpecCount = $sh->fetchrow_array();
  $sh->finish();

  if($massSpecCount > 0) {

    my $unifiedMassSpecTrack = ApiCommonModel::Model::JBrowseTrackConfig::UnifiedMassSpecTrackConfig->new({application_type => $applicationType })->getConfigurationObject();

    push @{$result->{tracks}}, $unifiedMassSpecTrack;
   };



}

sub addChipChipTracks {
  my ($dbh, $result, $datasetProperties) = @_;

 my $sql = "select d.name, s.name, pan.name, pan.protocol_app_node_id
from study.study s
   , SRES.EXTERNALDATABASERELEASE r
   , SRES.EXTERNALDATABASE d
   , study.protocolappnode pan
   , study.studylink sl
where d.name like '${organismAbbrev}%_chipChipExper_%'
and s.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and s.investigation_id is null";


  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($dataset, $study, $panName, $panId) = $sh->fetchrow_array()) {
    if($panName =~ /_peaks \(ChIP-chip\)/) {
        my $peakTrack = &makeChipChipPeak($dataset, $study, $panName, $panId, $datasetProperties);
        push @{$result->{tracks}}, $peakTrack;
    }
    if($panName =~ /_smoothed \(ChIP-chip\)/) {
      my $track = &makeChipChipSmoothed($dataset, $study, $panName, $panId, $datasetProperties);
      push @{$result->{tracks}}, $track;
    }
  }
 
  $sh->finish();
}


sub makeChipChipPeak {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $datasetPresenterId = $datasetProperties->{$dataset}->{datasetPresenterId};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $cutoff = $datasetProperties->{$dataset}->{cutoff} || 0;
  
  my $colorFunction = $cutoff ? "colorSegmentByScore" : "chipColor";

#  my $peaks = {storeClass => "JBrowse/Store/SeqFeature/REST",
#                  baseUrl => "/a/service/jbrowse",
#                  type => "JBrowse/View/Track/CanvasFeatures",
#                  key => $key,
#                  label => $key,
#                  category => "Epigenomics",
#                  style => {
#                    color => "{$colorFunction}",
#                  },
#                  metadata => {
#                    subcategory => "ChIP chip",
#                    dataset => $datasetDisplayName,
#                    trackType => 'Segments',
#                    attribution => $shortAttribution,
#                    description => $summary,
#                   },
#                   fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetId('${datasetPresenterId}', '${datasetDisplayName}'); }",
#                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
#                  query => {'feature' => "ChIP:ChIPchip_peaksjbrowse",
#                            'exp' => $dataset,
#                            'sub' => $subTrackAttr,
#                            'cutoff' => $cutoff,
#                            'panId' => $panId,
#                  },
#               onClick => {
#                 content => "{peakTitleChipSeqFxn}",
#               },
#               menuTemplate => [
#                 {label => "View Details",
#                  content => "{peakTitleChipSeqFxn}",
#                 },
#                   ],
#    };

  my $peaks = ApiCommonModel::Model::JBrowseTrackConfig::ChipChipPeakTrackConfig->new({
                                                                                                fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                                                                                                store_type => "JBrowse/Store/SeqFeature/REST",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                subcategory => "ChIP chip",

                                                                                              })->getConfigurationObject();


  return $peaks;


}

sub addCnvArray {
  my ($dbh, $result) = @_;

  my $sql = "select distinct pan.name
from study.protocolappnode pan
   , study.study s
   , study.studylink sl
where pan.PROTOCOL_APP_NODE_ID = sl.PROTOCOL_APP_NODE_ID
and sl.study_id = s.study_id
and s.name like 'tcruCLBrenerEsmeraldo-like_cghArrayExper_Tarelton_GSE23576_CNV_RSRC%'
order by pan.name";
  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my $desc = "Comparative Genomic Hybridization to determine regions of significant Copy Number Variation in <i>T. cruzi</i> strains with strain CL Brener as reference. Type I strains used include: Brazil, Chinata, Colombiana, M78, Montalvania, PalDa1 (clone 9), SylvioX10/4, TCC, TEDa2 (clone 4), TEP6 (clone 5). Type II-VI strains used include: Esmeraldo, M5631, Tu18 (clone 1), Tulahuen, wtCL, Y. Scores from Type I strain is shown in Green and from Type II-VI are show in Brown. Score value represents the number of strains showing CNV , with a postive score implying amplification and a negative score implying deletion with respect to CL Brener. CNV criteria: minimum log2 ratio of signal intensities (test strain/reference) +/- 0.6, minimum number of probes 5. For more details refer the following manuscript: <a href=\"http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3060142/\">Widespread, focal copy number variations (CNV) and whole chromosome aneuploidies in Trypanosoma cruzi strains revealed by array comparative genomic hybridization</a> ";

  while(my ($name) = $sh->fetchrow_array()) {


    my $cnv = {storeClass => "JBrowse/Store/SeqFeature/REST",
               baseUrl => "/a/service/jbrowse",
               type => "JBrowse/View/Track/Wiggle/XYPlot",
               key => $name,
               label => $name,
               category => "Genetic Variation",
               style => {height => 40},
               metadata => {
                 subcategory => "CGH Array",
                 dataset => "Comparative Genomic Hybridizations of 33 strains",
                 trackType => 'XYPlot',
                 description => $desc,
               },
               fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('tcruCLBrenerEsmeraldo-like_cghArrayPlatform_GPL10781_RSRC', 'Comparative Genomic Hybridizations of 33 strains'); }",
               fmtMetaValue_Description => "function() { return datasetDescription('${desc}', ''); }",
               query => {'feature' => "cnv:ArrayJBrowse",
                         'sample' => $name,
               },
               max_score => 3,
               min_score => -3,
               yScalePosition => "left"
    };
    push @{$result->{tracks}}, $cnv;

  }
  $sh->finish();
}

sub makeChipChipSmoothed {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

#  my $datasetKey = $datasetProperties->{$dataset}->{key};
#  my $key = $datasetKey ? "${panName} ${datasetKey}" : $panName; # no longer valid??
  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $smoothed = {storeClass => "JBrowse/Store/SeqFeature/REST",
                  baseUrl => "/a/service/jbrowse",
                  type => "JBrowse/View/Track/Wiggle/XYPlot",
                  key => $key,
                  label => $key,
                  category => "Epigenomics",
                  style => {
                    pos_color => "{chipColor}",
                    neg_color => "{chipColor}",
                    height => 40,
                  },
                  metadata => {
                    subcategory => "ChIP chip",
                    dataset => $datasetDisplayName,
                    trackType => 'XYPlot',
                    attribution => $shortAttribution,
                    description => $summary,
                   },
                   fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                  query => {'feature' => "ChIP:ChIPchip_smoothedjbrowse",
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'panId' => $panId
                  },
                  max_score => 3,
                  min_score => -3,
                  yScalePosition => "left"
    };


  return $smoothed;
}


sub addNrdbProteinAlignments {
  my ($dbh, $result, $datasetProperties, $projectName) = @_;

  my $proteinAlignTrack;

#     my $sql = "select name_for_filenames from apidb.organism where abbrev = '$organismAbbrev'";
#     my $sh = $dbh->prepare($sql);
#     $sh->execute();
#     my ($nameForFileNames) = $sh->fetchrow_array();
#     $sh->finish();

    my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/nrProteinsToGenomeAlign/result.sorted.gff.gz");

    my $methodDescription = "<p>NCBI's non redundant collection of proteins (nr) was filtered for deflines matching the Genus of this sequence.  These proteins were aligned using <a href='https://www.ebi.ac.uk/about/vertebrate-genomics/software/exonerate'>exonerate</a>. (protein to genomic sequence)</p>";

#    $proteinAlignTrack = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
#                          urlTemplate => $gffUrl,
#                          key => "NRDB Protein Alignments",
#                          label => "NRDB Protein Alignments",
#                          category => "Sequence Analysis",
#                          type => "JBrowse/View/Track/CanvasFeatures",
#                          glyph => "JBrowse/View/FeatureGlyph/Segments",
#                          fmtMetaValue_Description => "function(){return datasetDescription(\"$methodDescription\", \"\");}",
#                          metadata => {
#                            subcategory => "BLAT and Blast Alignments",
#                            trackType => 'Segments',
#                            description => $methodDescription,
#                          },
#                          onClick => {
#                            content => "{nrdbGffDetails}", title => "----------------------------- {id} -----------------------------",
#                          },
#                          menuTemplate => [
#                            {label =>  "View Details", content => "{nrdbGffDetails}", title => "----------------------------- {id} -----------------------------",},
#                            {label => "View in Genbank",title => "Genbank {name}", iconClass => "dijitIconDatabase", action => "newWindow", url => "https://www.ncbi.nlm.nih.gov/protein/{name}"}
#                              ],
#                          style => {
#                            color => "{nrdbColor}",
#                            borderColor => "{processedTranscriptBorderColor}"
#                          },
#                          displayMode => "compact",
#
#      };
    $proteinAlignTrack = ApiCommonModel::Model::JBrowseTrackConfig::NrdbProteinTrackConfig->new({
                                                                                                fmtMetaValue_Description => "function(){return datasetDescription(\"$methodDescription\", \"\");}",
                                                                                                store_type => "JBrowse/Store/SeqFeature/GFF3Tabix",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                subcategory => "BLAT and Blast Alignments",
                                                                                                url_template => $gffUrl,
                                                                                                application_type => $applicationType,
                                                                                                summary => $methodDescription,
                                                                                                display_mode => "compact",
                                                                                                glyph => "JBrowse/View/FeatureGlyph/Segments",
                                                                                              })->getConfigurationObject();


    push @{$result->{tracks}}, $proteinAlignTrack;

}

sub addTRNA {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from dots.rnafeature rnaf, sres.ontologyterm ot
where ot.ontology_term_id = rnaf.sequence_ontology_id
and ot.name ='tRNA'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

#    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
#                 baseUrl => "/a/service/jbrowse",
#                 type => "JBrowse/View/Track/CanvasFeatures",
#                 glyph => "JBrowse/View/FeatureGlyph/Box",
#                 key => "tRNAscan",
#                 label => "tRNAscan",
#                 category => "Sequence Analysis",
#                 displayMode => "normal",
#                 style => {
#                   color => "white",
#		   borderColor => "{processedTranscriptBorderColor}"
#                 },
#                 metadata => {
#                   subcategory => "Sequence sites, features and motifs",
#                   trackType => 'Segments',
#                 },
#                 query => {'feature' => "domain:tRNA",
#                 },
#                 onClick => {
#                   content => "{positionTitle}",
#                 },
#                 menuTemplate => [
#                   {label => "View Details",
#                    content => "{positionTitle}",
#                   },
#                     ],
#    };
     my $track = ApiCommonModel::Model::JBrowseTrackConfig::TrnaTrackConfig->new({
                                                                                                store_type => "JBrowse/Store/SeqFeature/REST",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                key => "tRNAscan",
                                                                                                label => "tRNAscan",
                                                                                                category => "Sequence Analysis",
                                                                                                subcategory => "Sequence sites, features and motifs",
                                                                                                baseUrl => "/a/service/jbrowse",
                                                                                                application_type => $applicationType,
                                                                                                display_mode => "normal",
                                                                                                glyph => "JBrowse/View/FeatureGlyph/Box",
                                                                                                color => "white",
                                                                                                borderColor => "{processedTranscriptBorderColor}",
                                                                                              })->getConfigurationObject();


    push @{$result->{tracks}}, $track;
  }
}


sub addPopsets {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.popsetAttributes";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

#    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
#                 baseUrl => "/a/service/jbrowse",
#                 type => "JBrowse/View/Track/CanvasFeatures",
#                 glyph => "JBrowse/View/FeatureGlyph/Box",
#                 key => "Popset Isolate Sequence Alignments",
#                 label => "popsetIsolates",
#		 maxFeatureScreenDensity => 0.03,
#                 region_feature_densities => "function(){return true}",
#                 category => "Sequence Analysis",
#                 displayMode => "compact",
#                 style => {
#                   color => "{popsetColor}",
#                 },
#                 metadata => {
#                   subcategory => "BLAT and Blast Alignments",
#                   trackType => 'Segments',
#                 },
#                 query => {'feature' => "match:IsolatePopset",
#                 },
#                 onClick => {
#                   content => "{popsetDetails}",
#                 },
#                 menuTemplate =>
#		 [
#		  {label => "View Details",
#		   content => "{popsetDetails}",
#		  },
#		  {label => "View Popset Sequence Page",
#		   title => "{popsetDetails}",
#		   iconClass => "dijitIconDatabase",
#		   action => "newWindow",
#		   url => "/a/app/record/popsetSequence/{name}",
#		  },
#		 ],
#		};
    my $track = ApiCommonModel::Model::JBrowseTrackConfig::PopsetsTrackConfig->new({
                                                                                                store_type => "JBrowse/Store/SeqFeature/REST",
                                                                                                type => "JBrowse/View/Track/CanvasFeatures",
                                                                                                key => "All MS/MS Peptides",
                                                                                                label => "popsetIsolates",
                                                                                                max_feature_screen_density => 0.03,
                                                                                                region_feature_densities => "function(){return true}",
                                                                                                category => "Sequence Analysis",
                                                                                                subcategory => "BLAT and Blast Alignment",
                                                                                                color => "{popsetColor}",
                                                                                                baseUrl => "/a/service/jbrowse",
                                                                                                application_type => $applicationType,
                                                                                                display_mode => "compact",
                                                                                                glyph => "JBrowse/View/FeatureGlyph/Box",

                                                                                              })->getConfigurationObject();



    push @{$result->{tracks}}, $track;
  }
}

1;


package _Tree; 

use strict;

sub getName {$_[0]->{_name}}

sub setAlreadySeen {$_[0]->{_seen} = $_[1]}
sub getAlreadySeen {$_[0]->{_seen}}

sub setAbbrev {$_[0]->{_abbrev} = $_[1]}
sub getAbbrev {$_[0]->{_abbrev}}

sub setFeatureFilters {$_[0]->{_feature_filters} = $_[1]}
sub getFeatureFilters {$_[0]->{_feature_filters}}

sub setMetadata {$_[0]->{_metadata} = $_[1]}
sub getMetadata {$_[0]->{_metadata}}

sub getParent {$_[0]->{_parent}}

sub getChildren {$_[0]->{_children} || [] }

sub addChild {push @{$_[0]->{_children}}, $_[1]}

sub isLeaf {
  my ($self) = @_;
  my $children = $self->getChildren();
  return scalar @$children == 0;
}

sub isRoot {
  my ($self) = @_;
  return !defined($self->getParent());
}

sub new {
  my ($class, $args) = @_;

  return bless $args, $class;
}

1;
