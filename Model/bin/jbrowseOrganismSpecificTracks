#!/usr/bin/perl

use strict;
use lib $ENV{GUS_HOME} . "/lib/perl";
use JSON;
use ApiCommonModel::Model::JBrowseUtil;
use Data::Dumper;
use URI::Escape;
use Storable 'dclone';
use Tie::IxHash;

my %datasets;
my $t = tie %datasets, 'Tie::IxHash';
my %strain;


my ($organismAbbrev, $projectName, $isApollo, $buildNumber, $webservicesDir) = @ARGV;

my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName});

my $dbh = $jbrowseUtil->getDbh();   

my ($nameForFilenames, $isReference) = &nameForFilenamesAndIsReference($organismAbbrev, $dbh);


my $result = {"tracks" => [] };
#my $result = {"tracks" => []};

&addScaffolds($dbh, $result);
&addCentromere($dbh, $result);
&addUnifiedMassSpec($dbh, $result);
&addUnifiedSnp($dbh, $result);

&addSynteny($dbh, $result);
&addDatasets($dbh, \%datasets) unless($isApollo);

my $datasetProperties = &datasetProperties($dbh);

&addChipChipTracks($dbh, $result, $datasetProperties);
&addSmallNcRnaSeq($dbh, $result, $datasetProperties, $nameForFilenames);
&addProteinExpressionMassSpec($dbh, $result, $datasetProperties);
&addVCF($dbh, $result, $datasetProperties, $nameForFilenames);
&addGFF($dbh, $result, $datasetProperties, $nameForFilenames);


&addTRNA($dbh, $result, $datasetProperties);
if ($projectName !~ m/HostDB/ && $organismAbbrev !~ m/cgloCBS148.51/ && $organismAbbrev !~ m/pgig/ && $organismAbbrev !~ m/amutUAMH3576/ && $organismAbbrev !~ m/anigUAMH3544/ && $organismAbbrev !~ m/bcerUAMH5669/){
  &addNrdbProteinAlignments($dbh, $result, $datasetProperties, $projectName, $nameForFilenames);
}
&addPopsets($dbh, $result, $datasetProperties);

if ($organismAbbrev !~ m/dmeliso-1/ ){
&addApolloGFF($dbh, $result);
}
&addMergedRnaSeq($dbh, $result, $datasetProperties, $projectName, $nameForFilenames);


&addLongReadRNASeq($result, $datasetProperties, $nameForFilenames, $webservicesDir);


if($projectName eq 'FungiDB' && $isReference) {
  &addAntismash($result, $nameForFilenames, $webservicesDir, $projectName);
}


# other organism specific tracks
if($organismAbbrev eq 'tcruCLBrenerEsmeraldo-like') {
  &addCnvArray($dbh, $result);
}


unless($isApollo) {
  $result->{datasets} = \%datasets;
  $result->{dataset_id} = $organismAbbrev;

  # $organismAbbrev is internal_abbrev here; if not same as public_abbrev
  # then the dataset_id needs be set to public_abbrev
  if ($strain{$organismAbbrev}->{public} ne $organismAbbrev) {
    $result->{dataset_id} = $strain{$organismAbbrev}->{public};
  }
}

print encode_json($result);


sub nameForFilenamesAndIsReference {
  my ($organismAbbrev, $dbh) = @_;

  my $sql = "select name_for_filenames, is_reference_strain from apidb.organism where abbrev = '$organismAbbrev'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my ($nameForFileNames, $isReferenceStrain) = $sh->fetchrow_array();
  $sh->finish();

  return $nameForFileNames, $isReferenceStrain;
}

sub addDatasets {
  my ($dbh) = @_;
  #Public facing track requires public_abbrev here!
  my $sql = "select public_abbrev, internal_abbrev, organism_name FROM Apidbtuning.organismattributes order by organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($abbrev, $internalAbbrev, $name) = $sh->fetchrow_array()) {
    $datasets{$abbrev}->{name} = $name;
    $datasets{$abbrev}->{url} = "?data=/a/service/jbrowse/tracks/${abbrev}";
#    $result->{datasets}->{$abbrev}->{name} = $name;
#    $result->{datasets}->{$abbrev}->{url} = "?data=tracks/${abbrev}";

    $strain{$internalAbbrev}->{public} = $abbrev;
  }
  $sh->finish();
}

sub datasetProperties {
  my ($dbh) = @_;

  my $sql = "select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_chipChipExper%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dnt.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
   , apidbtuning.datasetnametaxon dnt
where dnt.name like '${organismAbbrev}%_ebi_VCF_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
and dsp.dataset_presenter_id = dnt.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_ebi_GFF3_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_ebi_rnaSeq_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}_smallNcRna_%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select distinct dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
from apidbtuning.datasetnametaxon dnt,
     apidbtuning.datasetproperty prop,
     apidbtuning.datasetpresenter dsp,
     apidb.organism o
where dnt.taxon_id = o.taxon_id
and o.abbrev = '${organismAbbrev}'
and dnt.name like '%_massSpec%_RSRC'
and dnt.dataset_presenter_id = prop.dataset_presenter_id
and prop.dataset_presenter_id = dsp.dataset_presenter_id
--TODO Saikou longread rnaseq
UNION
--select name, presenter_id, property, value, ....
select distinct dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
from apidbtuning.datasetnametaxon dnt,
     apidbtuning.datasetproperty prop,
     apidbtuning.datasetpresenter dsp,
     apidb.organism o
where dnt.taxon_id = o.taxon_id
and o.abbrev = '${organismAbbrev}'
and dnt.name like '%_nanopore%_RSRC'
and dnt.dataset_presenter_id = prop.dataset_presenter_id
and prop.dataset_presenter_id = dsp.dataset_presenter_id
";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my %datasetProperties;
  while(my ($datasetName, $datasetPresenterId, $prop, $val, $extdbName) = $sh->fetchrow_array()) {
    $datasetProperties{$datasetName}->{$prop} = $val;
    $datasetProperties{$datasetName}->{datasetPresenterId} = $datasetPresenterId;
    $datasetProperties{$datasetName}->{datasetExtdbName} = $extdbName;
  }
  $sh->finish();

  return \%datasetProperties;
}

sub addVCF {
  my ($dbh, $result, $datasetProperties, $nameForFilenames) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /VCF/);
    
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;;
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select ds.name from apidb.datasource ds where ds.name = '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset;
      my ($vcfFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;
      my $keyName = $vcfFileName;
 	 $keyName =~ s/_/ /g;
      my $vcfUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/vcf/${sampleName}/${vcfFileName}.vcf.gz");
      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/VCFTabix",
                       urlTemplate => $vcfUrl,
                           #key => "${vcfFileName} SNPs from VCF",
                           key => "$keyName SNPs from VCF",
                           label => "${sampleName} SNPs",
                           type => "JBrowse/View/Track/CanvasVariants",
                           glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
                           category => "Genetic Variation",
                           chunkSizeLimit => '10000000',
                           metadata => {
                             subcategory => 'DNA polymorphism',
                             dataset => $datasetDisplayName,
                             trackType => 'VCF from VectorBase',
                             attribution => $shortAttribution,
                             description => $summary,
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}

sub addGFF {
  my ($dbh, $result, $datasetProperties, $nameForFilenames) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /GFF/);

    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_GFF3_RSRC/;;
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select ds.name from apidb.datasource ds where ds.name = '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    my %lookup = (aaegLVP_AGWG => 'Aedes aegypti LVP_AGWG %5BAaegL5.2%5D',
                  aalbSTECLA => 'Anopheles albimanus STECLA %5BAalbS2.6%5D',
                  aaraDongola => 'Anopheles arabiensis Dongola %5BAaraD1.11%5D',
                  aatrEBRO => 'Anopheles atroparvus EBRO %5BAatrE3.1%5D',
                  achrACHKN1017 => 'Anopheles christyi ACHKN1017 %5BAchrA1.7%5D',
                  acolNgousso => 'Anopheles coluzzii Ngousso %5BAcolN1.0%5D',
                  'aculA-37' => 'Anopheles culicifacies A-37 %5BAculA1.6%5D',
                  adarCoari => 'Anopheles darlingi Coari %5BAdarC3.8%5D',
                  adirWRAIR2 => 'Anopheles dirus WRAIR2 %5BAdirW1.8%5D',
                  aepiEpiroticus2 => 'Anopheles epiroticus Epiroticus2 %5BAepiE1.7%5D',
                  afarFAR1 => 'Anopheles farauti FAR1 %5BAfarF2.6%5D',
                  afunFUMOZ => 'Anopheles funestus FUMOZ %5BAfunF3.1%5D',
                  agamPEST => 'Anopheles gambiae str. PEST %5BAgamP4.12%5D',
                  amacmaculatus3 => 'Anopheles maculatus maculatus3 %5BAmacM1.5%5D',
                  amelCM1001059 => 'Anopheles melas CM1001059_A %5BAmelC2.6%5D',
                  amerMAF => 'Anopheles merus MAF %5BAmerM2.9%5D',
                  aminMINIMUS1 => 'Anopheles minimus MINIMUS1 %5BAminM1.8%5D',
                  aquaSANGWE => 'Anopheles quadriannulatus SANGWE %5BAquaS1.11%5D',
                  asinSINENSIS => 'Anopheles sinensis SINENSIS %5BAsinS2.5%5D',
                  'asteSDA-500' => 'Anopheles stephensi SDA-500 %5BAsteS1.7%5D',
                  bglaBB02 => 'Biomphalaria glabrata BB02 %5BBglaB1.6%5D',
                  cquiJohannesburg => 'Culex quinquefasciatus Johannesburg %5BCpipJ2.4%5D',
                  gausTTRI => 'Glossina austeni TTRI %5BGausT1.7%5D',
                  gfusIAEA => 'Glossina fuscipes IAEA %5BGfusI1.7%5D',
                  gmorYale => 'Glossina morsitans Yale %5BGmorY1.9%5D',
                  gpalIAEA => 'Glossina pallidipes IAEA %5BGpalI1.7%5D',
                  gpapIAEA => 'Glossina palpalis IAEA %5BGpapI1.4%5D',
                  iscaWikel => 'Ixodes scapularis Wikel %5BIscaW1.6%5D',
                  llonJacobina => 'Lutzomyia longipalpis Jacobina %5BLlonJ1.5%5D',
                  mdomaabys => 'Musca domestica aabys %5BMdomA1.3%5D',
                  phumUSDA => 'Pediculus humanus USDA %5BPhumU2.4%5D',
                  ppapIsrael => 'Phlebotomus papatasi Israel %5BPpapI1.5%5D',
                  rproCDC => 'Rhodnius prolixus CDC %5BRproC3.3%5D',
                  scalUSDA => 'Stomoxys calcitrans USDA %5BScalU1.5%5D',
                  );

    my $organismLookup = $lookup{${organismAbbrev}};
    my $organismUrl = $organismLookup;
    $organismUrl =~ s/ /%20/g;
    while(my ($sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset;
      my ($gffFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_GFF3_RSRC/;
      my $keyName = $datasetDisplayName;
      my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/gff/${sampleName}/${organismAbbrev}_apolloPatch.gff3.gz");
      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
                       urlTemplate => $gffUrl,
                           key => "$keyName",
                           label => "${sampleName}",
                           category => "Gene Models",
			   type => "NeatCanvasFeatures/View/Track/NeatFeatures",
			   menuTemplate => [ 
			   {label =>  'Open {name} in Apollo', 
			    iconClass => 'dijitIconDatabase' ,
			    action => 'iframeDialog',
			    url => "function(track,feature,featureDiv) {return 'https://apollo.veupathdb.org/annotator/loadLink?loc='  + feature.get('seq_id') +  ':' + feature.get('start') + '..' + feature.get('end') + '&organism=$organismLookup&tracks=' }" } ],
			   noncodingType => "nc_transcript",
			   subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
			   impliedUTRs => "true",
                           metadata => {
                             subcategory => "Annotation Updates",
                             dataset => $datasetDisplayName,
                             trackType => "Community Updates from Apollo",
                             attribution => $shortAttribution,
                             description => $summary,
                             apollo => '',
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                          fmtMetaValue_Apollo => "function() { return '<a href=https://apollo.veupathdb.org/annotator/loadLink?organism=$organismUrl&tracks= target=_blank>Add annotations in Apollo</a>'; }"
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}

sub addFunctionalAnnotations {
  my ($dbh, $result) = @_;
  
  my $sql = "select count(*) from apidbtuning.ApolloUpdate";
  
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish(); 
  if($count > 0) {
    
    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "NeatCanvasFeatures/View/Track/NeatFeatures",
                 key => "Functional Annotations",
                 label => "Functional Annotations",
                 category => "Gene Models",
                 unsafePopup => JSON::true,
                 displayMode => "normal",
                 noncodingType => "nc_transcript",
                 subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
                 style => {
                 color => "{processedApolloTranscriptColor}",
                 borderColor => "{processedTranscriptBorderColor}",
                 },
                 impliedUTRs => "true", 
                 query => {'feature' => "gff:apolloTranscript",
                 },
                 onClick => {
                 content => "{functionalAnnotationDetails}",
                 },
                 menuTemplate => [
                   {label => "View Details",
                    content => "{functionalAnnotationDetails}",
                   },
                     ],
    };
    push @{$result->{tracks}}, $track;
  }
}

sub addApolloGFF {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.ApolloId aid, apidbtuning.organismattributes oa where (oa.public_abbrev='".$organismAbbrev."' OR oa.internal_abbrev='".$organismAbbrev."') and aid.organism = oa.organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "NeatCanvasFeatures/View/Track/NeatFeatures",
                 key => "Community annotations from Apollo",
                 label => "Community annotations from Apollo",
                 category => "Gene Models",
                 unsafePopup => JSON::true,
                 metadata => {
                     category => "Gene Models",
                     trackType => "Processed transcript from Apollo",
                     description => "Community annotation represents user provided effort to improve the current gene models and offer alternatives based on -omic level evidence. Users can utilise our Apollo instance for creating and editing functional annotation to be displayed in this track. Only when the status of the gene model is changed to 'Finished' will the model be displayed, normally within 24 hours of the status change.",
                 },
                 displayMode => "normal",
		 noncodingType => "ncRNA",
                 subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
                 style => {
                 color => "{processedApolloTranscriptColor}",
                 borderColor => "{processedTranscriptBorderColor}",
		 unprocessedTranscriptColor => "{unprocessedApolloTranscriptColor}",
                 description => "apolloProduct,description",
                 },
                 impliedUTRs => "true",
                 query => {'feature' => "gff:apolloTranscript",
                 },
                 onClick => {
                 content => "{apolloGeneDetails}",
                 label => "{apolloProductsFxn}",
                 },
                 menuTemplate => [
                   {label => "View Details",
                    content => "{apolloGeneDetails}",
                   },
                     ],
    };
    push @{$result->{tracks}}, $track;
  }
}

sub addMergedRnaSeq {
  my ($dbh, $result, $datasetProperties, $projectName, $nameForFilenames) = @_;
  my @urlArray;
  my $genomeName;
  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /rnaSeq/);
my @urlArrayProject;
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};
    my $keyName = $datasetDisplayName;
    my $sql = "select ds.name from apidb.datasource ds where ds.name = '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($sampleDataset) = $sh->fetchrow_array()) {
    $genomeName = ${nameForFilenames};
      my ($sampleName) = $sampleDataset;
      my ($bigwigFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
      my $keyName = $bigwigFileName;
         $keyName =~ s/_/ /g;

        my $bigWigRelativePath = "/var/www/Common/apiSiteFilesMirror/webServices/${projectName}/build-${buildNumber}/${nameForFilenames}/bigwig/${sampleName}/mergedBigwigs/*";
        my @bigwigFiles = glob($bigWigRelativePath);
        my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};
        foreach(@bigwigFiles){
                my $bigwigPath = $_;
                my $bigwigName = (split '/', $bigwigPath)[-1];
                my $shortBigwigName = $bigwigName;
                my $shortBigwigName = substr($shortBigwigName,0, -3);
                my $bigwigUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/bigwig/${sampleName}/mergedBigwigs/${bigwigName}");
                my $template = { url=>${bigwigUrl}, name=> ${shortBigwigName}, color=> 'black' };
                push (@urlArray, $template);
                push (@urlArrayProject, $template);
                }
        ### Print out combinedRNAseq track for experiment
#        my $arrayLength = @urlArrayProject;
#
#    if ($arrayLength > 0){
#
#        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
#        urlTemplates =>
#        \@urlArrayProject
#        ,
#        showTooltips => "true",
#        key => "${datasetDisplayName} combined RNAseq plot",
#        label => "${datasetDisplayName} combined RNAseq plot",
#        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
#        category => "Transcriptomics",
#        autoscale => "global",
#        style => {'height' => "100",
#        },
#                  metadata => {
#                    subcategory => "RNA-Seq",
#                    dataset => $datasetDisplayName,
#                    trackType => "Multi XY plot",
#                    attribution => $shortAttribution,
#                   },
#        fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
#      };
#      push @{$result->{tracks}}, $alignment;
#   }
  }
 }
        ### Print out combinedRNAseq track for organism
        my $arrayLength = @urlArray;

    if ($arrayLength > 0){
        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
        urlTemplates =>
        \@urlArray
        ,
        showTooltips => "true",
        key => "${genomeName} combined RNAseq plot",
        label => "${genomeName} combined RNAseq plot",
        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
        category => "Transcriptomics",
        autoscale => "local",
        yScalePosition => "left",
        style => {'height' => "40",
        },
                  metadata => {
                    subcategory => "RNA-Seq",
                    dataset => "Combined all RNA-Seq data for ${genomeName}",
                    trackType => "Multi XY plot",
                    alignment => "Unique", 
                   },
      };
      push @{$result->{tracks}}, $alignment;
  }
}


sub addProteinExpressionMassSpec {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /_massSpec_/);

    my $experimentName = $datasetProperties->{$dataset}->{name};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $datasetPresenterId = $datasetProperties->{$dataset}->{datasetPresenterId};
    my $category = $datasetProperties->{$dataset}->{datasetClassCategory};

    my $datasetExtdbName = $datasetProperties->{$dataset}->{datasetExtdbName};

    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $massSpec = {storeClass => "JBrowse/Store/SeqFeature/REST",
                    baseUrl => "/a/service/jbrowse",
                    type => "JBrowse/View/Track/CanvasFeatures",
                    glyph => "JBrowse/View/FeatureGlyph/Segments",
                    subParts => "Peptide",
                    displayMode => "compact",
                    query => {'feature' => "domain:MassSpecPeptide",
                              'edName' => "like '${datasetExtdbName}'",
                    },
                    key => "${datasetDisplayName}  MS/MS Peptides  ${shortAttribution}",
                    label => "${dataset}",
                    category => "Proteomics",
                    style => {'color' => "{massSpecColor}",
                              'label' => "Sample,sample,name",
                    },
                    metadata => {
                      subcategory => 'Protein Expression',
                      dataset => $datasetDisplayName,
                      trackType => 'Segments',
                      attribution => $shortAttribution,
                      description => $summary,
                    },
                    fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetId('${datasetPresenterId}', '${datasetDisplayName}'); }",
                    fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                    onClick => {
                      content => "{massSpecDetails}",
                    },
                    menuTemplate => [
                      {label => "View Details", 
                       content => "{massSpecDetails}",
                      },
                        ],
    };

    push @{$result->{tracks}}, $massSpec;
  }
}

sub addSmallNcRnaSeq {
  my ($dbh, $result, $datasetProperties, $nameForFilenames) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /smallNcRna/);

    my $experimentName = $datasetProperties->{$dataset}->{experimentName};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select ds.name from apidb.datasource ds where ds.name like '${organismAbbrev}%_smallNcRnaSample_RSRC'";

    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset =~ /${organismAbbrev}_${experimentName}_(.+)_smallNcRnaSample_RSRC/;

      # Example: EhistolyticaHM1IMSS/bam/Singh_Small_RNA/Rahman/Rahman.bam
      my $bamUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/bam/$experimentName/${sampleName}/${sampleName}.bam");

      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/BAM",
                       urlTemplate => $bamUrl,
                           key => "${sampleName} Small Non-coding RNAs",
                           label => "${sampleName} Small Non-coding RNAs",
                           type => "SmallRNAPlugin/View/Track/smAlignments",
                           category => "Transcriptomics",
                           yScalePosition => "left",
                       unsafePopup => JSON::true,
                           metadata => {
                             subcategory => 'small non-coding RNA',
                             dataset => $datasetDisplayName,
                             trackType => 'Small RNA',
                             attribution => $shortAttribution,
                             description => $summary,
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}

sub addCentromere {
  my ($dbh, $result) = @_;
  my $sql = "select count(*) from apidbtuning.organismattributes where hasCentromere = 1 and  internal_abbrev = '${organismAbbrev}'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Box",
                 key => "Centromere",
                 label => "Centromere",
                 category => "Sequence Analysis",
                 displayMode => "normal",
                 style => {
                   color => "blue",
                 },
                 metadata => {
                   subcategory => "Sequence sites, features and motifs",
                   trackType => 'Segments',
                 },
                 query => {'feature' => "Centromere:overview",
                 },
                 onClick => {
                   content => "{positionTitle}",
                 },
                 menuTemplate => [
                   {label => "View Details", 
                    content => "{positionTitle}",
                   },
                     ],
    };

    push @{$result->{tracks}}, $track;


  }

}

sub addScaffolds {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from dots.scaffoldgapfeature sgf, apidbtuning.genomicseqattributes sa, apidb.organism o where sa.na_sequence_id = sgf.na_sequence_id and o.taxon_id = sa.taxon_id and o.abbrev = '${organismAbbrev}'";


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Box",
#                 glyph => "function(feature){ return changeScaffoldType(feature)}",
                 key => "Scaffolds and Gaps",
                 label => "Scaffolds",
                 category => "Sequence Analysis",
                 displayMode => "normal",
                 subParts => "sgap",
                    style => {
                      color => "function( feature, variableName, glyphObject, track ){ var c = track.browser.config; return c.scaffoldColor(feature)}",
                      height => "function(feature, variableName, glyphObject, track){ var c = track.browser.config; return c.scaffoldHeight(feature)}",
                    },
                    metadata => {
                      subcategory => "Sequence assembly",
                      trackType => 'Segments',
                    },
                    query => {'feature' => "scaffold:genome",
                    },
                     onClick => {
                       content => "function(track, feature){ var c = track.browser.config; return c.scaffoldDetails(track, feature)}",
                     },
                     menuTemplate => [
                       {label => "View Details", 
                        content => "function(track, feature){ var c = track.browser.config; return c.scaffoldDetails(track, feature)}",
                       },
                         ],
    };

    push @{$result->{tracks}}, $track;


  }
}

sub addSynteny {
  my ($dbh, $result) = @_;
  # Requires public_abbrev here!
  my $sql = "select otr.organism, oa.internal_abbrev as public_abbrev, otr.phylum, otr.genus, otr.species, otr.kingdom, otr.class, gt.gtracks
            from APIDBTUNING.ORGANISMSELECTTAXONRANK otr
               , APIDBTUNING.ORGANISMATTRIBUTES oa
               , (select * from APIDBTUNING.GBROWSETRACKSORGANISM where type = 'synteny' ) gt
            where oa.ORGANISM_NAME = otr.organism 
            and oa.IS_ANNOTATED_GENOME = 1
            and oa.PROJECT_ID in (select distinct name from core.projectinfo)
            and oa.ORGANISM_NAME = gt.organism (+)";

  my $hasSyntenyTracks = 0;

  my $orgGTracks;
  my %subtracks;
  my %defaults;

  my $taxonNamesToNode = {};
  my $rootNode = _Tree->new({_name => 'root'});
  my $refOrganism;


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  while(my ($organism, $publicAbbrev, $phylum, $genus, $species, $kingdom, $class, $gTracks) = $sh->fetchrow_array()) {
    if($publicAbbrev eq $organismAbbrev) {
      $hasSyntenyTracks = 1;
      $gTracks =~ s/^.+Synteny\///;
      %defaults = map { $_ => 1 } split(/\+/, $gTracks);
      $refOrganism = $organism;
    }
    my $kingdomNode = &makeTreeNode('k_' . $rootNode, $kingdom, $taxonNamesToNode, $rootNode);
    my $phylumNode = &makeTreeNode('p_' . $kingdom, $phylum, $taxonNamesToNode, $kingdomNode);
    my $classNode = &makeTreeNode('c_'. $phylum, $class, $taxonNamesToNode, $phylumNode);
    my $genusNode = &makeTreeNode('g_'. $class, $genus, $taxonNamesToNode, $classNode);
    my $speciesNode = &makeTreeNode('s_'. $genus, $species, $taxonNamesToNode, $genusNode);
    my $strainNode = &makeTreeNode('', $organism, $taxonNamesToNode, $speciesNode);

    # stuff these things in the leaf nodes
    $strainNode->setAbbrev($publicAbbrev);
    $strainNode->setFeatureFilters({ "taxon" => $organism});
    $strainNode->setMetadata({"Kingdom" => $kingdom,
                              "Phylum" => $phylum,
                              "Class" => $class,
                              "Genus" => $genus,
                              "Species" => $species 
                             });
  }
  $sh->finish();

  if($hasSyntenyTracks) {
    my $subtracksAr = [];

    my $refOrganismNode = $taxonNamesToNode->{$refOrganism};

    &addSubtracks($subtracksAr, $refOrganismNode, $taxonNamesToNode, \%defaults, $organismAbbrev);

    my $syntenyTrack = {storeClass => "EbrcTracks/Store/SeqFeature/REST",
                        baseUrl => "/a/service/jbrowse",
                        type => "EbrcTracks/View/Track/Synteny",
                        transcriptType => "processed_transcript",
                        noncodingType => ["nc_transcript"],
                        glyph => "function(f){return f.get('syntype') === 'span' ? 'JBrowse/View/FeatureGlyph/Box' : 'JBrowse/View/FeatureGlyph/Gene'; }",
                        subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon,pseudogenic_exon",
                        key => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        label => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        region_feature_densities => "function(){return false}",
                        category => "Comparative Genomics",
			unsafePopup => JSON::true,
                        geneGroupAttributeName => "orthomcl_name",
                        displayMode => "normal",

                        style => {
                          color => "{syntenyColorFxn}",
                          unprocessedTranscriptColor => "lightgrey",
                          utrColor => "grey",
#                          borderWidth => 4,
                          connectorThickness => "function(f){return f.get('syntype') === 'span' ? 3 : 1; }",
                          showLabels => "function(){return false}",
                          strandArrow => "function(f){return f.get('syntype') === 'span' ? false : true; }",
                          height => "function(f){return f.get('syntype') === 'span' ? 2 : 5; }",
#                          height => 5,
                          marginBottom => 0,
                       },
                        metadata => {
                          subcategory => "Orthology and Synteny",
                          trackType => 'Segments',
                        },
                        query => {'feature' => "gene:syntenyJBrowseScaled"
                        },
                        subtracks => $subtracksAr,
                        onClick => {
                          content => "{syntenyTitleFxn}",
                        },
                        menuTemplate => [
                          {label => "View Details", 
                           content => "{syntenyTitleFxn}",
                          },
                          {label => "View Gene or Sequence Page",
                           title => "function(track,f) { return f.get('syntype') == 'span' ? f.get('contig') : f.get('name'); }", 
                           iconClass => "dijitIconDatabase", 
                           action => "iframeDialog", 
                           url => "function(track,f) { return f.get('syntype') == 'span' ? '/a/app/record/genomic-sequence/' + f.get('contig') : '/a/app/record/gene/' + f.get('name') }"}
                            ],
    };
    
    push @{$result->{tracks}}, $syntenyTrack;


  }

}



sub addSubtracks {
  my ($subtracks, $node, $taxonNamesToNode, $defaults, $organismAbbrev) = @_;

  return if($node->getAlreadySeen());
  return if($node->isRoot());

  if($node->isLeaf()) {
    my $abbrev = $node->getAbbrev();

    foreach my $type ("gene", "span") {
      my $metadataClone = dclone $node->getMetadata();
      my $ffClone = dclone $node->getFeatureFilters();
      $ffClone->{syntype} = $type;

      my $label = "${abbrev}_${type}";

      my $visible = $abbrev eq $organismAbbrev || $defaults->{$label} ? 'true' : 'false';

      my $subtrack = {featureFilters => $ffClone,
                      metadata => $metadataClone,
                      label => "$abbrev $type",
                      visible => $visible
      };
      push @$subtracks, $subtrack;
    }
  }
  else {
    my $children = $node->getChildren();

    foreach my $child (@$children) {
      &addSubtracks($subtracks, $child, $taxonNamesToNode, $defaults, $organismAbbrev);
    }
  }

  $node->setAlreadySeen(1);

  my $parent = $node->getParent();
  
  &addSubtracks($subtracks, $parent, $taxonNamesToNode, $defaults, $organismAbbrev);
}

sub makeTreeNode {
  my ($prefix, $name, $taxonNamesToNode, $parentNode) = @_;

  my $key = $prefix . $name;

  my $node = $taxonNamesToNode->{$key};
  unless($node) {
    $node = _Tree->new({_parent => $parentNode, _name => $name});
    $parentNode->addChild($node);
  }
  
  $taxonNamesToNode->{$key} = $node;

  return $node;
}


sub addUnifiedSnp {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%HTS_SNP_%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $snpCount = $sh->fetchrow_array();
  $sh->finish();

  if($snpCount > 0) {

    my $desc ="The SNPs in this track are gathered from the high-throughput sequencing data of multiple strains and isolates. For more details on the methods used, go to the Data menu, choose Analysis Methods, and then scroll down to the Genetic Variation and SNP calling section. SNPs in this track are represented as colored diamonds, where dark blue = non-synonymous, light blue = synonymous, red = nonsense, and yellow = non-coding.";
    my $snpTrack = {storeClass => "JBrowse/Store/SeqFeature/REST",
                    baseUrl => "/a/service/jbrowse",
                    type => "JBrowse/View/Track/CanvasFeatures",
                    glyph => "EbrcTracks/View/FeatureGlyph/Diamond",
                    key => "SNPs by coding potential",
                    label => "SNPs by coding potential",
                    maxFeatureScreenDensity => 0.01,
                    region_feature_densities => "function(){return true}",
                    category => "Genetic Variation",
                    displayMode => "normal",
                    style => {
                      color => "{snpColorFxn}",
                      strandArrow => "function(){return false}",
                      labelScale => 1000000000000000, #some really big number so labels are not shown; showLabels=false not working here or in hook TODO
                    },
                    metadata => {
                      subcategory => "DNA polymorphism",
                      trackType => 'Unified SNPs',
		      description => $desc
                    },
                    query => {'feature' => "SNP:Population",
                              'edname' => 'InsertSnps.pm NGS SNPs INTERNAL'
                    },
                     onClick => {
                       content => "{snpTitleFxn}",
                     },
                     menuTemplate => [
                       {label => "View Details", 
                        content => "{snpTitleFxn}",
                       },
                         ],
    };

    push @{$result->{tracks}}, $snpTrack;

  }

}

sub addUnifiedMassSpec {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%massSpec%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $massSpecCount = $sh->fetchrow_array();
  $sh->finish();

  if($massSpecCount > 0) {
    my $unifiedMassSpecTrack = {storeClass => "JBrowse/Store/SeqFeature/REST",
                                baseUrl => "/a/service/jbrowse",
                                type => "JBrowse/View/Track/CanvasFeatures",
                                key => "All MS/MS Peptides",
                                label => "UnifiedMassSpecPeptides",
                                maxFeatureScreenDensity => 0.01,
                                region_feature_densities => "function(){return true}",
                                category => "Proteomics",
                                displayMode => "compact",
                                style => {
                                  color => "{massSpecColor}",
                                },
                                metadata => {
                                  subcategory => "Protein Expression",
                                  trackType => 'Segments',
                                },
                                query => {'feature' => "domain:UnifiedMassSpecPeptides",
                                },
                                onClick => {
                                  content => "{massSpecDetails}",
                                },
                                menuTemplate => [
                                  {label => "View Details", 
                                   content => "{massSpecDetails}",
                                  },
                                    ],
    };

    push @{$result->{tracks}}, $unifiedMassSpecTrack;

  }


}

sub addChipChipTracks {
  my ($dbh, $result, $datasetProperties) = @_;

 my $sql = "select d.name, s.name, pan.name, pan.protocol_app_node_id
from study.study s
   , SRES.EXTERNALDATABASERELEASE r
   , SRES.EXTERNALDATABASE d
   , study.protocolappnode pan
   , study.studylink sl
where d.name like '${organismAbbrev}%_chipChipExper_%'
and s.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and s.investigation_id is null";


  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($dataset, $study, $panName, $panId) = $sh->fetchrow_array()) {
    if($panName =~ /_peaks \(ChIP-chip\)/) {
        my $peakTrack = &makeChipChipPeak($dataset, $study, $panName, $panId, $datasetProperties);
        push @{$result->{tracks}}, $peakTrack;
    }
    if($panName =~ /_smoothed \(ChIP-chip\)/) {
      my $track = &makeChipChipSmoothed($dataset, $study, $panName, $panId, $datasetProperties);
      push @{$result->{tracks}}, $track;
    }
  }
 
  $sh->finish();
}


sub makeChipChipPeak {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $datasetPresenterId = $datasetProperties->{$dataset}->{datasetPresenterId};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $cutoff = $datasetProperties->{$dataset}->{cutoff} || 0;
  
  my $colorFunction = $cutoff ? "colorSegmentByScore" : "chipColor";

  my $peaks = {storeClass => "JBrowse/Store/SeqFeature/REST",
                  baseUrl => "/a/service/jbrowse",
                  type => "JBrowse/View/Track/CanvasFeatures",
                  key => $key,
                  label => $key,
                  category => "Epigenomics",
                  style => {
                    color => "{$colorFunction}",
                  },
                  metadata => {
                    subcategory => "ChIP chip",
                    dataset => $datasetDisplayName,
                    trackType => 'Segments',
                    attribution => $shortAttribution,
                    description => $summary,
                   },
                   fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetId('${datasetPresenterId}', '${datasetDisplayName}'); }",
                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                  query => {'feature' => "ChIP:ChIPchip_peaksjbrowse",
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'cutoff' => $cutoff,
                            'panId' => $panId,
                  },
               onClick => {
                 content => "{peakTitleChipSeqFxn}",
               },
               menuTemplate => [
                 {label => "View Details", 
                  content => "{peakTitleChipSeqFxn}",
                 },
                   ],
    };


  return $peaks;


}

sub addCnvArray {
  my ($dbh, $result) = @_;

  my $sql = "select distinct pan.name
from study.protocolappnode pan
   , study.study s
   , study.studylink sl
where pan.PROTOCOL_APP_NODE_ID = sl.PROTOCOL_APP_NODE_ID
and sl.study_id = s.study_id
and s.name like 'tcruCLBrenerEsmeraldo-like_cghArrayExper_Tarelton_GSE23576_CNV_RSRC%'
order by pan.name";
  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my $desc = "Comparative Genomic Hybridization to determine regions of significant Copy Number Variation in <i>T. cruzi</i> strains with strain CL Brener as reference. Type I strains used include: Brazil, Chinata, Colombiana, M78, Montalvania, PalDa1 (clone 9), SylvioX10/4, TCC, TEDa2 (clone 4), TEP6 (clone 5). Type II-VI strains used include: Esmeraldo, M5631, Tu18 (clone 1), Tulahuen, wtCL, Y. Scores from Type I strain is shown in Green and from Type II-VI are show in Brown. Score value represents the number of strains showing CNV , with a postive score implying amplification and a negative score implying deletion with respect to CL Brener. CNV criteria: minimum log2 ratio of signal intensities (test strain/reference) +/- 0.6, minimum number of probes 5. For more details refer the following manuscript: <a href=\"http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3060142/\">Widespread, focal copy number variations (CNV) and whole chromosome aneuploidies in Trypanosoma cruzi strains revealed by array comparative genomic hybridization</a> ";

  while(my ($name) = $sh->fetchrow_array()) {


    my $cnv = {storeClass => "JBrowse/Store/SeqFeature/REST",
               baseUrl => "/a/service/jbrowse",
               type => "JBrowse/View/Track/Wiggle/XYPlot",
               key => $name,
               label => $name,
               category => "Genetic Variation",
               style => {height => 40},
               metadata => {
                 subcategory => "CGH Array",
                 dataset => "Comparative Genomic Hybridizations of 33 strains",
                 trackType => 'XYPlot',
                 description => $desc,
               },
               fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('tcruCLBrenerEsmeraldo-like_cghArrayPlatform_GPL10781_RSRC', 'Comparative Genomic Hybridizations of 33 strains'); }",
               fmtMetaValue_Description => "function() { return datasetDescription('${desc}', ''); }",
               query => {'feature' => "cnv:ArrayJBrowse",
                         'sample' => $name,
               },
               max_score => 3,
               min_score => -3,
               yScalePosition => "left"
    };
    push @{$result->{tracks}}, $cnv;

  }
  $sh->finish();
}

sub makeChipChipSmoothed {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

#  my $datasetKey = $datasetProperties->{$dataset}->{key};
#  my $key = $datasetKey ? "${panName} ${datasetKey}" : $panName; # no longer valid??
  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $smoothed = {storeClass => "JBrowse/Store/SeqFeature/REST",
                  baseUrl => "/a/service/jbrowse",
                  type => "JBrowse/View/Track/Wiggle/XYPlot",
                  key => $key,
                  label => $key,
                  category => "Epigenomics",
                  style => {
                    pos_color => "{chipColor}",
                    neg_color => "{chipColor}",
                    height => 40,
                  },
                  metadata => {
                    subcategory => "ChIP chip",
                    dataset => $datasetDisplayName,
                    trackType => 'XYPlot',
                    attribution => $shortAttribution,
                    description => $summary,
                   },
                   fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                  query => {'feature' => "ChIP:ChIPchip_smoothedjbrowse",
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'panId' => $panId
                  },
                  max_score => 3,
                  min_score => -3,
                  yScalePosition => "left"
    };


  return $smoothed;
}


sub addNrdbProteinAlignments {
  my ($dbh, $result, $datasetProperties, $projectName, $nameForFileNames) = @_;

  my $proteinAlignTrack;
    my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/nrProteinsToGenomeAlign/result.sorted.gff.gz");

    my $methodDescription = "<p>NCBI's non redundant collection of proteins (nr) was filtered for deflines matching the Genus of this sequence.  These proteins were aligned using <a href='https://www.ebi.ac.uk/about/vertebrate-genomics/software/exonerate'>exonerate</a>. (protein to genomic sequence)</p>";

    $proteinAlignTrack = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
                          urlTemplate => $gffUrl,
                          key => "NRDB Protein Alignments",
                          label => "NRDB Protein Alignments",
                          category => "Sequence Analysis",
                          type => "JBrowse/View/Track/CanvasFeatures",
                          glyph => "JBrowse/View/FeatureGlyph/Segments",
                          fmtMetaValue_Description => "function(){return datasetDescription(\"$methodDescription\", \"\");}",
                          metadata => {
                            subcategory => "BLAT and Blast Alignments",
                            trackType => 'Segments',
                            description => $methodDescription,
                          },
                          onClick => {
                            content => "{nrdbGffDetails}", title => "----------------------------- {id} -----------------------------",
                          },
                          menuTemplate => [
                            {label =>  "View Details", content => "{nrdbGffDetails}", title => "----------------------------- {id} -----------------------------",}, 
                            {label => "View in Genbank",title => "Genbank {name}", iconClass => "dijitIconDatabase", action => "newWindow", url => "https://www.ncbi.nlm.nih.gov/protein/{name}"}
                              ],
                          style => {
                            color => "{nrdbColor}",
                            borderColor => "{processedTranscriptBorderColor}"
                          },
                          displayMode => "compact",

      };

    push @{$result->{tracks}}, $proteinAlignTrack;

}

sub addTRNA {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from dots.rnafeature rnaf, sres.ontologyterm ot
where ot.ontology_term_id = rnaf.sequence_ontology_id
and ot.name ='tRNA'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Box",
                 key => "tRNAscan",
                 label => "tRNAscan",
                 category => "Sequence Analysis",
                 displayMode => "normal",
                 style => {
                   color => "white",
		   borderColor => "{processedTranscriptBorderColor}"
                 },
                 metadata => {
                   subcategory => "Sequence sites, features and motifs",
                   trackType => 'Segments',
                 },
                 query => {'feature' => "domain:tRNA",
                 },
                 onClick => {
                   content => "{positionTitle}",
                 },
                 menuTemplate => [
                   {label => "View Details",
                    content => "{positionTitle}",
                   },
                     ],
    };
    push @{$result->{tracks}}, $track;
  }
}


sub addPopsets {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.popsetAttributes";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Box",
                 key => "Popset Isolate Sequence Alignments",
                 label => "popsetIsolates",
		 maxFeatureScreenDensity => 0.03,
                 region_feature_densities => "function(){return true}",
                 category => "Sequence Analysis",
                 displayMode => "compact",
                 style => {
                   color => "{popsetColor}",
                 },
                 metadata => {
                   subcategory => "BLAT and Blast Alignments",
                   trackType => 'Segments',
                 },
                 query => {'feature' => "match:IsolatePopset",
                 },
                 onClick => {
                   content => "{popsetDetails}",
                 },
                 menuTemplate =>
		 [
		  {label => "View Details",
		   content => "{popsetDetails}",
		  },
		  {label => "View Popset Sequence Page",
		   title => "{popsetDetails}",
		   iconClass => "dijitIconDatabase",
		   action => "newWindow",
		   url => "/a/app/record/popsetSequence/{name}",
		  },
		 ],
		};
    push @{$result->{tracks}}, $track;
  }
}

sub addAntismash {
  my ($result, $nameForFilenames, $webservicesDir, $projectName) = @_;

  my $gffUrl = "/a/service/jbrowse/auxiliary?data=${projectName}/antismash/" . uri_escape_utf8("${nameForFilenames}.sorted.gff.gz");


  my $description = "Secondary metabolite gene clusters as predicted using antiSmash version 7.1 under default parameters";

  my $track = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
               urlTemplate => $gffUrl,
               transcriptType => 'function(f) { return f.children()[0].get("type")}', # we have exactly 1 transcript per gene.  BUT it may be called either mRNA or transcript
               category => "Sequence Analysis",
               type => "CanvasFeatures",
               key => "Secondary Metabolites (antiSMASH)",
               label => "antibiotics and Secondary Metabolites Analysis SHell (antiSMASH)",
               subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon,pseudogenic_exon,proto_core",
               style => {label => "{antismashLabel}",
                         color => "{antismashColor}",
                         utrColor => "white",
                         borderColor => "black",

               },
               metadata => {
                 subcategory => "Secondary Metabolites",
                 description => $description,
                 "Gene Legend" => "<img src='https://microscope.readthedocs.io/en/stable/_images/antiSMASH6_colorcode_features.png'/>",
                 "Region Legend" => "<img src='/a/images/antismash_cluster_colors.png'  height='250' width='250' align=left/>",
               },
               unsafePopup => JSON::true

  };
  push @{$result->{tracks}}, $track;
  
}


sub addLongReadRNASeq {
  my ($result, $datasetProperties, $nameForFileNames, $webservicesDir) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /nanopore_rnaSeqNextflow/);

    

    my $datasetName = $datasetProperties->{$dataset}->{datasetName};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $datasetPresenterId = $datasetProperties->{$dataset}->{datasetPresenterId};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution}; 

    #----------------------------


    my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/longReadRNASeq/gff/${datasetName}/${datasetName}\_sorted_updated.gff.gz");
    my $featuresTrack = {storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
                         urlTemplate => $gffUrl,
                         key => "${datasetDisplayName} all models",
                         label => "${datasetName}_all_models",
                         category => "Gene Models",
                         glyph => "JBrowse/View/FeatureGlyph/ProcessedTranscript",
                         type => "NeatCanvasFeatures/View/Track/NeatFeatures",
                         fmtMetaValue_Description => "function(){return datasetDescription(\"$summary\", \"\");}",
                         metadata => {
                             subcategory => "Long Read RNA-Seq",
                             dataset => $datasetDisplayName,
                             trackType => 'All Gene Models',
                             description => $summary,
                         },
                         displayMode => "normal",
                         transcriptType => "transcript",
                         topLevelFeatures => "transcript",
                         subParts => "exon",
                         impliedUTRs => JSON::true,
                         topLevelFeaturesPercent => 33,

                         onClick => {
                             action => "iframeDialog",
                             hideIframeDialogUrl =>  JSON::true,
                             url => "/a/app/embed-record/long_read_transcript/{transcript_id}_${datasetPresenterId}?tables=SampleInfo"
                         },
                         menuTemplate => [
                             {label =>  "View Details", content => "{longReadRnaSeqGffDetails}"},
                             ],

                         style => {
                             showLabels => JSON::false,
                             label => "function(f){return \"Model is \" + f.get(\"transcript_status\") + \"; Supporting Reads=\" + f.get(\"totalCount\");}",
                             color => "{processedApolloTranscriptColor}",
                             borderColor => "{processedTranscriptBorderColor}",
                         },

    };

    my $highConfidenceFeaturesTrack = { storeClass => "JBrowse/Store/SeqFeature/GFF3Tabix",
                                        urlTemplate => $gffUrl,
                                        key => "${datasetDisplayName} high confidence models (> 5 supporting reads)",
                                        label => "${datasetName}_high_confidence_models",
                                        category => "Gene Models",
                                        glyph => "JBrowse/View/FeatureGlyph/ProcessedTranscript",
                                        type => "EbrcTracks/View/Track/GFFByReadCount",
                                        fmtMetaValue_Description => "function(){return datasetDescription(\"$summary\", \"\");}",
                                        metadata => {
                                            subcategory => "Long Read RNA-Seq",
                                            dataset => $datasetDisplayName,
                                            trackType => "High Confidence Gene Models",
                                            description => $summary,
                                        },
                                        displayMode => "normal",
                                        transcriptType => "transcript",
                                        topLevelFeatures => "transcript",
                                        subParts => "exon",
                                        impliedUTRs => JSON::true,
                                        topLevelFeaturesPercent => 33,

                                        onClick => {
                                            action => "iframeDialog",
                                            hideIframeDialogUrl => JSON::true,
                                            url => "/a/app/embed-record/long_read_transcript/{transcript_id}_${datasetPresenterId}?tables=SampleInfo"
                                        },
                                        menuTemplate => [
                                            {label => "View Details", content => "{longReadRnaSeqGffDetails}"},
                                            ],

                                        style => {
                                            showLabels => JSON::false,
                                            label => "function(f){return \"Model is \" + f.get(\"transcript_status\") + \"; Supporting Reads=\" + f.get(\"totalCount\");}",
                                            color => "{processedApolloTranscriptColor}",
                                            borderColor => "{processedTranscriptBorderColor}",
                                        },
    };

    push @{$result->{tracks}}, $highConfidenceFeaturesTrack;
	push @{$result->{tracks}}, $featuresTrack; 


    

    #----------------------------
    my $metadataFile = "${webservicesDir}/$projectName/build-${buildNumber}/${nameForFileNames}/longReadRNASeq/bam/${datasetName}/metadata.txt";

    open(FILE, $metadataFile) or die "Cannot open file $metadataFile for reading: $!";
    while(<FILE>) {
      chomp;
      my ($sampleType, $sampleFile, $sampleDisplayName) = split(/\t/, $_);


      my $bamUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFilenames}/longReadRNASeq/bam/${datasetName}/${sampleFile}");

      my $alignment = {     storeClass => "JBrowse/Store/SeqFeature/BAM",
                            urlTemplate => $bamUrl,
                            key => "${sampleDisplayName} long read RNA-Seq",
                            label => "${sampleDisplayName} long read RNA-Seq",
                            type => "JBrowse/View/Track/Alignments2",
                            category => "Transcriptomics",
                            yScalePosition => "left",
                            unsafePopup => JSON::true,
                            metadata => {
                                subcategory => 'Long Read RNA-Seq',
                                dataset => $datasetDisplayName,
                                trackType => 'Long Read Bam alignment',
                                attribution => $shortAttribution,
                                description => $summary,
                           },
			 style => { 
                     color_fwd_strand => "#898FD8",
                     color_rev_strand => "#EC8B8B",
                         },
             fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
             fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}



1;


package _Tree; 

use strict;

sub getName {$_[0]->{_name}}

sub setAlreadySeen {$_[0]->{_seen} = $_[1]}
sub getAlreadySeen {$_[0]->{_seen}}

sub setAbbrev {$_[0]->{_abbrev} = $_[1]}
sub getAbbrev {$_[0]->{_abbrev}}

sub setFeatureFilters {$_[0]->{_feature_filters} = $_[1]}
sub getFeatureFilters {$_[0]->{_feature_filters}}

sub setMetadata {$_[0]->{_metadata} = $_[1]}
sub getMetadata {$_[0]->{_metadata}}

sub getParent {$_[0]->{_parent}}

sub getChildren {$_[0]->{_children} || [] }

sub addChild {push @{$_[0]->{_children}}, $_[1]}

sub isLeaf {
  my ($self) = @_;
  my $children = $self->getChildren();
  return scalar @$children == 0;
}

sub isRoot {
  my ($self) = @_;
  return !defined($self->getParent());
}

sub new {
  my ($class, $args) = @_;

  return bless $args, $class;
}

1;
